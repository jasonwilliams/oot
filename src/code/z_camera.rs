#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case,
         non_upper_case_globals, unused_assignments, unused_mut)]
#![register_tool(c2rust)]
#![feature(const_raw_ptr_to_usize_cast, const_transmute, register_tool)]
extern "C" {
    #[no_mangle]
    fn fabsf(f: f32_0) -> f32_0;
    #[no_mangle]
    fn osSyncPrintf(fmt: *const libc::c_char, _: ...);
    #[no_mangle]
    fn Player_GetHeight(player: *mut Player) -> f32_0;
    #[no_mangle]
    fn func_8002DCE4(player: *mut Player) -> f32_0;
    #[no_mangle]
    fn func_8002DF38(globalCtx: *mut GlobalContext, actor: *mut Actor,
                     csMode: u8_0) -> s32;
    #[no_mangle]
    fn func_8002DF54(globalCtx: *mut GlobalContext, actor: *mut Actor,
                     arg2: u8_0) -> s32;
    #[no_mangle]
    fn Actor_GetFocus(arg0: *mut PosRot, actor: *mut Actor) -> *mut PosRot;
    #[no_mangle]
    fn Actor_GetWorld(arg0: *mut PosRot, actor: *mut Actor) -> *mut PosRot;
    #[no_mangle]
    fn Actor_GetWorldPosShapeRot(arg0: *mut PosRot, actor: *mut Actor)
     -> *mut PosRot;
    #[no_mangle]
    fn Actor_GetScreenPos(globalCtx: *mut GlobalContext, actor: *mut Actor,
                          x: *mut s16, y: *mut s16);
    #[no_mangle]
    fn CollisionPoly_GetPointDistanceFromPlane(poly: *mut CollisionPoly,
                                               point: *mut Vec3f) -> f32_0;
    #[no_mangle]
    fn BgCheck_EntityRaycastFloor3(colCtx: *mut CollisionContext,
                                   outPoly: *mut *mut CollisionPoly,
                                   bgId: *mut s32, pos: *mut Vec3f) -> f32_0;
    #[no_mangle]
    fn BgCheck_EntityRaycastFloor5(globalCtx: *mut GlobalContext,
                                   colCtx: *mut CollisionContext,
                                   outPoly: *mut *mut CollisionPoly,
                                   bgId: *mut s32, actor: *mut Actor,
                                   pos: *mut Vec3f) -> f32_0;
    #[no_mangle]
    fn BgCheck_CameraRaycastFloor2(colCtx: *mut CollisionContext,
                                   outPoly: *mut *mut CollisionPoly,
                                   bgId: *mut s32, pos: *mut Vec3f) -> f32_0;
    #[no_mangle]
    fn BgCheck_CameraLineTest1(colCtx: *mut CollisionContext,
                               posA: *mut Vec3f, posB: *mut Vec3f,
                               posResult: *mut Vec3f,
                               outPoly: *mut *mut CollisionPoly, chkWall: s32,
                               chkFloor: s32, chkCeil: s32, chkOneFace: s32,
                               bgId: *mut s32) -> s32;
    #[no_mangle]
    fn SurfaceType_GetCamDataIndex(colCtx: *mut CollisionContext,
                                   poly: *mut CollisionPoly, bgId: s32)
     -> u32_0;
    #[no_mangle]
    fn func_80041A4C(colCtx: *mut CollisionContext, camId: u32_0, bgId: s32)
     -> u16_0;
    #[no_mangle]
    fn SurfaceType_GetNumCameras(colCtx: *mut CollisionContext,
                                 poly: *mut CollisionPoly, bgId: s32)
     -> u16_0;
    #[no_mangle]
    fn func_80041C10(colCtx: *mut CollisionContext, camId: s32, bgId: s32)
     -> *mut Vec3s;
    #[no_mangle]
    fn SurfaceType_GetCamPosData(colCtx: *mut CollisionContext,
                                 poly: *mut CollisionPoly, bgId: s32)
     -> *mut Vec3s;
    #[no_mangle]
    fn func_80041D4C(colCtx: *mut CollisionContext, poly: *mut CollisionPoly,
                     bgId: s32) -> u32_0;
    #[no_mangle]
    fn WaterBox_GetSurface1(globalCtx: *mut GlobalContext,
                            colCtx: *mut CollisionContext, x: f32_0, z: f32_0,
                            ySurface: *mut f32_0,
                            outWaterBox: *mut *mut WaterBox) -> s32;
    #[no_mangle]
    fn WaterBox_GetCamDataIndex(colCtx: *mut CollisionContext,
                                waterBox: *mut WaterBox) -> u32_0;
    #[no_mangle]
    fn WaterBox_GetCameraSType(colCtx: *mut CollisionContext,
                               waterBox: *mut WaterBox) -> u16_0;
    #[no_mangle]
    fn WaterBox_GetLightSettingIndex(colCtx: *mut CollisionContext,
                                     waterBox: *mut WaterBox) -> u32_0;
    #[no_mangle]
    fn func_800427B4(polyA: *mut CollisionPoly, polyB: *mut CollisionPoly,
                     pointA: *mut Vec3f, pointB: *mut Vec3f,
                     closestPoint: *mut Vec3f) -> s32;
    #[no_mangle]
    fn CollisionCheck_LineOCCheck(globalCtx: *mut GlobalContext,
                                  colChkCtx: *mut CollisionCheckContext,
                                  a: *mut Vec3f, b: *mut Vec3f,
                                  exclusions: *mut *mut Actor,
                                  numExclusions: s32) -> s32;
    #[no_mangle]
    fn func_8006376C(x: u8_0, y: u8_0, colorId: u8_0,
                     text: *const libc::c_char);
    #[no_mangle]
    fn func_80064534(globalCtx: *mut GlobalContext,
                     csCtx: *mut CutsceneContext);
    #[no_mangle]
    fn Environment_EnableUnderwaterLights(globalCtx: *mut GlobalContext,
                                          waterLightsIndex: s32);
    #[no_mangle]
    fn Environment_DisableUnderwaterLights(globalCtx: *mut GlobalContext);
    #[no_mangle]
    fn Math_CosS(angle: s16) -> f32_0;
    #[no_mangle]
    fn Math_SinS(angle: s16) -> f32_0;
    #[no_mangle]
    fn func_80078884(sfxId: u16_0);
    #[no_mangle]
    fn ZeldaArena_MallocDebug(size: u32_0, file: *const libc::c_char,
                              line: s32) -> *mut libc::c_void;
    #[no_mangle]
    fn ZeldaArena_FreeDebug(ptr: *mut libc::c_void, file: *const libc::c_char,
                            line: s32);
    #[no_mangle]
    fn OLib_Vec3fDist(a: *mut Vec3f, b: *mut Vec3f) -> f32_0;
    #[no_mangle]
    fn OLib_Vec3fDistXZ(a: *mut Vec3f, b: *mut Vec3f) -> f32_0;
    #[no_mangle]
    fn OLib_ClampMaxDist(val: f32_0, max: f32_0) -> f32_0;
    #[no_mangle]
    fn OLib_Vec3fDistNormalize(dest: *mut Vec3f, a: *mut Vec3f, b: *mut Vec3f)
     -> *mut Vec3f;
    #[no_mangle]
    fn OLib_VecSphGeoToVec3f(dest: *mut Vec3f, sph: *mut VecSph)
     -> *mut Vec3f;
    #[no_mangle]
    fn OLib_Vec3fToVecSphGeo(arg0: *mut VecSph, arg1: *mut Vec3f)
     -> *mut VecSph;
    #[no_mangle]
    fn OLib_Vec3fDiffToVecSphGeo(arg0: *mut VecSph, a: *mut Vec3f,
                                 b: *mut Vec3f) -> *mut VecSph;
    #[no_mangle]
    fn OnePointCutscene_Init(globalCtx: *mut GlobalContext, csId: s16,
                             timer: s16, actor: *mut Actor, camIdx: s16)
     -> s16;
    #[no_mangle]
    fn Interface_ChangeAlpha(alphaType: u16_0);
    #[no_mangle]
    static mut gGameInfo: *mut GameInfo;
    #[no_mangle]
    fn DbCamera_Init(dbCamera: *mut DbCamera, cameraPtr: *mut Camera);
    #[no_mangle]
    fn DbCamera_Reset(cam: *mut Camera, dbCam: *mut DbCamera);
    #[no_mangle]
    fn func_80106860(ptr: *mut libc::c_void, val: s32, size: size_t)
     -> *mut libc::c_void;
    #[no_mangle]
    fn Audio_SetExtraFilter(_: u8_0);
    #[no_mangle]
    fn Quake_RemoveFromIdx(idx: s16) -> u32_0;
    #[no_mangle]
    fn Quake_SetCountdown(idx: s16, value: s16) -> u32_0;
    #[no_mangle]
    fn Quake_SetQuakeValues(idx: s16, y: s16, x: s16, zoom: s16, rotZ: s16)
     -> u32_0;
    #[no_mangle]
    fn Quake_SetSpeed(idx: s16, value: s16) -> u32_0;
    #[no_mangle]
    fn Quake_Add(cam: *mut Camera, callbackIdx: u32_0) -> s16;
    #[no_mangle]
    fn Quake_GetCountdown(idx: s16) -> s16;
    #[no_mangle]
    static mut gSaveContext: SaveContext;
    #[no_mangle]
    fn func_800AA358(view: *mut View, eye: *mut Vec3f, lookAt: *mut Vec3f,
                     up: *mut Vec3f);
    #[no_mangle]
    fn View_SetScale(view: *mut View, scale: f32_0);
    #[no_mangle]
    fn func_800AA814(view: *mut View);
    #[no_mangle]
    fn func_800AA7AC(view: *mut View, arg1: f32_0) -> s32;
    #[no_mangle]
    fn func_800AA78C(view: *mut View, arg1: f32_0, arg2: f32_0, arg3: f32_0);
    #[no_mangle]
    fn func_800AA76C(view: *mut View, arg1: f32_0, arg2: f32_0, arg3: f32_0);
    #[no_mangle]
    fn Quake_Calc(camera: *mut Camera, camData: *mut QuakeCamCalc) -> s16;
    #[no_mangle]
    fn DbCamera_Update(dbCamera: *mut DbCamera, cam: *mut Camera);
    #[no_mangle]
    fn DbgCamera_Enable(dbCamera: *mut DbCamera, cam: *mut Camera);
    #[no_mangle]
    fn ShrinkWindow_SetVal(value: s32);
    #[no_mangle]
    fn ShrinkWindow_SetCurrentVal(nowVal: s32);
    #[no_mangle]
    fn Rand_ZeroOne() -> f32_0;
    #[no_mangle]
    fn func_800BB2B4(pos: *mut Vec3f, roll: *mut f32_0, fov: *mut f32_0,
                     point: *mut CutsceneCameraPoint, keyframe: *mut s16,
                     curFrame: *mut f32_0) -> s32;
    #[no_mangle]
    fn Gameplay_GetCamera(globalCtx: *mut GlobalContext, camId: s16)
     -> *mut Camera;
    #[no_mangle]
    fn Math_FAtan2F(y: f32_0, x: f32_0) -> f32_0;
    #[no_mangle]
    fn func_800C0D34(globalCtx: *mut GlobalContext, actor: *mut Actor,
                     yaw: *mut s16) -> s32;
    #[no_mangle]
    fn Math3D_LineClosestToPoint(line: *mut Linef, pos: *mut Vec3f,
                                 closestPoint: *mut Vec3f);
    #[no_mangle]
    fn Math3D_Cos(a: *mut Vec3f, b: *mut Vec3f) -> f32_0;
    #[no_mangle]
    fn sinf(_: f32_0) -> f32_0;
    #[no_mangle]
    fn Math3D_LineSegVsPlane(nx: f32_0, ny: f32_0, nz: f32_0,
                             originDist: f32_0, linePointA: *mut Vec3f,
                             linePointB: *mut Vec3f, intersect: *mut Vec3f,
                             fromFront: s32) -> s32;
    #[no_mangle]
    fn Math_FTanF(x: f32_0) -> f32_0;
    #[no_mangle]
    fn func_800F4010(pos: *mut Vec3f, sfxId: u16_0, _: f32_0);
    #[no_mangle]
    fn Gameplay_ClearCamera(globalCtx: *mut GlobalContext, camId: s16);
    #[no_mangle]
    fn Gameplay_ChangeCameraStatus(globalCtx: *mut GlobalContext, camId: s16,
                                   status: s16) -> s16;
}
pub type s8 = libc::c_schar;
pub type u8_0 = libc::c_uchar;
pub type s16 = libc::c_short;
pub type u16_0 = libc::c_ushort;
pub type s32 = libc::c_int;
pub type u32_0 = libc::c_uint;
pub type u64_0 = libc::c_ulonglong;
pub type f32_0 = libc::c_float;
pub type Mtx_t = [[libc::c_long; 4]; 4];
#[derive(Copy, Clone)]
#[repr(C)]
pub union Mtx {
    pub m: Mtx_t,
    pub c2rust_unnamed: C2RustUnnamed,
    pub forc_structure_alignment: libc::c_longlong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed {
    pub intPart: [[u16_0; 4]; 4],
    pub fracPart: [[u16_0; 4]; 4],
}
pub type MtxF_t = [[libc::c_float; 4]; 4];
#[derive(Copy, Clone)]
#[repr(C)]
pub union MtxF {
    pub mf: MtxF_t,
    pub c2rust_unnamed: C2RustUnnamed_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_0 {
    pub xx: libc::c_float,
    pub yx: libc::c_float,
    pub zx: libc::c_float,
    pub wx: libc::c_float,
    pub xy: libc::c_float,
    pub yy: libc::c_float,
    pub zy: libc::c_float,
    pub wy: libc::c_float,
    pub xz: libc::c_float,
    pub yz: libc::c_float,
    pub zz: libc::c_float,
    pub wz: libc::c_float,
    pub xw: libc::c_float,
    pub yw: libc::c_float,
    pub zw: libc::c_float,
    pub ww: libc::c_float,
}
pub type size_t = libc::c_ulong;
pub type OSPri = s32;
pub type OSId = s32;
#[derive(Copy, Clone)]
#[repr(C)]
pub union __OSfp {
    pub f: C2RustUnnamed_1,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_1 {
    pub f_odd: f32_0,
    pub f_even: f32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __OSThreadContext {
    pub at: u64_0,
    pub v0: u64_0,
    pub v1: u64_0,
    pub a0: u64_0,
    pub a1: u64_0,
    pub a2: u64_0,
    pub a3: u64_0,
    pub t0: u64_0,
    pub t1: u64_0,
    pub t2: u64_0,
    pub t3: u64_0,
    pub t4: u64_0,
    pub t5: u64_0,
    pub t6: u64_0,
    pub t7: u64_0,
    pub s0: u64_0,
    pub s1: u64_0,
    pub s2: u64_0,
    pub s3: u64_0,
    pub s4: u64_0,
    pub s5: u64_0,
    pub s6: u64_0,
    pub s7: u64_0,
    pub t8: u64_0,
    pub t9: u64_0,
    pub gp: u64_0,
    pub sp: u64_0,
    pub s8: u64_0,
    pub ra: u64_0,
    pub lo: u64_0,
    pub hi: u64_0,
    pub sr: u32_0,
    pub pc: u32_0,
    pub cause: u32_0,
    pub badvaddr: u32_0,
    pub rcp: u32_0,
    pub fpcsr: u32_0,
    pub fp0: __OSfp,
    pub fp2: __OSfp,
    pub fp4: __OSfp,
    pub fp6: __OSfp,
    pub fp8: __OSfp,
    pub fp10: __OSfp,
    pub fp12: __OSfp,
    pub fp14: __OSfp,
    pub fp16: __OSfp,
    pub fp18: __OSfp,
    pub fp20: __OSfp,
    pub fp22: __OSfp,
    pub fp24: __OSfp,
    pub fp26: __OSfp,
    pub fp28: __OSfp,
    pub fp30: __OSfp,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __OSThreadprofile {
    pub flag: u32_0,
    pub count: u32_0,
    pub time: u64_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OSThread {
    pub next: *mut OSThread,
    pub priority: OSPri,
    pub queue: *mut *mut OSThread,
    pub tlnext: *mut OSThread,
    pub state: u16_0,
    pub flags: u16_0,
    pub id: OSId,
    pub fp: s32,
    pub thprof: *mut __OSThreadprofile,
    pub context: __OSThreadContext,
}
pub type OSMesg = *mut libc::c_void;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OSMesgQueue {
    pub mtqueue: *mut OSThread,
    pub fullqueue: *mut OSThread,
    pub validCount: s32,
    pub first: s32,
    pub msgCount: s32,
    pub msg: *mut OSMesg,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OSTask_t {
    pub type_0: u32_0,
    pub flags: u32_0,
    pub ucode_boot: *mut u64_0,
    pub ucode_boot_size: u32_0,
    pub ucode: *mut u64_0,
    pub ucode_size: u32_0,
    pub ucode_data: *mut u64_0,
    pub ucode_data_size: u32_0,
    pub dram_stack: *mut u64_0,
    pub dram_stack_size: u32_0,
    pub output_buff: *mut u64_0,
    pub output_buff_size: *mut u64_0,
    pub data_ptr: *mut u64_0,
    pub data_size: u32_0,
    pub yield_data_ptr: *mut u64_0,
    pub yield_data_size: u32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union OSTask {
    pub t: OSTask_t,
    pub force_structure_alignment: libc::c_longlong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OSViCommonRegs {
    pub ctrl: u32_0,
    pub width: u32_0,
    pub burst: u32_0,
    pub vSync: u32_0,
    pub hSync: u32_0,
    pub leap: u32_0,
    pub hStart: u32_0,
    pub xScale: u32_0,
    pub vCurrent: u32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OSViFieldRegs {
    pub origin: u32_0,
    pub yScale: u32_0,
    pub vStart: u32_0,
    pub vBurst: u32_0,
    pub vIntr: u32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OSViMode {
    pub type_0: u8_0,
    pub comRegs: OSViCommonRegs,
    pub fldRegs: [OSViFieldRegs; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OSContPad {
    pub button: u16_0,
    pub stick_x: s8,
    pub stick_y: s8,
    pub errno: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Vtx_t {
    pub ob: [libc::c_short; 3],
    pub flag: libc::c_ushort,
    pub tc: [libc::c_short; 2],
    pub cn: [libc::c_uchar; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Vtx_tn {
    pub ob: [libc::c_short; 3],
    pub flag: libc::c_ushort,
    pub tc: [libc::c_short; 2],
    pub n: [libc::c_schar; 3],
    pub a: libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union Vtx {
    pub v: Vtx_t,
    pub n: Vtx_tn,
    pub force_structure_alignment: libc::c_longlong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Tri {
    pub flag: libc::c_uchar,
    pub v: [libc::c_uchar; 3],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Vp_t {
    pub vscale: [libc::c_short; 4],
    pub vtrans: [libc::c_short; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union Vp {
    pub vp: Vp_t,
    pub force_structure_alignment: libc::c_longlong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Light_t {
    pub col: [libc::c_uchar; 3],
    pub pad1: libc::c_char,
    pub colc: [libc::c_uchar; 3],
    pub pad2: libc::c_char,
    pub dir: [libc::c_schar; 3],
    pub pad3: libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Ambient_t {
    pub col: [libc::c_uchar; 3],
    pub pad1: libc::c_char,
    pub colc: [libc::c_uchar; 3],
    pub pad2: libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union Light {
    pub l: Light_t,
    pub force_structure_alignment: [libc::c_longlong; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union Ambient {
    pub l: Ambient_t,
    pub force_structure_alignment: [libc::c_longlong; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Lightsn {
    pub a: Ambient,
    pub l: [Light; 7],
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct Gdma {
    #[bitfield(name = "cmd", ty = "libc::c_int", bits = "0..=7")]
    #[bitfield(name = "par", ty = "libc::c_uint", bits = "8..=15")]
    #[bitfield(name = "len", ty = "libc::c_uint", bits = "16..=31")]
    pub cmd_par_len: [u8; 4],
    pub addr: libc::c_uint,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct Gtri {
    #[bitfield(name = "cmd", ty = "libc::c_int", bits = "0..=7")]
    #[bitfield(name = "pad", ty = "libc::c_int", bits = "8..=31")]
    pub cmd_pad: [u8; 4],
    pub tri: Tri,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct Gpopmtx {
    #[bitfield(name = "cmd", ty = "libc::c_int", bits = "0..=7")]
    #[bitfield(name = "pad1", ty = "libc::c_int", bits = "8..=31")]
    #[bitfield(name = "pad2", ty = "libc::c_int", bits = "32..=55")]
    #[bitfield(name = "param", ty = "libc::c_uchar", bits = "56..=63")]
    pub cmd_pad1_pad2_param: [u8; 8],
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct Gsegment {
    #[bitfield(name = "cmd", ty = "libc::c_int", bits = "0..=7")]
    #[bitfield(name = "pad0", ty = "libc::c_int", bits = "8..=15")]
    #[bitfield(name = "mw_index", ty = "libc::c_int", bits = "16..=23")]
    #[bitfield(name = "number", ty = "libc::c_int", bits = "24..=31")]
    #[bitfield(name = "pad1", ty = "libc::c_int", bits = "32..=39")]
    #[bitfield(name = "base", ty = "libc::c_int", bits = "40..=63")]
    pub cmd_pad0_mw_index_number_pad1_base: [u8; 8],
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct GsetothermodeL {
    #[bitfield(name = "cmd", ty = "libc::c_int", bits = "0..=7")]
    #[bitfield(name = "pad0", ty = "libc::c_int", bits = "8..=15")]
    #[bitfield(name = "sft", ty = "libc::c_int", bits = "16..=23")]
    #[bitfield(name = "len", ty = "libc::c_int", bits = "24..=31")]
    #[bitfield(name = "data", ty = "libc::c_uint", bits = "32..=63")]
    pub cmd_pad0_sft_len_data: [u8; 8],
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct GsetothermodeH {
    #[bitfield(name = "cmd", ty = "libc::c_int", bits = "0..=7")]
    #[bitfield(name = "pad0", ty = "libc::c_int", bits = "8..=15")]
    #[bitfield(name = "sft", ty = "libc::c_int", bits = "16..=23")]
    #[bitfield(name = "len", ty = "libc::c_int", bits = "24..=31")]
    #[bitfield(name = "data", ty = "libc::c_uint", bits = "32..=63")]
    pub cmd_pad0_sft_len_data: [u8; 8],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Gtexture {
    pub cmd: libc::c_uchar,
    pub lodscale: libc::c_uchar,
    pub tile: libc::c_uchar,
    pub on: libc::c_uchar,
    pub s: libc::c_ushort,
    pub t: libc::c_ushort,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct Gline3D {
    #[bitfield(name = "cmd", ty = "libc::c_int", bits = "0..=7")]
    #[bitfield(name = "pad", ty = "libc::c_int", bits = "8..=31")]
    pub cmd_pad: [u8; 4],
    pub line: Tri,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct Gperspnorm {
    #[bitfield(name = "cmd", ty = "libc::c_int", bits = "0..=7")]
    #[bitfield(name = "pad1", ty = "libc::c_int", bits = "8..=31")]
    pub cmd_pad1: [u8; 4],
    pub pad2: libc::c_short,
    pub scale: libc::c_short,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct Gsetimg {
    #[bitfield(name = "cmd", ty = "libc::c_int", bits = "0..=7")]
    #[bitfield(name = "fmt", ty = "libc::c_uint", bits = "8..=10")]
    #[bitfield(name = "siz", ty = "libc::c_uint", bits = "11..=12")]
    #[bitfield(name = "pad", ty = "libc::c_uint", bits = "13..=19")]
    #[bitfield(name = "wd", ty = "libc::c_uint", bits = "20..=31")]
    pub cmd_fmt_siz_pad_wd: [u8; 4],
    pub dram: libc::c_uint,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct Gsetcombine {
    #[bitfield(name = "cmd", ty = "libc::c_int", bits = "0..=7")]
    #[bitfield(name = "muxs0", ty = "libc::c_uint", bits = "8..=31")]
    #[bitfield(name = "muxs1", ty = "libc::c_uint", bits = "32..=63")]
    pub cmd_muxs0_muxs1: [u8; 8],
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct Gsetcolor {
    #[bitfield(name = "cmd", ty = "libc::c_int", bits = "0..=7")]
    pub cmd: [u8; 1],
    pub pad: libc::c_uchar,
    pub prim_min_level: libc::c_uchar,
    pub prim_level: libc::c_uchar,
    pub color: libc::c_ulong,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct Gfillrect {
    #[bitfield(name = "cmd", ty = "libc::c_int", bits = "0..=7")]
    #[bitfield(name = "x0", ty = "libc::c_int", bits = "8..=17")]
    #[bitfield(name = "x0frac", ty = "libc::c_int", bits = "18..=19")]
    #[bitfield(name = "y0", ty = "libc::c_int", bits = "20..=29")]
    #[bitfield(name = "y0frac", ty = "libc::c_int", bits = "30..=31")]
    #[bitfield(name = "pad", ty = "libc::c_uint", bits = "32..=39")]
    #[bitfield(name = "x1", ty = "libc::c_int", bits = "40..=49")]
    #[bitfield(name = "x1frac", ty = "libc::c_int", bits = "50..=51")]
    #[bitfield(name = "y1", ty = "libc::c_int", bits = "52..=61")]
    #[bitfield(name = "y1frac", ty = "libc::c_int", bits = "62..=63")]
    pub cmd_x0_x0frac_y0_y0frac_pad_x1_x1frac_y1_y1frac: [u8; 8],
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct Gsettile {
    #[bitfield(name = "cmd", ty = "libc::c_int", bits = "0..=7")]
    #[bitfield(name = "fmt", ty = "libc::c_uint", bits = "8..=10")]
    #[bitfield(name = "siz", ty = "libc::c_uint", bits = "11..=12")]
    #[bitfield(name = "pad0", ty = "libc::c_uint", bits = "13..=13")]
    #[bitfield(name = "line", ty = "libc::c_uint", bits = "14..=22")]
    #[bitfield(name = "tmem", ty = "libc::c_uint", bits = "23..=31")]
    #[bitfield(name = "pad1", ty = "libc::c_uint", bits = "32..=36")]
    #[bitfield(name = "tile", ty = "libc::c_uint", bits = "37..=39")]
    #[bitfield(name = "palette", ty = "libc::c_uint", bits = "40..=43")]
    #[bitfield(name = "ct", ty = "libc::c_uint", bits = "44..=44")]
    #[bitfield(name = "mt", ty = "libc::c_uint", bits = "45..=45")]
    #[bitfield(name = "maskt", ty = "libc::c_uint", bits = "46..=49")]
    #[bitfield(name = "shiftt", ty = "libc::c_uint", bits = "50..=53")]
    #[bitfield(name = "cs", ty = "libc::c_uint", bits = "54..=54")]
    #[bitfield(name = "ms", ty = "libc::c_uint", bits = "55..=55")]
    #[bitfield(name = "masks", ty = "libc::c_uint", bits = "56..=59")]
    #[bitfield(name = "shifts", ty = "libc::c_uint", bits = "60..=63")]
    pub cmd_fmt_siz_pad0_line_tmem_pad1_tile_palette_ct_mt_maskt_shiftt_cs_ms_masks_shifts: [u8; 8],
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct Gloadtile {
    #[bitfield(name = "cmd", ty = "libc::c_int", bits = "0..=7")]
    #[bitfield(name = "sl", ty = "libc::c_uint", bits = "8..=19")]
    #[bitfield(name = "tl", ty = "libc::c_uint", bits = "20..=31")]
    #[bitfield(name = "pad", ty = "libc::c_int", bits = "32..=36")]
    #[bitfield(name = "tile", ty = "libc::c_uint", bits = "37..=39")]
    #[bitfield(name = "sh", ty = "libc::c_uint", bits = "40..=51")]
    #[bitfield(name = "th", ty = "libc::c_uint", bits = "52..=63")]
    pub cmd_sl_tl_pad_tile_sh_th: [u8; 8],
}
pub type Gsettilesize = Gloadtile;
pub type Gloadtlut = Gloadtile;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Gwords {
    pub w0: libc::c_uint,
    pub w1: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union Gfx {
    pub words: Gwords,
    pub dma: Gdma,
    pub tri: Gtri,
    pub line: Gline3D,
    pub popmtx: Gpopmtx,
    pub segment: Gsegment,
    pub setothermodeH: GsetothermodeH,
    pub setothermodeL: GsetothermodeL,
    pub texture: Gtexture,
    pub perspnorm: Gperspnorm,
    pub setimg: Gsetimg,
    pub setcombine: Gsetcombine,
    pub setcolor: Gsetcolor,
    pub fillrect: Gfillrect,
    pub settile: Gsettile,
    pub loadtile: Gloadtile,
    pub settilesize: Gsettilesize,
    pub loadtlut: Gloadtlut,
    pub force_structure_alignment: libc::c_longlong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Vec2f {
    pub x: f32_0,
    pub y: f32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Vec3f {
    pub x: f32_0,
    pub y: f32_0,
    pub z: f32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Vec3us {
    pub x: u16_0,
    pub y: u16_0,
    pub z: u16_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Vec3s {
    pub x: s16,
    pub y: s16,
    pub z: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Vec3i {
    pub x: s32,
    pub y: s32,
    pub z: s32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Sphere16 {
    pub center: Vec3s,
    pub radius: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Cylinder16 {
    pub radius: s16,
    pub height: s16,
    pub yShift: s16,
    pub pos: Vec3s,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Linef {
    pub a: Vec3f,
    pub b: Vec3f,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct VecSph {
    pub r: f32_0,
    pub pitch: s16,
    pub yaw: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ItemEquips {
    pub buttonItems: [u8_0; 4],
    pub cButtonSlots: [u8_0; 3],
    pub equipment: u16_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Inventory {
    pub items: [u8_0; 24],
    pub ammo: [s8; 16],
    pub equipment: u16_0,
    pub upgrades: u32_0,
    pub questItems: u32_0,
    pub dungeonItems: [u8_0; 20],
    pub dungeonKeys: [s8; 19],
    pub defenseHearts: s8,
    pub gsTokens: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SavedSceneFlags {
    pub chest: u32_0,
    pub swch: u32_0,
    pub clear: u32_0,
    pub collect: u32_0,
    pub unk: u32_0,
    pub rooms: u32_0,
    pub floors: u32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct HorseData {
    pub scene: s16,
    pub pos: Vec3s,
    pub angle: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RespawnData {
    pub pos: Vec3f,
    pub yaw: s16,
    pub playerParams: s16,
    pub entranceIndex: s16,
    pub roomIndex: u8_0,
    pub data: s8,
    pub tempSwchFlags: u32_0,
    pub tempCollectFlags: u32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct FaroresWindData {
    pub pos: Vec3i,
    pub yaw: s32,
    pub playerParams: s32,
    pub entranceIndex: s32,
    pub roomIndex: s32,
    pub set: s32,
    pub tempSwchFlags: s32,
    pub tempCollectFlags: s32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SaveContext {
    pub entranceIndex: s32,
    pub linkAge: s32,
    pub cutsceneIndex: s32,
    pub dayTime: u16_0,
    pub nightFlag: s32,
    pub totalDays: s32,
    pub bgsDayCount: s32,
    pub newf: [libc::c_char; 6],
    pub deaths: u16_0,
    pub playerName: [libc::c_char; 8],
    pub n64ddFlag: s16,
    pub healthCapacity: s16,
    pub health: s16,
    pub magicLevel: s8,
    pub magic: s8,
    pub rupees: s16,
    pub swordHealth: u16_0,
    pub naviTimer: u16_0,
    pub magicAcquired: u8_0,
    pub unk_3B: [libc::c_char; 1],
    pub doubleMagic: u8_0,
    pub doubleDefense: u8_0,
    pub bgsFlag: u8_0,
    pub ocarinaGameRoundNum: u8_0,
    pub childEquips: ItemEquips,
    pub adultEquips: ItemEquips,
    pub unk_54: u32_0,
    pub unk_58: [libc::c_char; 14],
    pub savedSceneNum: s16,
    pub equips: ItemEquips,
    pub inventory: Inventory,
    pub sceneFlags: [SavedSceneFlags; 124],
    pub fw: FaroresWindData,
    pub unk_E8C: [libc::c_char; 16],
    pub gsFlags: [s32; 6],
    pub unk_EB4: [libc::c_char; 4],
    pub highScores: [s32; 7],
    pub eventChkInf: [u16_0; 14],
    pub itemGetInf: [u16_0; 4],
    pub infTable: [u16_0; 30],
    pub unk_F34: [libc::c_char; 4],
    pub worldMapAreaData: u32_0,
    pub unk_F3C: [libc::c_char; 4],
    pub scarecrowCustomSongSet: u8_0,
    pub scarecrowCustomSong: [u8_0; 864],
    pub unk_12A1: [libc::c_char; 36],
    pub scarecrowSpawnSongSet: u8_0,
    pub scarecrowSpawnSong: [u8_0; 128],
    pub unk_1346: [libc::c_char; 2],
    pub horseData: HorseData,
    pub checksum: u16_0,
    pub fileNum: s32,
    pub unk_1358: [libc::c_char; 4],
    pub gameMode: s32,
    pub sceneSetupIndex: s32,
    pub respawnFlag: s32,
    pub respawn: [RespawnData; 3],
    pub entranceSpeed: f32_0,
    pub entranceSound: u16_0,
    pub unk_13C2: [libc::c_char; 1],
    pub unk_13C3: u8_0,
    pub dogParams: s16,
    pub textTriggerFlags: u8_0,
    pub showTitleCard: u8_0,
    pub nayrusLoveTimer: s16,
    pub unk_13CA: [libc::c_char; 2],
    pub rupeeAccumulator: s16,
    pub timer1State: s16,
    pub timer1Value: s16,
    pub timer2State: s16,
    pub timer2Value: s16,
    pub timerX: [s16; 2],
    pub timerY: [s16; 2],
    pub unk_13DE: [libc::c_char; 2],
    pub seqId: u8_0,
    pub natureAmbienceId: u8_0,
    pub buttonStatus: [u8_0; 5],
    pub unk_13E7: u8_0,
    pub unk_13E8: u16_0,
    pub unk_13EA: u16_0,
    pub unk_13EC: u16_0,
    pub unk_13EE: u16_0,
    pub unk_13F0: s16,
    pub unk_13F2: s16,
    pub unk_13F4: s16,
    pub unk_13F6: s16,
    pub unk_13F8: s16,
    pub eventInf: [u16_0; 4],
    pub mapIndex: u16_0,
    pub minigameState: u16_0,
    pub minigameScore: u16_0,
    pub unk_1408: [libc::c_char; 1],
    pub language: u8_0,
    pub audioSetting: u8_0,
    pub unk_140B: [libc::c_char; 1],
    pub zTargetSetting: u8_0,
    pub forcedSeqId: u16_0,
    pub unk_1410: u8_0,
    pub unk_1411: [libc::c_char; 1],
    pub nextCutsceneIndex: u16_0,
    pub cutsceneTrigger: u8_0,
    pub chamberCutsceneNum: u8_0,
    pub nextDayTime: u16_0,
    pub fadeDuration: u8_0,
    pub unk_1419: u8_0,
    pub skyboxTime: u16_0,
    pub dogIsLost: u8_0,
    pub nextTransition: u8_0,
    pub unk_141E: [libc::c_char; 2],
    pub worldMapArea: s16,
    pub sunsSongState: s16,
    pub healthAccumulator: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Color_RGB8 {
    pub r: u8_0,
    pub g: u8_0,
    pub b: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union Color_RGBA8_u32 {
    pub c2rust_unnamed: C2RustUnnamed_2,
    pub rgba: u32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub r: u8_0,
    pub g: u8_0,
    pub b: u8_0,
    pub a: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Color_RGBAf {
    pub r: f32_0,
    pub g: f32_0,
    pub b: f32_0,
    pub a: f32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct LightPoint {
    pub x: s16,
    pub y: s16,
    pub z: s16,
    pub color: [u8_0; 3],
    pub drawGlow: u8_0,
    pub radius: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct LightDirectional {
    pub x: s8,
    pub y: s8,
    pub z: s8,
    pub color: [u8_0; 3],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union LightParams {
    pub point: LightPoint,
    pub dir: LightDirectional,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct LightInfo {
    pub type_0: u8_0,
    pub params: LightParams,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Lights {
    pub numLights: u8_0,
    pub l: Lightsn,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct LightNode {
    pub info: *mut LightInfo,
    pub prev: *mut LightNode,
    pub next: *mut LightNode,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct LightContext {
    pub listHead: *mut LightNode,
    pub ambientColor: [u8_0; 3],
    pub fogColor: [u8_0; 3],
    pub fogNear: s16,
    pub fogFar: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GlobalContext {
    pub state: GameState,
    pub sceneNum: s16,
    pub sceneConfig: u8_0,
    pub unk_A7: [libc::c_char; 9],
    pub sceneSegment: *mut libc::c_void,
    pub view: View,
    pub mainCamera: Camera,
    pub subCameras: [Camera; 3],
    pub cameraPtrs: [*mut Camera; 4],
    pub activeCamera: s16,
    pub nextCamera: s16,
    pub sequenceCtx: SequenceContext,
    pub lightCtx: LightContext,
    pub frameAdvCtx: FrameAdvanceContext,
    pub colCtx: CollisionContext,
    pub actorCtx: ActorContext,
    pub csCtx: CutsceneContext,
    pub soundSources: [SoundSource; 16],
    pub sramCtx: SramContext,
    pub skyboxCtx: SkyboxContext,
    pub msgCtx: MessageContext,
    pub interfaceCtx: InterfaceContext,
    pub pauseCtx: PauseContext,
    pub gameOverCtx: GameOverContext,
    pub envCtx: EnvironmentContext,
    pub animationCtx: AnimationContext,
    pub objectCtx: ObjectContext,
    pub roomCtx: RoomContext,
    pub transiActorCtx: TransitionActorContext,
    pub playerInit: Option<unsafe extern "C" fn(_: *mut Player,
                                                _: *mut GlobalContext,
                                                _: *mut FlexSkeletonHeader)
                               -> ()>,
    pub playerUpdate: Option<unsafe extern "C" fn(_: *mut Player,
                                                  _: *mut GlobalContext,
                                                  _: *mut Input) -> ()>,
    pub isPlayerDroppingFish: Option<unsafe extern "C" fn(_:
                                                              *mut GlobalContext)
                                         -> s32>,
    pub startPlayerFishing: Option<unsafe extern "C" fn(_: *mut GlobalContext)
                                       -> s32>,
    pub grabPlayer: Option<unsafe extern "C" fn(_: *mut GlobalContext,
                                                _: *mut Player) -> s32>,
    pub startPlayerCutscene: Option<unsafe extern "C" fn(_:
                                                             *mut GlobalContext,
                                                         _: *mut Actor,
                                                         _: s32) -> s32>,
    pub func_11D54: Option<unsafe extern "C" fn(_: *mut Player,
                                                _: *mut GlobalContext) -> ()>,
    pub damagePlayer: Option<unsafe extern "C" fn(_: *mut GlobalContext,
                                                  _: s32) -> s32>,
    pub talkWithPlayer: Option<unsafe extern "C" fn(_: *mut GlobalContext,
                                                    _: *mut Actor) -> ()>,
    pub viewProjectionMtxF: MtxF,
    pub billboardMtxF: MtxF,
    pub billboardMtx: *mut Mtx,
    pub gameplayFrames: u32_0,
    pub linkAgeOnLoad: u8_0,
    pub unk_11DE9: u8_0,
    pub curSpawn: u8_0,
    pub numSetupActors: u8_0,
    pub numRooms: u8_0,
    pub roomList: *mut RomFile,
    pub linkActorEntry: *mut ActorEntry,
    pub setupActorList: *mut ActorEntry,
    pub unk_11DFC: *mut libc::c_void,
    pub setupEntranceList: *mut EntranceEntry,
    pub setupExitList: *mut s16,
    pub setupPathList: *mut Path,
    pub cUpElfMsgs: *mut ElfMessage,
    pub specialEffects: *mut libc::c_void,
    pub skyboxId: u8_0,
    pub sceneLoadFlag: s8,
    pub unk_11E16: s16,
    pub unk_11E18: s16,
    pub nextEntranceIndex: s16,
    pub unk_11E1C: [libc::c_char; 64],
    pub shootingGalleryStatus: s8,
    pub bombchuBowlingStatus: s8,
    pub fadeTransition: u8_0,
    pub colChkCtx: CollisionCheckContext,
    pub envFlags: [u16_0; 20],
    pub pauseBgPreRender: PreRender,
    pub unk_12174: [libc::c_char; 83],
    pub unk_121C7: s8,
    pub transitionCtx: TransitionContext,
    pub unk_12418: [libc::c_char; 3],
    pub transitionMode: u8_0,
    pub transitionFade: TransitionFade,
    pub unk_12428: [libc::c_char; 3],
    pub unk_1242B: u8_0,
    pub loadedScene: *mut SceneTableEntry,
    pub unk_12430: [libc::c_char; 232],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SceneTableEntry {
    pub sceneFile: RomFile,
    pub titleFile: RomFile,
    pub unk_10: u8_0,
    pub config: u8_0,
    pub unk_12: u8_0,
    pub unk_13: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RomFile {
    pub vromStart: u32_0,
    pub vromEnd: u32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TransitionFade {
    pub fadeType: u8_0,
    pub isDone: u8_0,
    pub fadeDirection: u8_0,
    pub fadeColor: Color_RGBA8_u32,
    pub fadeTimer: u16_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TransitionContext {
    pub c2rust_unnamed: C2RustUnnamed_3,
    pub transitionType: s32,
    pub init: Option<unsafe extern "C" fn(_: *mut libc::c_void)
                         -> *mut libc::c_void>,
    pub destroy: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
    pub update: Option<unsafe extern "C" fn(_: *mut libc::c_void, _: s32)
                           -> ()>,
    pub draw: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                          _: *mut *mut Gfx) -> ()>,
    pub start: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
    pub setType: Option<unsafe extern "C" fn(_: *mut libc::c_void, _: s32)
                            -> ()>,
    pub setColor: Option<unsafe extern "C" fn(_: *mut libc::c_void, _: u32_0)
                             -> ()>,
    pub setEnvColor: Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                                 _: u32_0) -> ()>,
    pub isDone: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> s32>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_3 {
    pub fade: TransitionFade,
    pub circle: TransitionCircle,
    pub triforce: TransitionTriforce,
    pub wipe: TransitionWipe,
    pub data: [libc::c_char; 552],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TransitionWipe {
    pub color: Color_RGBA8_u32,
    pub envColor: Color_RGBA8_u32,
    pub direction: u8_0,
    pub frame: u8_0,
    pub isDone: u8_0,
    pub texX: u16_0,
    pub texY: u16_0,
    pub normal: u16_0,
    pub projection: Mtx,
    pub lookAt: Mtx,
    pub modelView: [[Mtx; 3]; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TransitionTriforce {
    pub color: Color_RGBA8_u32,
    pub transPos: f32_0,
    pub step: f32_0,
    pub state: s32,
    pub fadeDirection: s32,
    pub projection: Mtx,
    pub frame: s32,
    pub modelView: [[Mtx; 3]; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TransitionCircle {
    pub color: Color_RGBA8_u32,
    pub envColor: Color_RGBA8_u32,
    pub texX: s32,
    pub texY: s32,
    pub step: s32,
    pub unk_14: u8_0,
    pub typeColor: u8_0,
    pub speed: u8_0,
    pub effect: u8_0,
    pub isDone: u8_0,
    pub frame: u8_0,
    pub normal: u16_0,
    pub projection: Mtx,
    pub lookAt: Mtx,
    pub texture: *mut libc::c_void,
    pub modelView: [[Mtx; 3]; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PreRender {
    pub width: s32,
    pub height: s32,
    pub widthSave: s32,
    pub heightSave: s32,
    pub fbuf: *mut u16_0,
    pub fbufSave: *mut u16_0,
    pub cvgSave: *mut u8_0,
    pub zbuf: *mut u16_0,
    pub zbufSave: *mut u16_0,
    pub ulxSave: s32,
    pub ulySave: s32,
    pub lrxSave: s32,
    pub lrySave: s32,
    pub ulx: s32,
    pub uly: s32,
    pub lrx: s32,
    pub lry: s32,
    pub alloc: ListAlloc,
    pub unk_4C: u32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ListAlloc {
    pub prev: *mut ListAlloc,
    pub next: *mut ListAlloc,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CollisionCheckContext {
    pub colATCount: s16,
    pub sacFlags: u16_0,
    pub colAT: [*mut Collider; 50],
    pub colACCount: s32,
    pub colAC: [*mut Collider; 60],
    pub colOCCount: s32,
    pub colOC: [*mut Collider; 50],
    pub colLineCount: s32,
    pub colLine: [*mut OcLine; 3],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OcLine {
    pub line: Linef,
    pub ocFlags: u16_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Collider {
    pub actor: *mut Actor,
    pub at: *mut Actor,
    pub ac: *mut Actor,
    pub oc: *mut Actor,
    pub atFlags: u8_0,
    pub acFlags: u8_0,
    pub ocFlags1: u8_0,
    pub ocFlags2: u8_0,
    pub colType: u8_0,
    pub shape: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Actor {
    pub id: s16,
    pub category: u8_0,
    pub room: s8,
    pub flags: u32_0,
    pub home: PosRot,
    pub params: s16,
    pub objBankIndex: s8,
    pub targetMode: s8,
    pub sfx: u16_0,
    pub world: PosRot,
    pub focus: PosRot,
    pub targetArrowOffset: f32_0,
    pub scale: Vec3f,
    pub velocity: Vec3f,
    pub speedXZ: f32_0,
    pub gravity: f32_0,
    pub minVelocityY: f32_0,
    pub wallPoly: *mut CollisionPoly,
    pub floorPoly: *mut CollisionPoly,
    pub wallBgId: u8_0,
    pub floorBgId: u8_0,
    pub wallYaw: s16,
    pub floorHeight: f32_0,
    pub yDistToWater: f32_0,
    pub bgCheckFlags: u16_0,
    pub yawTowardsPlayer: s16,
    pub xyzDistToPlayerSq: f32_0,
    pub xzDistToPlayer: f32_0,
    pub yDistToPlayer: f32_0,
    pub colChkInfo: CollisionCheckInfo,
    pub shape: ActorShape,
    pub projectedPos: Vec3f,
    pub projectedW: f32_0,
    pub uncullZoneForward: f32_0,
    pub uncullZoneScale: f32_0,
    pub uncullZoneDownward: f32_0,
    pub prevPos: Vec3f,
    pub isTargeted: u8_0,
    pub targetPriority: u8_0,
    pub textId: u16_0,
    pub freezeTimer: u16_0,
    pub colorFilterParams: u16_0,
    pub colorFilterTimer: u8_0,
    pub isDrawn: u8_0,
    pub dropFlag: u8_0,
    pub naviEnemyId: u8_0,
    pub parent: *mut Actor,
    pub child: *mut Actor,
    pub prev: *mut Actor,
    pub next: *mut Actor,
    pub init: ActorFunc,
    pub destroy: ActorFunc,
    pub update: ActorFunc,
    pub draw: ActorFunc,
    pub overlayEntry: *mut ActorOverlay,
    pub dbgPad: [libc::c_char; 16],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ActorOverlay {
    pub vromStart: u32_0,
    pub vromEnd: u32_0,
    pub vramStart: *mut libc::c_void,
    pub vramEnd: *mut libc::c_void,
    pub loadedRamAddr: *mut libc::c_void,
    pub initInfo: *mut ActorInit,
    pub name: *mut libc::c_char,
    pub allocType: u16_0,
    pub numLoaded: s8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ActorInit {
    pub id: s16,
    pub category: u8_0,
    pub flags: u32_0,
    pub objectId: s16,
    pub instanceSize: u32_0,
    pub init: ActorFunc,
    pub destroy: ActorFunc,
    pub update: ActorFunc,
    pub draw: ActorFunc,
}
pub type ActorFunc
    =
    Option<unsafe extern "C" fn(_: *mut Actor, _: *mut GlobalContext) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ActorShape {
    pub rot: Vec3s,
    pub face: s16,
    pub yOffset: f32_0,
    pub shadowDraw: ActorShadowFunc,
    pub shadowScale: f32_0,
    pub shadowAlpha: u8_0,
    pub feetFloorFlags: u8_0,
    pub feetPos: [Vec3f; 2],
}
pub type ActorShadowFunc
    =
    Option<unsafe extern "C" fn(_: *mut Actor, _: *mut Lights,
                                _: *mut GlobalContext) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CollisionCheckInfo {
    pub damageTable: *mut DamageTable,
    pub displacement: Vec3f,
    pub cylRadius: s16,
    pub cylHeight: s16,
    pub cylYShift: s16,
    pub mass: u8_0,
    pub health: u8_0,
    pub damage: u8_0,
    pub damageEffect: u8_0,
    pub atHitEffect: u8_0,
    pub acHitEffect: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DamageTable {
    pub table: [u8_0; 32],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CollisionPoly {
    pub type_0: u16_0,
    pub c2rust_unnamed: C2RustUnnamed_4,
    pub normal: Vec3s,
    pub dist: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_4 {
    pub vtxData: [u16_0; 3],
    pub c2rust_unnamed: C2RustUnnamed_5,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_5 {
    pub flags_vIA: u16_0,
    pub flags_vIB: u16_0,
    pub vIC: u16_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PosRot {
    pub pos: Vec3f,
    pub rot: Vec3s,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ElfMessage {
    pub byte0: u8_0,
    pub byte1: u8_0,
    pub byte2: u8_0,
    pub byte3: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Path {
    pub count: u8_0,
    pub points: *mut Vec3s,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EntranceEntry {
    pub spawn: u8_0,
    pub room: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ActorEntry {
    pub id: s16,
    pub pos: Vec3s,
    pub rot: Vec3s,
    pub params: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Player {
    pub actor: Actor,
    pub currentTunic: s8,
    pub currentSword: s8,
    pub currentShield: s8,
    pub currentBoots: s8,
    pub heldItemButton: s8,
    pub heldItemActionParam: s8,
    pub heldItemId: u8_0,
    pub prevBoots: s8,
    pub itemActionParam: s8,
    pub unk_155: [libc::c_char; 3],
    pub modelGroup: u8_0,
    pub nextModelGroup: u8_0,
    pub unk_15A: s8,
    pub modelAnimType: u8_0,
    pub leftHandType: u8_0,
    pub rightHandType: u8_0,
    pub sheathType: u8_0,
    pub currentMask: u8_0,
    pub rightHandDLists: *mut *mut Gfx,
    pub leftHandDLists: *mut *mut Gfx,
    pub sheathDLists: *mut *mut Gfx,
    pub waistDLists: *mut *mut Gfx,
    pub giObjectLoading: u8_0,
    pub giObjectDmaRequest: DmaRequest,
    pub giObjectLoadQueue: OSMesgQueue,
    pub giObjectLoadMsg: OSMesg,
    pub giObjectSegment: *mut libc::c_void,
    pub skelAnime: SkelAnime,
    pub jointTable: [Vec3s; 24],
    pub morphTable: [Vec3s; 24],
    pub blendTable: [Vec3s; 24],
    pub unk_3A8: [s16; 2],
    pub heldActor: *mut Actor,
    pub leftHandPos: Vec3f,
    pub unk_3BC: Vec3s,
    pub unk_3C4: *mut Actor,
    pub unk_3C8: Vec3f,
    pub unk_3D4: [libc::c_char; 88],
    pub doorType: s8,
    pub doorDirection: s8,
    pub doorTimer: s16,
    pub doorActor: *mut Actor,
    pub getItemId: s8,
    pub getItemDirection: u16_0,
    pub interactRangeActor: *mut Actor,
    pub mountSide: s8,
    pub unk_43D: [libc::c_char; 3],
    pub rideActor: *mut Actor,
    pub csMode: u8_0,
    pub prevCsMode: u8_0,
    pub unk_446: u8_0,
    pub unk_447: u8_0,
    pub unk_448: *mut Actor,
    pub unk_44C: [libc::c_char; 4],
    pub unk_450: Vec3f,
    pub unk_45C: Vec3f,
    pub unk_468: [libc::c_char; 2],
    pub unk_46A: s16,
    pub unk_46C: s16,
    pub unk_46E: [libc::c_char; 42],
    pub cylinder: ColliderCylinder,
    pub swordQuads: [ColliderQuad; 2],
    pub shieldQuad: ColliderQuad,
    pub unk_664: *mut Actor,
    pub unk_668: [libc::c_char; 4],
    pub unk_66C: s32,
    pub swordEffectIndex: s32,
    pub func_674: PlayerFunc674,
    pub ageProperties: *mut PlayerAgeProperties,
    pub stateFlags1: u32_0,
    pub stateFlags2: u32_0,
    pub unk_684: *mut Actor,
    pub boomerangActor: *mut Actor,
    pub naviActor: *mut Actor,
    pub naviTextId: s16,
    pub stateFlags3: u8_0,
    pub exchangeItemId: s8,
    pub targetActor: *mut Actor,
    pub targetActorDistance: f32_0,
    pub unk_69C: [libc::c_char; 4],
    pub unk_6A0: f32_0,
    pub unk_6A4: f32_0,
    pub unk_6A8: *mut Actor,
    pub unk_6AC: s8,
    pub unk_6AD: u8_0,
    pub unk_6AE: u16_0,
    pub unk_6B0: s16,
    pub unk_6B4: [libc::c_char; 4],
    pub unk_6B6: s16,
    pub unk_6B8: s16,
    pub unk_6BA: s16,
    pub unk_6BC: s16,
    pub unk_6BE: s16,
    pub unk_6C0: s16,
    pub unk_6C2: s16,
    pub unk_6C4: f32_0,
    pub skelAnime2: SkelAnime,
    pub jointTable2: [Vec3s; 24],
    pub morphTable2: [Vec3s; 24],
    pub func_82C: PlayerFunc82C,
    pub unk_830: f32_0,
    pub unk_834: s16,
    pub unk_836: s8,
    pub unk_837: u8_0,
    pub linearVelocity: f32_0,
    pub currentYaw: s16,
    pub targetYaw: s16,
    pub unk_840: u16_0,
    pub swordAnimation: s8,
    pub swordState: s8,
    pub unk_844: s8,
    pub unk_845: u8_0,
    pub unk_846: u8_0,
    pub unk_847: [s8; 4],
    pub unk_84B: [s8; 4],
    pub unk_84F: s8,
    pub unk_850: s16,
    pub unk_854: f32_0,
    pub unk_858: f32_0,
    pub unk_85C: f32_0,
    pub unk_860: s16,
    pub unk_862: s8,
    pub unk_864: f32_0,
    pub unk_868: f32_0,
    pub unk_86C: f32_0,
    pub unk_870: f32_0,
    pub unk_874: f32_0,
    pub unk_878: f32_0,
    pub unk_87C: s16,
    pub unk_87E: s16,
    pub unk_880: f32_0,
    pub wallHeight: f32_0,
    pub wallDistance: f32_0,
    pub unk_88C: u8_0,
    pub unk_88D: u8_0,
    pub unk_88E: u8_0,
    pub unk_88F: u8_0,
    pub unk_890: u8_0,
    pub shockTimer: u8_0,
    pub unk_892: u8_0,
    pub hoverBootsTimer: u8_0,
    pub fallStartHeight: s16,
    pub fallDistance: s16,
    pub unk_898: s16,
    pub unk_89A: s16,
    pub unk_89C: s16,
    pub unk_89E: u16_0,
    pub unk_8A0: u8_0,
    pub unk_8A1: u8_0,
    pub unk_8A2: s16,
    pub unk_8A4: f32_0,
    pub unk_8A8: f32_0,
    pub windSpeed: f32_0,
    pub windDirection: s16,
    pub swordInfo: [WeaponInfo; 3],
    pub bodyPartsPos: [Vec3f; 18],
    pub mf_9E0: MtxF,
    pub shieldMf: MtxF,
    pub isBurning: u8_0,
    pub flameTimers: [u8_0; 18],
    pub unk_A73: u8_0,
    pub func_A74: PlayerFuncA74,
    pub invincibilityTimer: s8,
    pub unk_A79: u8_0,
    pub unk_A7A: u8_0,
    pub unk_A7B: u8_0,
    pub unk_A7C: f32_0,
    pub unk_A80: s16,
    pub unk_A82: u16_0,
    pub unk_A84: s16,
    pub unk_A86: s8,
    pub unk_A87: u8_0,
    pub unk_A88: Vec3f,
}
pub type PlayerFuncA74
    =
    Option<unsafe extern "C" fn(_: *mut GlobalContext, _: *mut Player) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct WeaponInfo {
    pub active: s32,
    pub tip: Vec3f,
    pub base: Vec3f,
}
pub type PlayerFunc82C
    =
    Option<unsafe extern "C" fn(_: *mut Player, _: *mut GlobalContext)
               -> s32>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SkelAnime {
    pub limbCount: u8_0,
    pub mode: u8_0,
    pub dListCount: u8_0,
    pub taper: s8,
    pub skeleton: *mut *mut libc::c_void,
    pub animation: *mut libc::c_void,
    pub startFrame: f32_0,
    pub endFrame: f32_0,
    pub animLength: f32_0,
    pub curFrame: f32_0,
    pub playSpeed: f32_0,
    pub jointTable: *mut Vec3s,
    pub morphTable: *mut Vec3s,
    pub morphWeight: f32_0,
    pub morphRate: f32_0,
    pub update: Option<unsafe extern "C" fn() -> s32>,
    pub initFlags: s8,
    pub moveFlags: u8_0,
    pub prevRot: s16,
    pub prevTransl: Vec3s,
    pub baseTransl: Vec3s,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PlayerAgeProperties {
    pub unk_00: f32_0,
    pub unk_04: f32_0,
    pub unk_08: f32_0,
    pub unk_0C: f32_0,
    pub unk_10: f32_0,
    pub unk_14: f32_0,
    pub unk_18: f32_0,
    pub unk_1C: f32_0,
    pub unk_20: f32_0,
    pub unk_24: f32_0,
    pub unk_28: f32_0,
    pub unk_2C: f32_0,
    pub unk_30: f32_0,
    pub unk_34: f32_0,
    pub unk_38: f32_0,
    pub unk_3C: f32_0,
    pub unk_40: f32_0,
    pub unk_44: Vec3s,
    pub unk_4A: [Vec3s; 4],
    pub unk_62: [Vec3s; 4],
    pub unk_7A: [Vec3s; 2],
    pub unk_86: [Vec3s; 2],
    pub unk_92: u16_0,
    pub unk_94: u16_0,
    pub unk_98: *mut LinkAnimationHeader,
    pub unk_9C: *mut LinkAnimationHeader,
    pub unk_A0: *mut LinkAnimationHeader,
    pub unk_A4: *mut LinkAnimationHeader,
    pub unk_A8: *mut LinkAnimationHeader,
    pub unk_AC: [*mut LinkAnimationHeader; 4],
    pub unk_BC: [*mut LinkAnimationHeader; 2],
    pub unk_C4: [*mut LinkAnimationHeader; 2],
    pub unk_CC: [*mut LinkAnimationHeader; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct LinkAnimationHeader {
    pub common: AnimationHeaderCommon,
    pub segment: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AnimationHeaderCommon {
    pub frameCount: s16,
}
pub type PlayerFunc674
    =
    Option<unsafe extern "C" fn(_: *mut Player, _: *mut GlobalContext) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ColliderQuad {
    pub base: Collider,
    pub info: ColliderInfo,
    pub dim: ColliderQuadDim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ColliderQuadDim {
    pub quad: [Vec3f; 4],
    pub dcMid: Vec3s,
    pub baMid: Vec3s,
    pub acDist: f32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ColliderInfo {
    pub toucher: ColliderTouch,
    pub bumper: ColliderBump,
    pub elemType: u8_0,
    pub toucherFlags: u8_0,
    pub bumperFlags: u8_0,
    pub ocElemFlags: u8_0,
    pub atHit: *mut Collider,
    pub acHit: *mut Collider,
    pub atHitInfo: *mut ColliderInfo,
    pub acHitInfo: *mut ColliderInfo,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ColliderBump {
    pub dmgFlags: u32_0,
    pub effect: u8_0,
    pub defense: u8_0,
    pub hitPos: Vec3s,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ColliderTouch {
    pub dmgFlags: u32_0,
    pub effect: u8_0,
    pub damage: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ColliderCylinder {
    pub base: Collider,
    pub info: ColliderInfo,
    pub dim: Cylinder16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DmaRequest {
    pub vromAddr: u32_0,
    pub dramAddr: *mut libc::c_void,
    pub size: u32_0,
    pub filename: *const libc::c_char,
    pub line: s32,
    pub unk_14: s32,
    pub notifyQueue: *mut OSMesgQueue,
    pub notifyMsg: OSMesg,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Input {
    pub cur: OSContPad,
    pub prev: OSContPad,
    pub press: OSContPad,
    pub rel: OSContPad,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct FlexSkeletonHeader {
    pub sh: SkeletonHeader,
    pub dListCount: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SkeletonHeader {
    pub segment: *mut *mut libc::c_void,
    pub limbCount: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TransitionActorContext {
    pub numActors: u8_0,
    pub list: *mut TransitionActorEntry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TransitionActorEntry {
    pub sides: [C2RustUnnamed_6; 2],
    pub id: s16,
    pub pos: Vec3s,
    pub rotY: s16,
    pub params: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_6 {
    pub room: s8,
    pub effects: s8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RoomContext {
    pub curRoom: Room,
    pub prevRoom: Room,
    pub bufPtrs: [*mut libc::c_void; 2],
    pub unk_30: u8_0,
    pub status: s8,
    pub unk_34: *mut libc::c_void,
    pub dmaRequest: DmaRequest,
    pub loadQueue: OSMesgQueue,
    pub loadMsg: OSMesg,
    pub unk_74: [s16; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Room {
    pub num: s8,
    pub unk_01: u8_0,
    pub unk_02: u8_0,
    pub unk_03: u8_0,
    pub echo: s8,
    pub showInvisActors: u8_0,
    pub mesh: *mut Mesh,
    pub segment: *mut libc::c_void,
    pub unk_10: [libc::c_char; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union Mesh {
    pub polygon: Polygon,
    pub polygon0: PolygonType0,
    pub polygon1: PolygonType1,
    pub polygon2: PolygonType2,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PolygonType2 {
    pub type_0: u8_0,
    pub num: u8_0,
    pub start: *mut libc::c_void,
    pub end: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PolygonType1 {
    pub type_0: u8_0,
    pub format: u8_0,
    pub dlist: *mut Gfx,
    pub c2rust_unnamed: C2RustUnnamed_7,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_7 {
    pub single: C2RustUnnamed_9,
    pub multi: C2RustUnnamed_8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_8 {
    pub count: u8_0,
    pub list: *mut BgImage,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct BgImage {
    pub unk_00: u16_0,
    pub id: u8_0,
    pub source: u32_0,
    pub unk_0C: u32_0,
    pub tlut: u32_0,
    pub width: u16_0,
    pub height: u16_0,
    pub fmt: u8_0,
    pub siz: u8_0,
    pub mode0: u16_0,
    pub tlutCount: u16_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_9 {
    pub source: *mut libc::c_void,
    pub unk_0C: u32_0,
    pub tlut: *mut libc::c_void,
    pub width: u16_0,
    pub height: u16_0,
    pub fmt: u8_0,
    pub siz: u8_0,
    pub mode0: u16_0,
    pub tlutCount: u16_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PolygonType0 {
    pub type_0: u8_0,
    pub num: u8_0,
    pub start: *mut libc::c_void,
    pub end: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Polygon {
    pub type_0: u8_0,
    pub num: u8_0,
    pub start: *mut libc::c_void,
    pub end: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ObjectContext {
    pub spaceStart: *mut libc::c_void,
    pub spaceEnd: *mut libc::c_void,
    pub num: u8_0,
    pub unk_09: u8_0,
    pub mainKeepIndex: u8_0,
    pub subKeepIndex: u8_0,
    pub status: [ObjectStatus; 19],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ObjectStatus {
    pub id: s16,
    pub segment: *mut libc::c_void,
    pub dmaRequest: DmaRequest,
    pub loadQueue: OSMesgQueue,
    pub loadMsg: OSMesg,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AnimationContext {
    pub animationCount: s16,
    pub entries: [AnimationEntry; 50],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AnimationEntry {
    pub type_0: u8_0,
    pub data: AnimationEntryData,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union AnimationEntryData {
    pub load: AnimEntryLoadFrame,
    pub copy: AnimEntryCopyAll,
    pub interp: AnimEntryInterp,
    pub copy1: AnimEntryCopyTrue,
    pub copy0: AnimEntryCopyFalse,
    pub move_0: AnimEntryMoveActor,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AnimEntryMoveActor {
    pub actor: *mut Actor,
    pub skelAnime: *mut SkelAnime,
    pub unk_08: f32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AnimEntryCopyFalse {
    pub queueFlag: u8_0,
    pub vecCount: u8_0,
    pub dst: *mut Vec3s,
    pub src: *mut Vec3s,
    pub copyFlag: *mut u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AnimEntryCopyTrue {
    pub queueFlag: u8_0,
    pub vecCount: u8_0,
    pub dst: *mut Vec3s,
    pub src: *mut Vec3s,
    pub copyFlag: *mut u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AnimEntryInterp {
    pub queueFlag: u8_0,
    pub vecCount: u8_0,
    pub base: *mut Vec3s,
    pub mod_0: *mut Vec3s,
    pub weight: f32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AnimEntryCopyAll {
    pub queueFlag: u8_0,
    pub vecCount: u8_0,
    pub dst: *mut Vec3s,
    pub src: *mut Vec3s,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AnimEntryLoadFrame {
    pub req: DmaRequest,
    pub msgQueue: OSMesgQueue,
    pub msg: OSMesg,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EnvironmentContext {
    pub unk_00: [libc::c_char; 2],
    pub timeIncrement: u16_0,
    pub sunPos: Vec3f,
    pub skybox1Index: u8_0,
    pub skybox2Index: u8_0,
    pub unk_12: [libc::c_char; 1],
    pub skyboxBlend: u8_0,
    pub unk_14: [libc::c_char; 1],
    pub skyboxDisabled: u8_0,
    pub sunMoonDisabled: u8_0,
    pub unk_17: u8_0,
    pub unk_18: u8_0,
    pub unk_19: u8_0,
    pub unk_1A: u16_0,
    pub unk_1C: [libc::c_char; 2],
    pub indoors: u8_0,
    pub unk_1F: u8_0,
    pub unk_20: u8_0,
    pub unk_21: u8_0,
    pub unk_22: u16_0,
    pub unk_24: u16_0,
    pub unk_26: [libc::c_char; 2],
    pub dirLight1: LightInfo,
    pub dirLight2: LightInfo,
    pub skyboxDmaState: s8,
    pub dmaRequest: DmaRequest,
    pub loadQueue: OSMesgQueue,
    pub loadMsg: OSMesg,
    pub unk_84: f32_0,
    pub unk_88: f32_0,
    pub adjAmbientColor: [s16; 3],
    pub adjLight1Color: [s16; 3],
    pub adjFogColor: [s16; 3],
    pub adjFogNear: s16,
    pub adjFogFar: s16,
    pub unk_A2: [libc::c_char; 6],
    pub windDirection: Vec3s,
    pub windSpeed: f32_0,
    pub numLightSettings: u8_0,
    pub lightSettingsList: *mut EnvLightSettings,
    pub blendIndoorLights: u8_0,
    pub unk_BD: u8_0,
    pub unk_BE: u8_0,
    pub unk_BF: u8_0,
    pub lightSettings: EnvLightSettings,
    pub unk_D6: u16_0,
    pub unk_D8: f32_0,
    pub unk_DC: u8_0,
    pub gloomySkyMode: u8_0,
    pub unk_DE: u8_0,
    pub lightningMode: u8_0,
    pub unk_E0: u8_0,
    pub fillScreen: u8_0,
    pub screenFillColor: [u8_0; 4],
    pub sandstormState: u8_0,
    pub sandstormPrimA: u8_0,
    pub sandstormEnvA: u8_0,
    pub customSkyboxFilter: u8_0,
    pub skyboxFilterColor: [u8_0; 4],
    pub unk_EE: [u8_0; 4],
    pub unk_F2: [u8_0; 4],
    pub unk_F6: [libc::c_char; 6],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EnvLightSettings {
    pub ambientColor: [u8_0; 3],
    pub light1Dir: [s8; 3],
    pub light1Color: [u8_0; 3],
    pub light2Dir: [s8; 3],
    pub light2Color: [u8_0; 3],
    pub fogColor: [u8_0; 3],
    pub fogNear: s16,
    pub fogFar: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GameOverContext {
    pub state: u16_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PauseContext {
    pub view: View,
    pub iconItemSegment: *mut u8_0,
    pub iconItem24Segment: *mut u8_0,
    pub iconItemAltSegment: *mut u8_0,
    pub iconItemLangSegment: *mut u8_0,
    pub nameSegment: *mut u8_0,
    pub playerSegment: *mut u8_0,
    pub unk_140: [libc::c_char; 4],
    pub itemPageVtx: *mut Vtx,
    pub equipPageVtx: *mut Vtx,
    pub mapPageVtx: *mut Vtx,
    pub questPageVtx: *mut Vtx,
    pub infoPanelVtx: *mut Vtx,
    pub itemVtx: *mut Vtx,
    pub equipVtx: *mut Vtx,
    pub unk_160: [libc::c_char; 4],
    pub questVtx: *mut Vtx,
    pub cursorVtx: *mut Vtx,
    pub saveVtx: *mut Vtx,
    pub unk_170: [libc::c_char; 36],
    pub ocarinaStaff: *mut OcarinaStaff,
    pub unk_198: [libc::c_char; 32],
    pub loadQueue: OSMesgQueue,
    pub loadMsg: OSMesg,
    pub state: u16_0,
    pub debugState: u16_0,
    pub eye: Vec3f,
    pub unk_1E4: u16_0,
    pub mode: u16_0,
    pub pageIndex: u16_0,
    pub unk_1EA: u16_0,
    pub unk_1EC: u16_0,
    pub unk_1F0: f32_0,
    pub unk_1F4: f32_0,
    pub unk_1F8: f32_0,
    pub unk_1FC: f32_0,
    pub unk_200: f32_0,
    pub unk_204: f32_0,
    pub alpha: u16_0,
    pub offsetY: s16,
    pub unk_20C: [libc::c_char; 8],
    pub stickRelX: s16,
    pub stickRelY: s16,
    pub cursorPoint: [s16; 5],
    pub cursorX: [s16; 5],
    pub cursorY: [s16; 5],
    pub dungeonMapSlot: s16,
    pub cursorSpecialPos: s16,
    pub pageSwitchTimer: s16,
    pub namedItem: u16_0,
    pub cursorItem: [u16_0; 4],
    pub cursorSlot: [u16_0; 4],
    pub equipTargetItem: u16_0,
    pub equipTargetSlot: u16_0,
    pub equipTargetCBtn: u16_0,
    pub equipAnimX: s16,
    pub equipAnimY: s16,
    pub equipAnimAlpha: s16,
    pub infoPanelOffsetY: s16,
    pub nameDisplayTimer: u16_0,
    pub nameColorSet: u16_0,
    pub cursorColorSet: s16,
    pub promptChoice: s16,
    pub ocarinaSongIdx: s16,
    pub worldMapPoints: [u8_0; 20],
    pub tradeQuestLocation: u8_0,
    pub playerSkelAnime: SkelAnime,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OcarinaStaff {
    pub noteIdx: u8_0,
    pub state: u8_0,
    pub pos: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct View {
    pub magic: s32,
    pub gfxCtx: *mut GraphicsContext,
    pub viewport: Viewport,
    pub fovy: f32_0,
    pub zNear: f32_0,
    pub zFar: f32_0,
    pub scale: f32_0,
    pub eye: Vec3f,
    pub lookAt: Vec3f,
    pub up: Vec3f,
    pub vp: Vp,
    pub projection: Mtx,
    pub viewing: Mtx,
    pub projectionPtr: *mut Mtx,
    pub viewingPtr: *mut Mtx,
    pub unk_E8: Vec3f,
    pub unk_F4: Vec3f,
    pub unk_100: f32_0,
    pub unk_104: Vec3f,
    pub unk_110: Vec3f,
    pub normal: u16_0,
    pub flags: s32,
    pub unk_124: s32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Viewport {
    pub topY: s32,
    pub bottomY: s32,
    pub leftX: s32,
    pub rightX: s32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GraphicsContext {
    pub polyOpaBuffer: *mut Gfx,
    pub polyXluBuffer: *mut Gfx,
    pub unk_008: [libc::c_char; 8],
    pub overlayBuffer: *mut Gfx,
    pub unk_014: u32_0,
    pub unk_018: [libc::c_char; 32],
    pub msgBuff: [OSMesg; 8],
    pub schedMsgQ: *mut OSMesgQueue,
    pub queue: OSMesgQueue,
    pub unk_074: [libc::c_char; 4],
    pub task: OSScTask,
    pub unk_0D0: [libc::c_char; 224],
    pub workBuffer: *mut Gfx,
    pub work: TwoHeadGfxArena,
    pub unk_01C4: [libc::c_char; 192],
    pub viMode: *mut OSViMode,
    pub unk_0288: [libc::c_char; 32],
    pub overlay: TwoHeadGfxArena,
    pub polyOpa: TwoHeadGfxArena,
    pub polyXlu: TwoHeadGfxArena,
    pub gfxPoolIdx: u32_0,
    pub curFrameBuffer: *mut u16_0,
    pub unk_2E0: [libc::c_char; 4],
    pub viFeatures: u32_0,
    pub fbIdx: s32,
    pub callback: Option<unsafe extern "C" fn(_: *mut GraphicsContext,
                                              _: *mut libc::c_void) -> ()>,
    pub callbackParam: *mut libc::c_void,
    pub xScale: f32_0,
    pub yScale: f32_0,
    pub unk_2FC: [libc::c_char; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TwoHeadGfxArena {
    pub size: u32_0,
    pub bufp: *mut Gfx,
    pub p: *mut Gfx,
    pub d: *mut Gfx,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OSScTask {
    pub next: *mut OSScTask,
    pub state: u32_0,
    pub flags: u32_0,
    pub framebuffer: *mut CfbInfo,
    pub list: OSTask,
    pub msgQ: *mut OSMesgQueue,
    pub msg: OSMesg,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CfbInfo {
    pub fb1: *mut u16_0,
    pub swapBuffer: *mut u16_0,
    pub viMode: *mut OSViMode,
    pub features: u32_0,
    pub unk_10: u8_0,
    pub updateRate: s8,
    pub updateRate2: s8,
    pub unk_13: u8_0,
    pub xScale: f32_0,
    pub yScale: f32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct InterfaceContext {
    pub view: View,
    pub actionVtx: *mut Vtx,
    pub beatingHeartVtx: *mut Vtx,
    pub parameterSegment: *mut u8_0,
    pub doActionSegment: *mut u8_0,
    pub iconItemSegment: *mut u8_0,
    pub mapSegment: *mut u8_0,
    pub mapPalette: [u8_0; 32],
    pub dmaRequest_160: DmaRequest,
    pub dmaRequest_180: DmaRequest,
    pub unk_1A0: [libc::c_char; 32],
    pub loadQueue: OSMesgQueue,
    pub loadMsg: OSMesg,
    pub viewport: Viewport,
    pub unk_1EC: s16,
    pub unk_1EE: u16_0,
    pub unk_1F0: u16_0,
    pub unk_1F4: f32_0,
    pub naviCalling: s16,
    pub unk_1FA: s16,
    pub unk_1FC: s16,
    pub unk_1FE: s16,
    pub unk_200: s16,
    pub beatingHeartPrim: [s16; 3],
    pub beatingHeartEnv: [s16; 3],
    pub heartsPrimR: [s16; 2],
    pub heartsPrimG: [s16; 2],
    pub heartsPrimB: [s16; 2],
    pub heartsEnvR: [s16; 2],
    pub heartsEnvG: [s16; 2],
    pub heartsEnvB: [s16; 2],
    pub unk_226: s16,
    pub unk_228: s16,
    pub unk_22A: s16,
    pub unk_22C: s16,
    pub unk_22E: s16,
    pub unk_230: s16,
    pub counterDigits: [s16; 4],
    pub numHorseBoosts: u8_0,
    pub unk_23C: u16_0,
    pub hbaAmmo: u16_0,
    pub unk_240: u16_0,
    pub unk_242: u16_0,
    pub unk_244: u16_0,
    pub aAlpha: u16_0,
    pub bAlpha: u16_0,
    pub cLeftAlpha: u16_0,
    pub cDownAlpha: u16_0,
    pub cRightAlpha: u16_0,
    pub healthAlpha: u16_0,
    pub magicAlpha: u16_0,
    pub minimapAlpha: u16_0,
    pub startAlpha: s16,
    pub unk_258: s16,
    pub unk_25A: s16,
    pub mapRoomNum: s16,
    pub mapPaletteIndex: s16,
    pub unk_260: u8_0,
    pub unk_261: u8_0,
    pub restrictions: C2RustUnnamed_10,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_10 {
    pub hGauge: u8_0,
    pub bButton: u8_0,
    pub aButton: u8_0,
    pub bottles: u8_0,
    pub tradeItems: u8_0,
    pub hookshot: u8_0,
    pub ocarina: u8_0,
    pub warpSongs: u8_0,
    pub sunsSong: u8_0,
    pub farores: u8_0,
    pub dinsNayrus: u8_0,
    pub all: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct MessageContext {
    pub view: View,
    pub font: Font,
    pub textboxSegment: *mut libc::c_void,
    pub unk_E2B4: [libc::c_char; 4],
    pub ocarinaStaff: *mut OcarinaStaff,
    pub unk_E2BC: [libc::c_char; 60],
    pub textId: u16_0,
    pub choiceTextId: u16_0,
    pub textBoxProperties: u8_0,
    pub textBoxType: u8_0,
    pub textBoxPos: u8_0,
    pub msgLength: s32,
    pub msgMode: u8_0,
    pub unk_E305: [libc::c_char; 1],
    pub msgBufDecoded: [u8_0; 200],
    pub msgBufPos: u16_0,
    pub unk_E3D0: u16_0,
    pub textDrawPos: u16_0,
    pub decodedTextLen: u16_0,
    pub textUnskippable: u16_0,
    pub textPosX: s16,
    pub textPosY: s16,
    pub textColorR: s16,
    pub textColorG: s16,
    pub textColorB: s16,
    pub textColorAlpha: s16,
    pub textboxEndType: u8_0,
    pub choiceIndex: u8_0,
    pub choiceNum: u8_0,
    pub stateTimer: u8_0,
    pub textDelayTimer: u16_0,
    pub textDelay: u16_0,
    pub lastPlayedSong: u16_0,
    pub ocarinaMode: u16_0,
    pub ocarinaAction: u16_0,
    pub unk_E3F2: u16_0,
    pub unk_E3F4: u16_0,
    pub textboxBackgroundIdx: u16_0,
    pub textboxBackgroundForeColorIdx: u8_0,
    pub textboxBackgroundBackColorIdx: u8_0,
    pub textboxBackgroundYOffsetIdx: u8_0,
    pub textboxBackgroundUnkArg: u8_0,
    pub unk_E3FC: [libc::c_char; 2],
    pub textboxColorRed: s16,
    pub textboxColorGreen: s16,
    pub textboxColorBlue: s16,
    pub textboxColorAlphaTarget: s16,
    pub textboxColorAlphaCurrent: s16,
    pub talkActor: *mut Actor,
    pub disableWarpSongs: s16,
    pub unk_E40E: s16,
    pub lastOcaNoteIdx: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Font {
    pub msgOffset: u32_0,
    pub msgLength: u32_0,
    pub charTexBuf: [u8_0; 15360],
    pub iconBuf: [u8_0; 128],
    pub fontBuf: [u8_0; 40960],
    pub c2rust_unnamed: C2RustUnnamed_11,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_11 {
    pub msgBuf: [libc::c_char; 1280],
    pub msgBufWide: [u16_0; 640],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SkyboxContext {
    pub unk_00: [libc::c_char; 296],
    pub staticSegments: [*mut libc::c_void; 2],
    pub palettes: *mut [u16_0; 256],
    pub dListBuf: *mut [Gfx; 150],
    pub unk_138: *mut Gfx,
    pub roomVtx: *mut Vtx,
    pub unk_140: s16,
    pub rot: Vec3f,
    pub unk_150: [libc::c_char; 16],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SramContext {
    pub readBuff: *mut u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SoundSource {
    pub countdown: u16_0,
    pub originPos: Vec3f,
    pub relativePos: Vec3f,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CutsceneContext {
    pub unk_00: [libc::c_char; 4],
    pub segment: *mut libc::c_void,
    pub state: u8_0,
    pub unk_0C: f32_0,
    pub frames: u16_0,
    pub unk_12: u16_0,
    pub unk_14: s32,
    pub unk_18: u16_0,
    pub unk_1A: u8_0,
    pub unk_1B: u8_0,
    pub cameraFocus: *mut CutsceneCameraPoint,
    pub cameraPosition: *mut CutsceneCameraPoint,
    pub linkAction: *mut CsCmdActorAction,
    pub npcActions: [*mut CsCmdActorAction; 10],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CsCmdActorAction {
    pub action: u16_0,
    pub startFrame: u16_0,
    pub endFrame: u16_0,
    pub c2rust_unnamed: C2RustUnnamed_12,
    pub startPos: Vec3i,
    pub endPos: Vec3i,
    pub normal: Vec3i,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_12 {
    pub rot: Vec3s,
    pub urot: Vec3us,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CutsceneCameraPoint {
    pub continueFlag: s8,
    pub cameraRoll: s8,
    pub nextPointFrame: u16_0,
    pub viewAngle: f32_0,
    pub pos: Vec3s,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ActorContext {
    pub freezeFlashTimer: u8_0,
    pub unk_01: [libc::c_char; 1],
    pub unk_02: u8_0,
    pub unk_03: u8_0,
    pub unk_04: [libc::c_char; 4],
    pub total: u8_0,
    pub unk_09: [libc::c_char; 3],
    pub actorLists: [ActorListEntry; 12],
    pub targetCtx: TargetContext,
    pub flags: C2RustUnnamed_13,
    pub titleCtx: TitleCardContext,
    pub unk_138: [libc::c_char; 4],
    pub absoluteSpace: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TitleCardContext {
    pub texture: *mut libc::c_void,
    pub x: s16,
    pub y: s16,
    pub width: u8_0,
    pub height: u8_0,
    pub durationTimer: u8_0,
    pub delayTimer: u8_0,
    pub alpha: s16,
    pub intensity: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_13 {
    pub swch: u32_0,
    pub tempSwch: u32_0,
    pub unk0: u32_0,
    pub unk1: u32_0,
    pub chest: u32_0,
    pub clear: u32_0,
    pub tempClear: u32_0,
    pub collect: u32_0,
    pub tempCollect: u32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TargetContext {
    pub naviRefPos: Vec3f,
    pub targetCenterPos: Vec3f,
    pub naviInner: Color_RGBAf,
    pub naviOuter: Color_RGBAf,
    pub arrowPointedActor: *mut Actor,
    pub targetedActor: *mut Actor,
    pub unk_40: f32_0,
    pub unk_44: f32_0,
    pub unk_48: s16,
    pub activeCategory: u8_0,
    pub unk_4B: u8_0,
    pub unk_4C: s8,
    pub unk_4D: [libc::c_char; 3],
    pub arr_50: [TargetContextEntry; 3],
    pub unk_8C: *mut Actor,
    pub bgmEnemy: *mut Actor,
    pub unk_94: *mut Actor,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TargetContextEntry {
    pub pos: Vec3f,
    pub unk_0C: f32_0,
    pub color: Color_RGB8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ActorListEntry {
    pub length: s32,
    pub head: *mut Actor,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CollisionContext {
    pub colHeader: *mut CollisionHeader,
    pub minBounds: Vec3f,
    pub maxBounds: Vec3f,
    pub subdivAmount: Vec3i,
    pub subdivLength: Vec3f,
    pub subdivLengthInv: Vec3f,
    pub lookupTbl: *mut StaticLookup,
    pub polyNodes: SSNodeList,
    pub dyna: DynaCollisionContext,
    pub memSize: u32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DynaCollisionContext {
    pub bitFlag: u8_0,
    pub bgActors: [BgActor; 50],
    pub bgActorFlags: [u16_0; 50],
    pub polyList: *mut CollisionPoly,
    pub vtxList: *mut Vec3s,
    pub polyNodes: DynaSSNodeList,
    pub polyNodesMax: s32,
    pub polyListMax: s32,
    pub vtxListMax: s32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DynaSSNodeList {
    pub tbl: *mut SSNode,
    pub count: s32,
    pub max: s32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SSNode {
    pub polyId: s16,
    pub next: u16_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct BgActor {
    pub actor: *mut Actor,
    pub colHeader: *mut CollisionHeader,
    pub dynaLookup: DynaLookup,
    pub vtxStartIndex: u16_0,
    pub prevTransform: ScaleRotPos,
    pub curTransform: ScaleRotPos,
    pub boundingSphere: Sphere16,
    pub minY: f32_0,
    pub maxY: f32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ScaleRotPos {
    pub scale: Vec3f,
    pub rot: Vec3s,
    pub pos: Vec3f,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DynaLookup {
    pub polyStartIndex: u16_0,
    pub ceiling: SSList,
    pub wall: SSList,
    pub floor: SSList,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SSList {
    pub head: u16_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CollisionHeader {
    pub minBounds: Vec3s,
    pub maxBounds: Vec3s,
    pub numVertices: u16_0,
    pub vtxList: *mut Vec3s,
    pub numPolygons: u16_0,
    pub polyList: *mut CollisionPoly,
    pub surfaceTypeList: *mut SurfaceType,
    pub cameraDataList: *mut CamData,
    pub numWaterBoxes: u16_0,
    pub waterBoxes: *mut WaterBox,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct WaterBox {
    pub xMin: s16,
    pub ySurface: s16,
    pub zMin: s16,
    pub xLength: s16,
    pub zLength: s16,
    pub properties: u32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CamData {
    pub cameraSType: u16_0,
    pub numCameras: s16,
    pub camPosData: *mut Vec3s,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SurfaceType {
    pub data: [u32_0; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SSNodeList {
    pub max: u16_0,
    pub count: u16_0,
    pub tbl: *mut SSNode,
    pub polyCheckTbl: *mut u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct StaticLookup {
    pub floor: SSList,
    pub wall: SSList,
    pub ceiling: SSList,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct FrameAdvanceContext {
    pub enabled: s32,
    pub timer: s32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SequenceContext {
    pub seqId: u8_0,
    pub natureAmbienceId: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Camera {
    pub paramData: [libc::c_char; 80],
    pub at: Vec3f,
    pub eye: Vec3f,
    pub up: Vec3f,
    pub eyeNext: Vec3f,
    pub skyboxOffset: Vec3f,
    pub globalCtx: *mut GlobalContext,
    pub player: *mut Player,
    pub playerPosRot: PosRot,
    pub target: *mut Actor,
    pub targetPosRot: PosRot,
    pub rUpdateRateInv: f32_0,
    pub pitchUpdateRateInv: f32_0,
    pub yawUpdateRateInv: f32_0,
    pub xzOffsetUpdateRate: f32_0,
    pub yOffsetUpdateRate: f32_0,
    pub fovUpdateRate: f32_0,
    pub xzSpeed: f32_0,
    pub dist: f32_0,
    pub speedRatio: f32_0,
    pub posOffset: Vec3f,
    pub playerPosDelta: Vec3f,
    pub fov: f32_0,
    pub atLERPStepScale: f32_0,
    pub playerGroundY: f32_0,
    pub floorNorm: Vec3f,
    pub waterYPos: f32_0,
    pub waterPrevCamIdx: s32,
    pub waterPrevCamSetting: s32,
    pub waterQuakeId: s32,
    pub data0: *mut libc::c_void,
    pub data1: *mut libc::c_void,
    pub data2: s16,
    pub data3: s16,
    pub uid: s16,
    pub unk_132: [libc::c_char; 2],
    pub inputDir: Vec3s,
    pub camDir: Vec3s,
    pub status: s16,
    pub setting: s16,
    pub mode: s16,
    pub bgCheckId: s16,
    pub camDataIdx: s16,
    pub unk_14A: s16,
    pub unk_14C: s16,
    pub childCamIdx: s16,
    pub unk_150: s16,
    pub unk_152: s16,
    pub prevSetting: s16,
    pub nextCamDataIdx: s16,
    pub nextBGCheckId: s16,
    pub roll: s16,
    pub paramFlags: s16,
    pub animState: s16,
    pub timer: s16,
    pub parentCamIdx: s16,
    pub thisIdx: s16,
    pub prevCamDataIdx: s16,
    pub csId: s16,
    pub unk_16A: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GameState {
    pub gfxCtx: *mut GraphicsContext,
    pub main: GameStateFunc,
    pub destroy: GameStateFunc,
    pub init: GameStateFunc,
    pub size: u32_0,
    pub input: [Input; 4],
    pub tha: TwoHeadArena,
    pub alloc: GameAlloc,
    pub running: u32_0,
    pub frames: u32_0,
    pub unk_A0: u32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GameAlloc {
    pub base: GameAllocEntry,
    pub head: *mut GameAllocEntry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GameAllocEntry {
    pub next: *mut GameAllocEntry,
    pub prev: *mut GameAllocEntry,
    pub size: u32_0,
    pub unk_0C: u32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TwoHeadArena {
    pub size: u32_0,
    pub bufp: *mut libc::c_void,
    pub head: *mut libc::c_void,
    pub tail: *mut libc::c_void,
}
pub type GameStateFunc
    =
    Option<unsafe extern "C" fn(_: *mut GameState) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SkinAvb {
    pub unk_0: u8_0,
    pub buf: [*mut Vtx; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PSkinAwb {
    pub skeletonHeader: *mut SkeletonHeader,
    pub mtx: MtxF,
    pub avbCount: s32,
    pub avbTbl: *mut SkinAvb,
    pub skelAnime: SkelAnime,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ColliderJntSphElementDim {
    pub modelSphere: Sphere16,
    pub worldSphere: Sphere16,
    pub scale: f32_0,
    pub limb: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ColliderJntSphElement {
    pub info: ColliderInfo,
    pub dim: ColliderJntSphElementDim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ColliderJntSph {
    pub base: Collider,
    pub count: s32,
    pub elements: *mut ColliderJntSphElement,
}
pub type C2RustUnnamed_14 = libc::c_uint;
pub const ACTORCAT_CHEST: C2RustUnnamed_14 = 11;
pub const ACTORCAT_DOOR: C2RustUnnamed_14 = 10;
pub const ACTORCAT_BOSS: C2RustUnnamed_14 = 9;
pub const ACTORCAT_MISC: C2RustUnnamed_14 = 8;
pub const ACTORCAT_ITEMACTION: C2RustUnnamed_14 = 7;
pub const ACTORCAT_PROP: C2RustUnnamed_14 = 6;
pub const ACTORCAT_ENEMY: C2RustUnnamed_14 = 5;
pub const ACTORCAT_NPC: C2RustUnnamed_14 = 4;
pub const ACTORCAT_EXPLOSIVE: C2RustUnnamed_14 = 3;
pub const ACTORCAT_PLAYER: C2RustUnnamed_14 = 2;
pub const ACTORCAT_BG: C2RustUnnamed_14 = 1;
pub const ACTORCAT_SWITCH: C2RustUnnamed_14 = 0;
pub type C2RustUnnamed_15 = libc::c_uint;
pub const ACTOR_ID_MAX: C2RustUnnamed_15 = 471;
pub const ACTOR_OBJ_WARP2BLOCK: C2RustUnnamed_15 = 470;
pub const ACTOR_BG_JYA_BLOCK: C2RustUnnamed_15 = 469;
pub const ACTOR_EN_MM2: C2RustUnnamed_15 = 468;
pub const ACTOR_EN_ZL4: C2RustUnnamed_15 = 467;
pub const ACTOR_OBJ_HAMISHI: C2RustUnnamed_15 = 466;
pub const ACTOR_OBJ_TIMEBLOCK: C2RustUnnamed_15 = 465;
pub const ACTOR_EN_GE3: C2RustUnnamed_15 = 464;
pub const ACTOR_OBJ_MAKEKINSUTA: C2RustUnnamed_15 = 463;
pub const ACTOR_EN_ZO: C2RustUnnamed_15 = 462;
pub const ACTOR_BG_MENKURI_NISEKABE: C2RustUnnamed_15 = 461;
pub const ACTOR_EN_EG: C2RustUnnamed_15 = 460;
pub const ACTOR_OCEFF_WIPE4: C2RustUnnamed_15 = 459;
pub const ACTOR_EN_KAKASI3: C2RustUnnamed_15 = 458;
pub const ACTOR_EN_KAKASI2: C2RustUnnamed_15 = 457;
pub const ACTOR_BG_ICE_SHUTTER: C2RustUnnamed_15 = 456;
pub const ACTOR_BG_ICE_TURARA: C2RustUnnamed_15 = 455;
pub const ACTOR_EN_COW: C2RustUnnamed_15 = 454;
pub const ACTOR_EN_MA3: C2RustUnnamed_15 = 453;
pub const ACTOR_BG_SPOT18_SHUTTER: C2RustUnnamed_15 = 452;
pub const ACTOR_BG_SPOT18_FUTA: C2RustUnnamed_15 = 451;
pub const ACTOR_BG_SPOT11_OASIS: C2RustUnnamed_15 = 450;
pub const ACTOR_DOOR_KILLER: C2RustUnnamed_15 = 449;
pub const ACTOR_EN_CROW: C2RustUnnamed_15 = 448;
pub const ACTOR_EN_PO_DESERT: C2RustUnnamed_15 = 447;
pub const ACTOR_EN_WALL_TUBO: C2RustUnnamed_15 = 446;
pub const ACTOR_BG_BOWL_WALL: C2RustUnnamed_15 = 445;
pub const ACTOR_EN_DAIKU_KAKARIKO: C2RustUnnamed_15 = 444;
pub const ACTOR_BG_MIZU_SHUTTER: C2RustUnnamed_15 = 443;
pub const ACTOR_BG_MIZU_BWALL: C2RustUnnamed_15 = 442;
pub const ACTOR_EN_GS: C2RustUnnamed_15 = 441;
pub const ACTOR_EN_GB: C2RustUnnamed_15 = 440;
pub const ACTOR_BG_GND_ICEBLOCK: C2RustUnnamed_15 = 439;
pub const ACTOR_BG_GND_NISEKABE: C2RustUnnamed_15 = 438;
pub const ACTOR_BG_GND_SOULMEIRO: C2RustUnnamed_15 = 437;
pub const ACTOR_BG_GND_DARKMEIRO: C2RustUnnamed_15 = 436;
pub const ACTOR_BG_GND_FIREMEIRO: C2RustUnnamed_15 = 435;
pub const ACTOR_DEMO_GEFF: C2RustUnnamed_15 = 434;
pub const ACTOR_DEMO_GJ: C2RustUnnamed_15 = 433;
pub const ACTOR_EN_SKB: C2RustUnnamed_15 = 432;
pub const ACTOR_EN_WF: C2RustUnnamed_15 = 431;
pub const ACTOR_EN_GO2: C2RustUnnamed_15 = 430;
pub const ACTOR_EN_MU: C2RustUnnamed_15 = 429;
pub const ACTOR_EN_TG: C2RustUnnamed_15 = 428;
pub const ACTOR_OBJ_MURE3: C2RustUnnamed_15 = 427;
pub const ACTOR_UNSET_1AA: C2RustUnnamed_15 = 426;
pub const ACTOR_BG_SPOT17_BAKUDANKABE: C2RustUnnamed_15 = 425;
pub const ACTOR_BG_SPOT08_BAKUDANKABE: C2RustUnnamed_15 = 424;
pub const ACTOR_DEMO_KEKKAI: C2RustUnnamed_15 = 423;
pub const ACTOR_EN_HS2: C2RustUnnamed_15 = 422;
pub const ACTOR_BG_BOM_GUARD: C2RustUnnamed_15 = 421;
pub const ACTOR_EN_GUEST: C2RustUnnamed_15 = 420;
pub const ACTOR_EN_DNT_NOMAL: C2RustUnnamed_15 = 419;
pub const ACTOR_EN_DNT_JIJI: C2RustUnnamed_15 = 418;
pub const ACTOR_EN_DNT_DEMO: C2RustUnnamed_15 = 417;
pub const ACTOR_OBJ_KIBAKO2: C2RustUnnamed_15 = 416;
pub const ACTOR_BG_SPOT11_BAKUDANKABE: C2RustUnnamed_15 = 415;
pub const ACTOR_OBJ_COMB: C2RustUnnamed_15 = 414;
pub const ACTOR_BG_SPOT01_OBJECTS2: C2RustUnnamed_15 = 413;
pub const ACTOR_EN_SI: C2RustUnnamed_15 = 412;
pub const ACTOR_EN_DOG: C2RustUnnamed_15 = 411;
pub const ACTOR_EN_NIW_GIRL: C2RustUnnamed_15 = 410;
pub const ACTOR_OCEFF_WIPE3: C2RustUnnamed_15 = 409;
pub const ACTOR_OCEFF_WIPE2: C2RustUnnamed_15 = 408;
pub const ACTOR_EN_GELDB: C2RustUnnamed_15 = 407;
pub const ACTOR_EN_IT: C2RustUnnamed_15 = 406;
pub const ACTOR_EN_SHOPNUTS: C2RustUnnamed_15 = 405;
pub const ACTOR_BG_SPOT00_BREAK: C2RustUnnamed_15 = 404;
pub const ACTOR_EN_NUTSBALL: C2RustUnnamed_15 = 403;
pub const ACTOR_EN_HINTNUTS: C2RustUnnamed_15 = 402;
pub const ACTOR_BG_SPOT12_SAKU: C2RustUnnamed_15 = 401;
pub const ACTOR_BG_SPOT12_GATE: C2RustUnnamed_15 = 400;
pub const ACTOR_BG_JYA_HAHENIRON: C2RustUnnamed_15 = 399;
pub const ACTOR_BG_JYA_1FLIFT: C2RustUnnamed_15 = 398;
pub const ACTOR_BG_SPOT05_SOKO: C2RustUnnamed_15 = 397;
pub const ACTOR_EN_WEIYER: C2RustUnnamed_15 = 396;
pub const ACTOR_OCEFF_STORM: C2RustUnnamed_15 = 395;
pub const ACTOR_OCEFF_WIPE: C2RustUnnamed_15 = 394;
pub const ACTOR_EN_STH: C2RustUnnamed_15 = 393;
pub const ACTOR_EN_SSH: C2RustUnnamed_15 = 392;
pub const ACTOR_OBJ_ROOMTIMER: C2RustUnnamed_15 = 391;
pub const ACTOR_EN_GE2: C2RustUnnamed_15 = 390;
pub const ACTOR_EN_WONDER_TALK2: C2RustUnnamed_15 = 389;
pub const ACTOR_EN_DY_EXTRA: C2RustUnnamed_15 = 388;
pub const ACTOR_SHOT_SUN: C2RustUnnamed_15 = 387;
pub const ACTOR_DEMO_EC: C2RustUnnamed_15 = 386;
pub const ACTOR_EN_TORCH: C2RustUnnamed_15 = 385;
pub const ACTOR_UNSET_180: C2RustUnnamed_15 = 384;
pub const ACTOR_END_TITLE: C2RustUnnamed_15 = 383;
pub const ACTOR_OCEFF_SPOT: C2RustUnnamed_15 = 382;
pub const ACTOR_OBJ_MAKEOSHIHIKI: C2RustUnnamed_15 = 381;
pub const ACTOR_EN_TAKARA_MAN: C2RustUnnamed_15 = 380;
pub const ACTOR_EN_KAKASI: C2RustUnnamed_15 = 379;
pub const ACTOR_BOSS_GANON2: C2RustUnnamed_15 = 378;
pub const ACTOR_EN_ZL3: C2RustUnnamed_15 = 377;
pub const ACTOR_EN_HEISHI4: C2RustUnnamed_15 = 376;
pub const ACTOR_BG_ZG: C2RustUnnamed_15 = 375;
pub const ACTOR_EFC_ERUPC: C2RustUnnamed_15 = 374;
pub const ACTOR_EN_PO_FIELD: C2RustUnnamed_15 = 373;
pub const ACTOR_DEMO_GT: C2RustUnnamed_15 = 372;
pub const ACTOR_ELF_MSG2: C2RustUnnamed_15 = 371;
pub const ACTOR_DOOR_GERUDO: C2RustUnnamed_15 = 370;
pub const ACTOR_EN_MAG: C2RustUnnamed_15 = 369;
pub const ACTOR_EN_OKARINA_EFFECT: C2RustUnnamed_15 = 368;
pub const ACTOR_EN_GANON_MANT: C2RustUnnamed_15 = 367;
pub const ACTOR_EN_HY: C2RustUnnamed_15 = 366;
pub const ACTOR_EN_MD: C2RustUnnamed_15 = 365;
pub const ACTOR_EN_CS: C2RustUnnamed_15 = 364;
pub const ACTOR_EN_JSJUTAN: C2RustUnnamed_15 = 363;
pub const ACTOR_EN_JS: C2RustUnnamed_15 = 362;
pub const ACTOR_BG_JYA_IRONOBJ: C2RustUnnamed_15 = 361;
pub const ACTOR_EN_EX_ITEM: C2RustUnnamed_15 = 360;
pub const ACTOR_EN_ANI: C2RustUnnamed_15 = 359;
pub const ACTOR_BG_SST_FLOOR: C2RustUnnamed_15 = 358;
pub const ACTOR_EN_WEATHER_TAG: C2RustUnnamed_15 = 357;
pub const ACTOR_EN_KZ: C2RustUnnamed_15 = 356;
pub const ACTOR_EN_KO: C2RustUnnamed_15 = 355;
pub const ACTOR_EN_MM: C2RustUnnamed_15 = 354;
pub const ACTOR_UNSET_161: C2RustUnnamed_15 = 353;
pub const ACTOR_EN_STREAM: C2RustUnnamed_15 = 352;
pub const ACTOR_EN_SIOFUKI: C2RustUnnamed_15 = 351;
pub const ACTOR_EN_GANON_ORGAN: C2RustUnnamed_15 = 350;
pub const ACTOR_UNSET_15D: C2RustUnnamed_15 = 349;
pub const ACTOR_BG_SPOT18_BASKET: C2RustUnnamed_15 = 348;
pub const ACTOR_BG_JYA_BOMBIWA: C2RustUnnamed_15 = 347;
pub const ACTOR_BG_JYA_AMISHUTTER: C2RustUnnamed_15 = 346;
pub const ACTOR_BG_JYA_BOMBCHUIWA: C2RustUnnamed_15 = 345;
pub const ACTOR_BG_JYA_BIGMIRROR: C2RustUnnamed_15 = 344;
pub const ACTOR_BG_JYA_LIFT: C2RustUnnamed_15 = 343;
pub const ACTOR_BG_JYA_MEGAMI: C2RustUnnamed_15 = 342;
pub const ACTOR_EN_CHANGER: C2RustUnnamed_15 = 341;
pub const ACTOR_UNSET_154: C2RustUnnamed_15 = 340;
pub const ACTOR_EN_FU: C2RustUnnamed_15 = 339;
pub const ACTOR_EN_GO: C2RustUnnamed_15 = 338;
pub const ACTOR_OBJ_MURE2: C2RustUnnamed_15 = 337;
pub const ACTOR_OBJ_LIGHTSWITCH: C2RustUnnamed_15 = 336;
pub const ACTOR_OBJ_HANA: C2RustUnnamed_15 = 335;
pub const ACTOR_EN_ISHI: C2RustUnnamed_15 = 334;
pub const ACTOR_EN_OWL: C2RustUnnamed_15 = 333;
pub const ACTOR_EN_BOM_BOWL_PIT: C2RustUnnamed_15 = 332;
pub const ACTOR_EN_BOM_BOWL_MAN: C2RustUnnamed_15 = 331;
pub const ACTOR_EN_MK: C2RustUnnamed_15 = 330;
pub const ACTOR_EN_DS: C2RustUnnamed_15 = 329;
pub const ACTOR_BG_GJYO_BRIDGE: C2RustUnnamed_15 = 328;
pub const ACTOR_EN_WONDER_TALK: C2RustUnnamed_15 = 327;
pub const ACTOR_EN_SA: C2RustUnnamed_15 = 326;
pub const ACTOR_BG_SPOT01_IDOSOKO: C2RustUnnamed_15 = 325;
pub const ACTOR_EN_ATTACK_NIW: C2RustUnnamed_15 = 324;
pub const ACTOR_EN_SYATEKI_NIW: C2RustUnnamed_15 = 323;
pub const ACTOR_EN_HEISHI3: C2RustUnnamed_15 = 322;
pub const ACTOR_EN_KANBAN: C2RustUnnamed_15 = 321;
pub const ACTOR_BG_INGATE: C2RustUnnamed_15 = 320;
pub const ACTOR_EN_HS: C2RustUnnamed_15 = 319;
pub const ACTOR_EN_MS: C2RustUnnamed_15 = 318;
pub const ACTOR_EN_GM: C2RustUnnamed_15 = 317;
pub const ACTOR_EN_NIW_LADY: C2RustUnnamed_15 = 316;
pub const ACTOR_EN_CLEAR_TAG: C2RustUnnamed_15 = 315;
pub const ACTOR_EN_SDA: C2RustUnnamed_15 = 314;
pub const ACTOR_OBJ_BLOCKSTOP: C2RustUnnamed_15 = 313;
pub const ACTOR_EN_GE1: C2RustUnnamed_15 = 312;
pub const ACTOR_ITEM_INBOX: C2RustUnnamed_15 = 311;
pub const ACTOR_EN_BLKOBJ: C2RustUnnamed_15 = 310;
pub const ACTOR_EN_NWC: C2RustUnnamed_15 = 309;
pub const ACTOR_UNSET_134: C2RustUnnamed_15 = 308;
pub const ACTOR_EN_DAIKU: C2RustUnnamed_15 = 307;
pub const ACTOR_EN_TORYO: C2RustUnnamed_15 = 306;
pub const ACTOR_EN_EX_RUPPY: C2RustUnnamed_15 = 305;
pub const ACTOR_EN_GOROIWA: C2RustUnnamed_15 = 304;
pub const ACTOR_EN_YABUSAME_MARK: C2RustUnnamed_15 = 303;
pub const ACTOR_EN_OKARINA_TAG: C2RustUnnamed_15 = 302;
pub const ACTOR_OBJ_HSBLOCK: C2RustUnnamed_15 = 301;
pub const ACTOR_OBJ_LIFT: C2RustUnnamed_15 = 300;
pub const ACTOR_OBJ_ELEVATOR: C2RustUnnamed_15 = 299;
pub const ACTOR_OBJ_SWITCH: C2RustUnnamed_15 = 298;
pub const ACTOR_UNSET_129: C2RustUnnamed_15 = 297;
pub const ACTOR_UNSET_128: C2RustUnnamed_15 = 296;
pub const ACTOR_OBJ_BOMBIWA: C2RustUnnamed_15 = 295;
pub const ACTOR_OBJ_BEAN: C2RustUnnamed_15 = 294;
pub const ACTOR_EN_KUSA: C2RustUnnamed_15 = 293;
pub const ACTOR_EN_DIVING_GAME: C2RustUnnamed_15 = 292;
pub const ACTOR_BG_RELAY_OBJECTS: C2RustUnnamed_15 = 291;
pub const ACTOR_EN_PO_RELAY: C2RustUnnamed_15 = 290;
pub const ACTOR_EN_FZ: C2RustUnnamed_15 = 289;
pub const ACTOR_BG_SPOT07_TAKI: C2RustUnnamed_15 = 288;
pub const ACTOR_BG_SPOT03_TAKI: C2RustUnnamed_15 = 287;
pub const ACTOR_OBJ_ICE_POLY: C2RustUnnamed_15 = 286;
pub const ACTOR_EN_TUBO_TRAP: C2RustUnnamed_15 = 285;
pub const ACTOR_EN_HONOTRAP: C2RustUnnamed_15 = 284;
pub const ACTOR_ELF_MSG: C2RustUnnamed_15 = 283;
pub const ACTOR_EN_DNS: C2RustUnnamed_15 = 282;
pub const ACTOR_DEMO_SHD: C2RustUnnamed_15 = 281;
pub const ACTOR_DEMO_EXT: C2RustUnnamed_15 = 280;
pub const ACTOR_EN_G_SWITCH: C2RustUnnamed_15 = 279;
pub const ACTOR_EN_SKJNEEDLE: C2RustUnnamed_15 = 278;
pub const ACTOR_EN_SKJ: C2RustUnnamed_15 = 277;
pub const ACTOR_DEMO_IK: C2RustUnnamed_15 = 276;
pub const ACTOR_EN_IK: C2RustUnnamed_15 = 275;
pub const ACTOR_EN_WONDER_ITEM: C2RustUnnamed_15 = 274;
pub const ACTOR_OBJ_TSUBO: C2RustUnnamed_15 = 273;
pub const ACTOR_OBJ_KIBAKO: C2RustUnnamed_15 = 272;
pub const ACTOR_ITEM_ETCETERA: C2RustUnnamed_15 = 271;
pub const ACTOR_UNSET_10E: C2RustUnnamed_15 = 270;
pub const ACTOR_UNSET_10D: C2RustUnnamed_15 = 269;
pub const ACTOR_ARROW_LIGHT: C2RustUnnamed_15 = 268;
pub const ACTOR_ARROW_ICE: C2RustUnnamed_15 = 267;
pub const ACTOR_ARROW_FIRE: C2RustUnnamed_15 = 266;
pub const ACTOR_UNSET_109: C2RustUnnamed_15 = 265;
pub const ACTOR_BG_UMAJUMP: C2RustUnnamed_15 = 264;
pub const ACTOR_BG_SPOT15_RRBOX: C2RustUnnamed_15 = 263;
pub const ACTOR_BG_GANON_OTYUKA: C2RustUnnamed_15 = 262;
pub const ACTOR_BG_PO_SYOKUDAI: C2RustUnnamed_15 = 261;
pub const ACTOR_BG_SPOT01_IDOMIZU: C2RustUnnamed_15 = 260;
pub const ACTOR_BG_SPOT01_IDOHASHIRA: C2RustUnnamed_15 = 259;
pub const ACTOR_BG_SPOT01_FUSYA: C2RustUnnamed_15 = 258;
pub const ACTOR_EFF_DUST: C2RustUnnamed_15 = 257;
pub const ACTOR_BG_GATE_SHUTTER: C2RustUnnamed_15 = 256;
pub const ACTOR_OBJ_OSHIHIKI: C2RustUnnamed_15 = 255;
pub const ACTOR_FISHING: C2RustUnnamed_15 = 254;
pub const ACTOR_BG_JYA_KANAAMI: C2RustUnnamed_15 = 253;
pub const ACTOR_BG_JYA_COBRA: C2RustUnnamed_15 = 252;
pub const ACTOR_UNSET_FB: C2RustUnnamed_15 = 251;
pub const ACTOR_BG_JYA_ZURERUKABE: C2RustUnnamed_15 = 250;
pub const ACTOR_BG_JYA_GOROIWA: C2RustUnnamed_15 = 249;
pub const ACTOR_BG_SPOT15_SAKU: C2RustUnnamed_15 = 248;
pub const ACTOR_BG_HAKA_GATE: C2RustUnnamed_15 = 247;
pub const ACTOR_EN_ANUBICE_TAG: C2RustUnnamed_15 = 246;
pub const ACTOR_DEMO_6K: C2RustUnnamed_15 = 245;
pub const ACTOR_MAGIC_DARK: C2RustUnnamed_15 = 244;
pub const ACTOR_UNSET_F3: C2RustUnnamed_15 = 243;
pub const ACTOR_UNSET_F2: C2RustUnnamed_15 = 242;
pub const ACTOR_ITEM_OCARINA: C2RustUnnamed_15 = 241;
pub const ACTOR_EN_ICE_HONO: C2RustUnnamed_15 = 240;
pub const ACTOR_BG_ICE_SHELTER: C2RustUnnamed_15 = 239;
pub const ACTOR_ITEM_SHIELD: C2RustUnnamed_15 = 238;
pub const ACTOR_EN_FR: C2RustUnnamed_15 = 237;
pub const ACTOR_EN_NY: C2RustUnnamed_15 = 236;
pub const ACTOR_UNSET_EB: C2RustUnnamed_15 = 235;
pub const ACTOR_UNSET_EA: C2RustUnnamed_15 = 234;
pub const ACTOR_BOSS_SST: C2RustUnnamed_15 = 233;
pub const ACTOR_BOSS_GANON: C2RustUnnamed_15 = 232;
pub const ACTOR_EN_MA1: C2RustUnnamed_15 = 231;
pub const ACTOR_BG_BDAN_SWITCH: C2RustUnnamed_15 = 230;
pub const ACTOR_BG_SPOT16_DOUGHNUT: C2RustUnnamed_15 = 229;
pub const ACTOR_BG_MORI_IDOMIZU: C2RustUnnamed_15 = 228;
pub const ACTOR_BG_MORI_HASHIRA4: C2RustUnnamed_15 = 227;
pub const ACTOR_BG_MORI_HASHIGO: C2RustUnnamed_15 = 226;
pub const ACTOR_EN_ANUBICE_FIRE: C2RustUnnamed_15 = 225;
pub const ACTOR_EN_ANUBICE: C2RustUnnamed_15 = 224;
pub const ACTOR_EN_BX: C2RustUnnamed_15 = 223;
pub const ACTOR_EN_BA: C2RustUnnamed_15 = 222;
pub const ACTOR_EN_RR: C2RustUnnamed_15 = 221;
pub const ACTOR_BOSS_TW: C2RustUnnamed_15 = 220;
pub const ACTOR_EN_HORSE_GAME_CHECK: C2RustUnnamed_15 = 219;
pub const ACTOR_EN_BOM_CHU: C2RustUnnamed_15 = 218;
pub const ACTOR_EN_MA2: C2RustUnnamed_15 = 217;
pub const ACTOR_UNSET_D8: C2RustUnnamed_15 = 216;
pub const ACTOR_BG_HAKA_WATER: C2RustUnnamed_15 = 215;
pub const ACTOR_BG_ICE_OBJECTS: C2RustUnnamed_15 = 214;
pub const ACTOR_BG_SPOT06_OBJECTS: C2RustUnnamed_15 = 213;
pub const ACTOR_BG_MIZU_UZU: C2RustUnnamed_15 = 212;
pub const ACTOR_OBJ_DEKUJR: C2RustUnnamed_15 = 211;
pub const ACTOR_EN_RU2: C2RustUnnamed_15 = 210;
pub const ACTOR_BG_SPOT08_ICEBLOCK: C2RustUnnamed_15 = 209;
pub const ACTOR_BG_BOMBWALL: C2RustUnnamed_15 = 208;
pub const ACTOR_BG_HIDAN_KOWARERUKABE: C2RustUnnamed_15 = 207;
pub const ACTOR_UNSET_CE: C2RustUnnamed_15 = 206;
pub const ACTOR_BG_SPOT16_BOMBSTONE: C2RustUnnamed_15 = 205;
pub const ACTOR_EN_TR: C2RustUnnamed_15 = 204;
pub const ACTOR_EN_IN: C2RustUnnamed_15 = 203;
pub const ACTOR_DEMO_GO: C2RustUnnamed_15 = 202;
pub const ACTOR_DEMO_SA: C2RustUnnamed_15 = 201;
pub const ACTOR_BG_BDAN_OBJECTS: C2RustUnnamed_15 = 200;
pub const ACTOR_EN_KAREBABA: C2RustUnnamed_15 = 199;
pub const ACTOR_EN_BIGOKUTA: C2RustUnnamed_15 = 198;
pub const ACTOR_EN_SB: C2RustUnnamed_15 = 197;
pub const ACTOR_BOSS_MO: C2RustUnnamed_15 = 196;
pub const ACTOR_EN_NB: C2RustUnnamed_15 = 195;
pub const ACTOR_EN_TANA: C2RustUnnamed_15 = 194;
pub const ACTOR_EN_SYATEKI_MAN: C2RustUnnamed_15 = 193;
pub const ACTOR_EN_SYATEKI_ITM: C2RustUnnamed_15 = 192;
pub const ACTOR_BG_SPOT17_FUNEN: C2RustUnnamed_15 = 191;
pub const ACTOR_BG_HAKA_ZOU: C2RustUnnamed_15 = 190;
pub const ACTOR_BG_HAKA_HUTA: C2RustUnnamed_15 = 189;
pub const ACTOR_BG_HAKA_TRAP: C2RustUnnamed_15 = 188;
pub const ACTOR_BG_HAKA_TUBO: C2RustUnnamed_15 = 187;
pub const ACTOR_BOSS_VA: C2RustUnnamed_15 = 186;
pub const ACTOR_BG_SPOT18_OBJ: C2RustUnnamed_15 = 185;
pub const ACTOR_BG_SPOT09_OBJ: C2RustUnnamed_15 = 184;
pub const ACTOR_MIR_RAY: C2RustUnnamed_15 = 183;
pub const ACTOR_EN_BROB: C2RustUnnamed_15 = 182;
pub const ACTOR_EN_FIRE_ROCK: C2RustUnnamed_15 = 181;
pub const ACTOR_EN_ENCOUNT2: C2RustUnnamed_15 = 180;
pub const ACTOR_EN_HEISHI2: C2RustUnnamed_15 = 179;
pub const ACTOR_UNSET_B2: C2RustUnnamed_15 = 178;
pub const ACTOR_BG_HAKA_SGAMI: C2RustUnnamed_15 = 177;
pub const ACTOR_BG_HAKA_SHIP: C2RustUnnamed_15 = 176;
pub const ACTOR_BG_HAKA_MEGANEBG: C2RustUnnamed_15 = 175;
pub const ACTOR_BG_HAKA_MEGANE: C2RustUnnamed_15 = 174;
pub const ACTOR_EN_VB_BALL: C2RustUnnamed_15 = 173;
pub const ACTOR_BG_VB_SIMA: C2RustUnnamed_15 = 172;
pub const ACTOR_EN_FW: C2RustUnnamed_15 = 171;
pub const ACTOR_DEMO_TRE_LGT: C2RustUnnamed_15 = 170;
pub const ACTOR_DEMO_IM: C2RustUnnamed_15 = 169;
pub const ACTOR_DEMO_DU: C2RustUnnamed_15 = 168;
pub const ACTOR_EN_ENCOUNT1: C2RustUnnamed_15 = 167;
pub const ACTOR_EN_RL: C2RustUnnamed_15 = 166;
pub const ACTOR_EN_DHA: C2RustUnnamed_15 = 165;
pub const ACTOR_EN_DH: C2RustUnnamed_15 = 164;
pub const ACTOR_EN_FD_FIRE: C2RustUnnamed_15 = 163;
pub const ACTOR_BOSS_FD2: C2RustUnnamed_15 = 162;
pub const ACTOR_EN_RU1: C2RustUnnamed_15 = 161;
pub const ACTOR_UNSET_A0: C2RustUnnamed_15 = 160;
pub const ACTOR_MAGIC_FIRE: C2RustUnnamed_15 = 159;
pub const ACTOR_MAGIC_WIND: C2RustUnnamed_15 = 158;
pub const ACTOR_BG_HAKA: C2RustUnnamed_15 = 157;
pub const ACTOR_BG_SPOT02_OBJECTS: C2RustUnnamed_15 = 156;
pub const ACTOR_DOOR_ANA: C2RustUnnamed_15 = 155;
pub const ACTOR_EN_HORSE_LINK_CHILD: C2RustUnnamed_15 = 154;
pub const ACTOR_EN_FD: C2RustUnnamed_15 = 153;
pub const ACTOR_EN_DU: C2RustUnnamed_15 = 152;
pub const ACTOR_OBJECT_KANKYO: C2RustUnnamed_15 = 151;
pub const ACTOR_BOSS_FD: C2RustUnnamed_15 = 150;
pub const ACTOR_EN_SW: C2RustUnnamed_15 = 149;
pub const ACTOR_OBJ_MURE: C2RustUnnamed_15 = 148;
pub const ACTOR_BG_PO_EVENT: C2RustUnnamed_15 = 147;
pub const ACTOR_BG_HEAVY_BLOCK: C2RustUnnamed_15 = 146;
pub const ACTOR_EN_PO_SISTERS: C2RustUnnamed_15 = 145;
pub const ACTOR_EN_RD: C2RustUnnamed_15 = 144;
pub const ACTOR_EN_HEISHI1: C2RustUnnamed_15 = 143;
pub const ACTOR_EN_FLOORMAS: C2RustUnnamed_15 = 142;
pub const ACTOR_BG_HIDAN_FWBIG: C2RustUnnamed_15 = 141;
pub const ACTOR_DEMO_KANKYO: C2RustUnnamed_15 = 140;
pub const ACTOR_DEMO_EFFECT: C2RustUnnamed_15 = 139;
pub const ACTOR_EN_VM: C2RustUnnamed_15 = 138;
pub const ACTOR_BG_MORI_RAKKATENJO: C2RustUnnamed_15 = 137;
pub const ACTOR_BG_MORI_KAITENKABE: C2RustUnnamed_15 = 136;
pub const ACTOR_BG_MORI_ELEVATOR: C2RustUnnamed_15 = 135;
pub const ACTOR_BG_MORI_BIGST: C2RustUnnamed_15 = 134;
pub const ACTOR_EN_TK: C2RustUnnamed_15 = 133;
pub const ACTOR_EN_TA: C2RustUnnamed_15 = 132;
pub const ACTOR_UNSET_83: C2RustUnnamed_15 = 131;
pub const ACTOR_EN_VASE: C2RustUnnamed_15 = 130;
pub const ACTOR_EN_AROW_TRAP: C2RustUnnamed_15 = 129;
pub const ACTOR_EN_TRAP: C2RustUnnamed_15 = 128;
pub const ACTOR_UNSET_7F: C2RustUnnamed_15 = 127;
pub const ACTOR_UNSET_7E: C2RustUnnamed_15 = 126;
pub const ACTOR_EN_PU_BOX: C2RustUnnamed_15 = 125;
pub const ACTOR_EN_LIGHTBOX: C2RustUnnamed_15 = 124;
pub const ACTOR_UNSET_7B: C2RustUnnamed_15 = 123;
pub const ACTOR_UNSET_7A: C2RustUnnamed_15 = 122;
pub const ACTOR_UNSET_79: C2RustUnnamed_15 = 121;
pub const ACTOR_UNSET_78: C2RustUnnamed_15 = 120;
pub const ACTOR_EN_WOOD02: C2RustUnnamed_15 = 119;
pub const ACTOR_UNSET_76: C2RustUnnamed_15 = 118;
pub const ACTOR_UNSET_75: C2RustUnnamed_15 = 117;
pub const ACTOR_UNSET_74: C2RustUnnamed_15 = 116;
pub const ACTOR_UNSET_73: C2RustUnnamed_15 = 115;
pub const ACTOR_EN_BIRD: C2RustUnnamed_15 = 114;
pub const ACTOR_BG_HIDAN_HAMSTEP: C2RustUnnamed_15 = 113;
pub const ACTOR_DOOR_TOKI: C2RustUnnamed_15 = 112;
pub const ACTOR_BG_HIDAN_KOUSI: C2RustUnnamed_15 = 111;
pub const ACTOR_BG_MJIN: C2RustUnnamed_15 = 110;
pub const ACTOR_EN_FHG_FIRE: C2RustUnnamed_15 = 109;
pub const ACTOR_BG_TOKI_SWD: C2RustUnnamed_15 = 108;
pub const ACTOR_EN_YUKABYUN: C2RustUnnamed_15 = 107;
pub const ACTOR_BG_TOKI_HIKARI: C2RustUnnamed_15 = 106;
pub const ACTOR_EN_BB: C2RustUnnamed_15 = 105;
pub const ACTOR_BG_MORI_HINERI: C2RustUnnamed_15 = 104;
pub const ACTOR_EN_FHG: C2RustUnnamed_15 = 103;
pub const ACTOR_ARMS_HOOK: C2RustUnnamed_15 = 102;
pub const ACTOR_BG_MIZU_WATER: C2RustUnnamed_15 = 101;
pub const ACTOR_BG_MIZU_MOVEBG: C2RustUnnamed_15 = 100;
pub const ACTOR_EN_VALI: C2RustUnnamed_15 = 99;
pub const ACTOR_BG_MENKURI_EYE: C2RustUnnamed_15 = 98;
pub const ACTOR_BG_MENKURI_KAITEN: C2RustUnnamed_15 = 97;
pub const ACTOR_EN_DEKUNUTS: C2RustUnnamed_15 = 96;
pub const ACTOR_ITEM_B_HEART: C2RustUnnamed_15 = 95;
pub const ACTOR_OBJ_SYOKUDAI: C2RustUnnamed_15 = 94;
pub const ACTOR_DOOR_WARP1: C2RustUnnamed_15 = 93;
pub const ACTOR_BG_DDAN_KD: C2RustUnnamed_15 = 92;
pub const ACTOR_EN_HORSE_ZELDA: C2RustUnnamed_15 = 91;
pub const ACTOR_EN_JJ: C2RustUnnamed_15 = 90;
pub const ACTOR_BG_BREAKWALL: C2RustUnnamed_15 = 89;
pub const ACTOR_BG_DDAN_JD: C2RustUnnamed_15 = 88;
pub const ACTOR_EN_M_THUNDER: C2RustUnnamed_15 = 87;
pub const ACTOR_EN_M_FIRE1: C2RustUnnamed_15 = 86;
pub const ACTOR_EN_DEKUBABA: C2RustUnnamed_15 = 85;
pub const ACTOR_EN_AM: C2RustUnnamed_15 = 84;
pub const ACTOR_UNSET_53: C2RustUnnamed_15 = 83;
pub const ACTOR_BOSS_GANONDROF: C2RustUnnamed_15 = 82;
pub const ACTOR_BG_YDAN_MARUTA: C2RustUnnamed_15 = 81;
pub const ACTOR_BG_YDAN_HASI: C2RustUnnamed_15 = 80;
pub const ACTOR_EN_OE2: C2RustUnnamed_15 = 79;
pub const ACTOR_BG_HIDAN_FSLIFT: C2RustUnnamed_15 = 78;
pub const ACTOR_EN_ZL2: C2RustUnnamed_15 = 77;
pub const ACTOR_EN_BOMBF: C2RustUnnamed_15 = 76;
pub const ACTOR_EN_MB: C2RustUnnamed_15 = 75;
pub const ACTOR_BG_SPOT00_HANEBASI: C2RustUnnamed_15 = 74;
pub const ACTOR_BG_HIDAN_CURTAIN: C2RustUnnamed_15 = 73;
pub const ACTOR_EN_XC: C2RustUnnamed_15 = 72;
pub const ACTOR_BG_HIDAN_SYOKU: C2RustUnnamed_15 = 71;
pub const ACTOR_BG_HIDAN_SIMA: C2RustUnnamed_15 = 70;
pub const ACTOR_BG_HIDAN_SEKIZOU: C2RustUnnamed_15 = 69;
pub const ACTOR_BG_HIDAN_RSEKIZOU: C2RustUnnamed_15 = 68;
pub const ACTOR_BG_HIDAN_ROCK: C2RustUnnamed_15 = 67;
pub const ACTOR_EN_HORSE_GANON: C2RustUnnamed_15 = 66;
pub const ACTOR_BG_HIDAN_HROCK: C2RustUnnamed_15 = 65;
pub const ACTOR_BG_HIDAN_DALM: C2RustUnnamed_15 = 64;
pub const ACTOR_BG_DODOAGO: C2RustUnnamed_15 = 63;
pub const ACTOR_BG_TREEMOUTH: C2RustUnnamed_15 = 62;
pub const ACTOR_EN_OSSAN: C2RustUnnamed_15 = 61;
pub const ACTOR_EN_HORSE_NORMAL: C2RustUnnamed_15 = 60;
pub const ACTOR_EN_RIVER_SOUND: C2RustUnnamed_15 = 59;
pub const ACTOR_EN_EIYER: C2RustUnnamed_15 = 58;
pub const ACTOR_EN_A_OBJ: C2RustUnnamed_15 = 57;
pub const ACTOR_EN_BW: C2RustUnnamed_15 = 56;
pub const ACTOR_EN_ST: C2RustUnnamed_15 = 55;
pub const ACTOR_UNSET_36: C2RustUnnamed_15 = 54;
pub const ACTOR_EN_TP: C2RustUnnamed_15 = 53;
pub const ACTOR_EN_BILI: C2RustUnnamed_15 = 52;
pub const ACTOR_EN_TORCH2: C2RustUnnamed_15 = 51;
pub const ACTOR_EN_BOOM: C2RustUnnamed_15 = 50;
pub const ACTOR_UNSET_31: C2RustUnnamed_15 = 49;
pub const ACTOR_EN_BDFIRE: C2RustUnnamed_15 = 48;
pub const ACTOR_EN_DODOJR: C2RustUnnamed_15 = 47;
pub const ACTOR_DOOR_SHUTTER: C2RustUnnamed_15 = 46;
pub const ACTOR_EN_BUBBLE: C2RustUnnamed_15 = 45;
pub const ACTOR_BG_PUSHBOX: C2RustUnnamed_15 = 44;
pub const ACTOR_EN_GOMA: C2RustUnnamed_15 = 43;
pub const ACTOR_EN_VIEWER: C2RustUnnamed_15 = 42;
pub const ACTOR_EN_ZL1: C2RustUnnamed_15 = 41;
pub const ACTOR_BOSS_GOMA: C2RustUnnamed_15 = 40;
pub const ACTOR_BOSS_DODONGO: C2RustUnnamed_15 = 39;
pub const ACTOR_EN_HATA: C2RustUnnamed_15 = 38;
pub const ACTOR_EN_ZF: C2RustUnnamed_15 = 37;
pub const ACTOR_EN_SCENE_CHANGE: C2RustUnnamed_15 = 36;
pub const ACTOR_EN_HOLL: C2RustUnnamed_15 = 35;
pub const ACTOR_UNSET_22: C2RustUnnamed_15 = 34;
pub const ACTOR_EN_FISH: C2RustUnnamed_15 = 33;
pub const ACTOR_EN_INSECT: C2RustUnnamed_15 = 32;
pub const ACTOR_UNSET_1F: C2RustUnnamed_15 = 31;
pub const ACTOR_EN_BUTTE: C2RustUnnamed_15 = 30;
pub const ACTOR_EN_PEEHAT: C2RustUnnamed_15 = 29;
pub const ACTOR_EN_REEBA: C2RustUnnamed_15 = 28;
pub const ACTOR_EN_TITE: C2RustUnnamed_15 = 27;
pub const ACTOR_UNSET_1A: C2RustUnnamed_15 = 26;
pub const ACTOR_EN_NIW: C2RustUnnamed_15 = 25;
pub const ACTOR_EN_ELF: C2RustUnnamed_15 = 24;
pub const ACTOR_UNSET_17: C2RustUnnamed_15 = 23;
pub const ACTOR_EN_ARROW: C2RustUnnamed_15 = 22;
pub const ACTOR_EN_ITEM00: C2RustUnnamed_15 = 21;
pub const ACTOR_EN_HORSE: C2RustUnnamed_15 = 20;
pub const ACTOR_EN_FIREFLY: C2RustUnnamed_15 = 19;
pub const ACTOR_EN_DODONGO: C2RustUnnamed_15 = 18;
pub const ACTOR_EN_WALLMAS: C2RustUnnamed_15 = 17;
pub const ACTOR_EN_BOM: C2RustUnnamed_15 = 16;
pub const ACTOR_BG_YDAN_SP: C2RustUnnamed_15 = 15;
pub const ACTOR_EN_OKUTA: C2RustUnnamed_15 = 14;
pub const ACTOR_EN_POH: C2RustUnnamed_15 = 13;
pub const ACTOR_BG_HIDAN_FIREWALL: C2RustUnnamed_15 = 12;
pub const ACTOR_BG_DY_YOSEIZO: C2RustUnnamed_15 = 11;
pub const ACTOR_EN_BOX: C2RustUnnamed_15 = 10;
pub const ACTOR_EN_DOOR: C2RustUnnamed_15 = 9;
pub const ACTOR_EN_LIGHT: C2RustUnnamed_15 = 8;
pub const ACTOR_EN_PART: C2RustUnnamed_15 = 7;
pub const ACTOR_UNSET_6: C2RustUnnamed_15 = 6;
pub const ACTOR_UNSET_5: C2RustUnnamed_15 = 5;
pub const ACTOR_EN_GIRLA: C2RustUnnamed_15 = 4;
pub const ACTOR_UNSET_3: C2RustUnnamed_15 = 3;
pub const ACTOR_EN_TEST: C2RustUnnamed_15 = 2;
pub const ACTOR_UNSET_1: C2RustUnnamed_15 = 1;
pub const ACTOR_PLAYER: C2RustUnnamed_15 = 0;
pub type C2RustUnnamed_16 = libc::c_uint;
pub const PLAYER_BOOTS_MAX: C2RustUnnamed_16 = 6;
pub const PLAYER_BOOTS_NORMAL_CHILD: C2RustUnnamed_16 = 5;
pub const PLAYER_BOOTS_IRON_UNDERWATER: C2RustUnnamed_16 = 4;
pub const PLAYER_BOOTS_INDOOR: C2RustUnnamed_16 = 3;
pub const PLAYER_BOOTS_HOVER: C2RustUnnamed_16 = 2;
pub const PLAYER_BOOTS_IRON: C2RustUnnamed_16 = 1;
pub const PLAYER_BOOTS_NORMAL: C2RustUnnamed_16 = 0;
pub type C2RustUnnamed_17 = libc::c_uint;
pub const CS_STATE_UNSKIPPABLE_EXEC: C2RustUnnamed_17 = 4;
pub const CS_STATE_UNSKIPPABLE_INIT: C2RustUnnamed_17 = 3;
pub const CS_STATE_SKIPPABLE_EXEC: C2RustUnnamed_17 = 2;
pub const CS_STATE_SKIPPABLE_INIT: C2RustUnnamed_17 = 1;
pub const CS_STATE_IDLE: C2RustUnnamed_17 = 0;
pub type C2RustUnnamed_18 = libc::c_uint;
pub const CAM_SET_MAX: C2RustUnnamed_18 = 66;
pub const CAM_SET_NORMAL4: C2RustUnnamed_18 = 65;
pub const CAM_SET_PIVOT_FROM_SIDE: C2RustUnnamed_18 = 64;
pub const CAM_SET_DIRECTED_YAW: C2RustUnnamed_18 = 63;
pub const CAM_SET_DUNGEON2: C2RustUnnamed_18 = 62;
pub const CAM_SET_JABU_TENTACLE: C2RustUnnamed_18 = 61;
pub const CAM_SET_CS_C: C2RustUnnamed_18 = 60;
pub const CAM_SET_FISHING: C2RustUnnamed_18 = 59;
pub const CAM_SET_NORMAL2: C2RustUnnamed_18 = 58;
pub const CAM_SET_PIVOT_VERTICAL: C2RustUnnamed_18 = 57;
pub const CAM_SET_TURN_AROUND: C2RustUnnamed_18 = 56;
pub const CAM_SET_FIRE_BIRDS_EYE: C2RustUnnamed_18 = 55;
pub const CAM_SET_MEADOW_UNUSED: C2RustUnnamed_18 = 54;
pub const CAM_SET_MEADOW_BIRDS_EYE: C2RustUnnamed_18 = 53;
pub const CAM_SET_BIG_OCTO: C2RustUnnamed_18 = 52;
pub const CAM_SET_FOREST_DEFEAT_POE: C2RustUnnamed_18 = 51;
pub const CAM_SET_FOREST_UNUSED: C2RustUnnamed_18 = 50;
pub const CAM_SET_FIRE_STAIRCASE: C2RustUnnamed_18 = 49;
pub const CAM_SET_FIRE_PLATFORM: C2RustUnnamed_18 = 48;
pub const CAM_SET_SCENE_TRANSITION: C2RustUnnamed_18 = 47;
pub const CAM_SET_SCENE_UNUSED: C2RustUnnamed_18 = 46;
pub const CAM_SET_BEAN_LOST_WOODS: C2RustUnnamed_18 = 45;
pub const CAM_SET_BEAN_GENERIC: C2RustUnnamed_18 = 44;
pub const CAM_SET_CS_ATTENTION: C2RustUnnamed_18 = 43;
pub const CAM_SET_CS_3: C2RustUnnamed_18 = 42;
pub const CAM_SET_ITEM_UNUSED: C2RustUnnamed_18 = 41;
pub const CAM_SET_SLOW_CHEST_CS: C2RustUnnamed_18 = 40;
pub const CAM_SET_FOREST_BIRDS_EYE: C2RustUnnamed_18 = 39;
pub const CAM_SET_CS_TWISTED_HALLWAY: C2RustUnnamed_18 = 38;
pub const CAM_SET_CS_0: C2RustUnnamed_18 = 37;
pub const CAM_SET_PIVOT_WATER_SURFACE: C2RustUnnamed_18 = 36;
pub const CAM_SET_PIVOT_CORNER: C2RustUnnamed_18 = 35;
pub const CAM_SET_FREE2: C2RustUnnamed_18 = 34;
pub const CAM_SET_FREE0: C2RustUnnamed_18 = 33;
pub const CAM_SET_START1: C2RustUnnamed_18 = 32;
pub const CAM_SET_START0: C2RustUnnamed_18 = 31;
pub const CAM_SET_CRAWLSPACE: C2RustUnnamed_18 = 30;
pub const CAM_SET_DOORC: C2RustUnnamed_18 = 29;
pub const CAM_SET_DOOR0: C2RustUnnamed_18 = 28;
pub const CAM_SET_PREREND_SIDE_SCROLL: C2RustUnnamed_18 = 27;
pub const CAM_SET_PREREND_PIVET: C2RustUnnamed_18 = 26;
pub const CAM_SET_PREREND_FIXED: C2RustUnnamed_18 = 25;
pub const CAM_SET_PIVOT_IN_FRONT: C2RustUnnamed_18 = 24;
pub const CAM_SET_PIVOT_SHOP_BROWSING: C2RustUnnamed_18 = 23;
pub const CAM_SET_PIVOT_CRAWLSPACE: C2RustUnnamed_18 = 22;
pub const CAM_SET_CHU_BOWLING: C2RustUnnamed_18 = 21;
pub const CAM_SET_MARKET_BALCONY: C2RustUnnamed_18 = 20;
pub const CAM_SET_TOWER_UNUSED: C2RustUnnamed_18 = 19;
pub const CAM_SET_TOWER_CLIMB: C2RustUnnamed_18 = 18;
pub const CAM_SET_BOSS_GANON: C2RustUnnamed_18 = 17;
pub const CAM_SET_BOSS_GANONDORF: C2RustUnnamed_18 = 16;
pub const CAM_SET_BOSS_TWINROVA_FLOOR: C2RustUnnamed_18 = 15;
pub const CAM_SET_BOSS_TWINROVA_PLATFORM: C2RustUnnamed_18 = 14;
pub const CAM_SET_BOSS_MORPHA: C2RustUnnamed_18 = 13;
pub const CAM_SET_BOSS_BONGO: C2RustUnnamed_18 = 12;
pub const CAM_SET_BOSS_VOLVAGIA: C2RustUnnamed_18 = 11;
pub const CAM_SET_BOSS_PHANTOM_GANON: C2RustUnnamed_18 = 10;
pub const CAM_SET_BOSS_BARINADE: C2RustUnnamed_18 = 9;
pub const CAM_SET_BOSS_DODONGO: C2RustUnnamed_18 = 8;
pub const CAM_SET_BOSS_GOHMA: C2RustUnnamed_18 = 7;
pub const CAM_SET_HORSE: C2RustUnnamed_18 = 6;
pub const CAM_SET_NORMAL3: C2RustUnnamed_18 = 5;
pub const CAM_SET_DUNGEON1: C2RustUnnamed_18 = 4;
pub const CAM_SET_DUNGEON0: C2RustUnnamed_18 = 3;
pub const CAM_SET_NORMAL1: C2RustUnnamed_18 = 2;
pub const CAM_SET_NORMAL0: C2RustUnnamed_18 = 1;
pub const CAM_SET_NONE: C2RustUnnamed_18 = 0;
pub type C2RustUnnamed_19 = libc::c_uint;
pub const CAM_MODE_MAX: C2RustUnnamed_19 = 21;
pub const CAM_MODE_FOLLOWBOOMERANG: C2RustUnnamed_19 = 20;
pub const CAM_MODE_PUSHPULL: C2RustUnnamed_19 = 19;
pub const CAM_MODE_STILL: C2RustUnnamed_19 = 18;
pub const CAM_MODE_CHARGE: C2RustUnnamed_19 = 17;
pub const CAM_MODE_FREEFALL: C2RustUnnamed_19 = 16;
pub const CAM_MODE_HANGZ: C2RustUnnamed_19 = 15;
pub const CAM_MODE_HANG: C2RustUnnamed_19 = 14;
pub const CAM_MODE_JUMP: C2RustUnnamed_19 = 13;
pub const CAM_MODE_CLIMBZ: C2RustUnnamed_19 = 12;
pub const CAM_MODE_SLINGSHOT: C2RustUnnamed_19 = 11;
pub const CAM_MODE_BOOMERANG: C2RustUnnamed_19 = 10;
pub const CAM_MODE_HOOKSHOT: C2RustUnnamed_19 = 9;
pub const CAM_MODE_BOWARROWZ: C2RustUnnamed_19 = 8;
pub const CAM_MODE_BOWARROW: C2RustUnnamed_19 = 7;
pub const CAM_MODE_FIRSTPERSON: C2RustUnnamed_19 = 6;
pub const CAM_MODE_CLIMB: C2RustUnnamed_19 = 5;
pub const CAM_MODE_BATTLE: C2RustUnnamed_19 = 4;
pub const CAM_MODE_TALK: C2RustUnnamed_19 = 3;
pub const CAM_MODE_FOLLOWTARGET: C2RustUnnamed_19 = 2;
pub const CAM_MODE_TARGET: C2RustUnnamed_19 = 1;
pub const CAM_MODE_NORMAL: C2RustUnnamed_19 = 0;
pub type C2RustUnnamed_20 = libc::c_uint;
pub const CAM_FUNC_MAX: C2RustUnnamed_20 = 71;
pub const CAM_FUNC_SPEC9: C2RustUnnamed_20 = 70;
pub const CAM_FUNC_SPEC8: C2RustUnnamed_20 = 69;
pub const CAM_FUNC_SPEC7: C2RustUnnamed_20 = 68;
pub const CAM_FUNC_SPEC6: C2RustUnnamed_20 = 67;
pub const CAM_FUNC_SPEC5: C2RustUnnamed_20 = 66;
pub const CAM_FUNC_SPEC4: C2RustUnnamed_20 = 65;
pub const CAM_FUNC_SPEC3: C2RustUnnamed_20 = 64;
pub const CAM_FUNC_SPEC2: C2RustUnnamed_20 = 63;
pub const CAM_FUNC_SPEC1: C2RustUnnamed_20 = 62;
pub const CAM_FUNC_SPEC0: C2RustUnnamed_20 = 61;
pub const CAM_FUNC_DEMO9: C2RustUnnamed_20 = 60;
pub const CAM_FUNC_DEMO8: C2RustUnnamed_20 = 59;
pub const CAM_FUNC_DEMO7: C2RustUnnamed_20 = 58;
pub const CAM_FUNC_DEMO6: C2RustUnnamed_20 = 57;
pub const CAM_FUNC_DEMO5: C2RustUnnamed_20 = 56;
pub const CAM_FUNC_DEMO4: C2RustUnnamed_20 = 55;
pub const CAM_FUNC_DEMO3: C2RustUnnamed_20 = 54;
pub const CAM_FUNC_DEMO2: C2RustUnnamed_20 = 53;
pub const CAM_FUNC_DEMO1: C2RustUnnamed_20 = 52;
pub const CAM_FUNC_DEMO0: C2RustUnnamed_20 = 51;
pub const CAM_FUNC_UNIQ9: C2RustUnnamed_20 = 50;
pub const CAM_FUNC_UNIQ8: C2RustUnnamed_20 = 49;
pub const CAM_FUNC_UNIQ7: C2RustUnnamed_20 = 48;
pub const CAM_FUNC_UNIQ6: C2RustUnnamed_20 = 47;
pub const CAM_FUNC_UNIQ5: C2RustUnnamed_20 = 46;
pub const CAM_FUNC_UNIQ4: C2RustUnnamed_20 = 45;
pub const CAM_FUNC_UNIQ3: C2RustUnnamed_20 = 44;
pub const CAM_FUNC_UNIQ2: C2RustUnnamed_20 = 43;
pub const CAM_FUNC_UNIQ1: C2RustUnnamed_20 = 42;
pub const CAM_FUNC_UNIQ0: C2RustUnnamed_20 = 41;
pub const CAM_FUNC_DATA4: C2RustUnnamed_20 = 40;
pub const CAM_FUNC_DATA3: C2RustUnnamed_20 = 39;
pub const CAM_FUNC_DATA2: C2RustUnnamed_20 = 38;
pub const CAM_FUNC_DATA1: C2RustUnnamed_20 = 37;
pub const CAM_FUNC_DATA0: C2RustUnnamed_20 = 36;
pub const CAM_FUNC_FIXD4: C2RustUnnamed_20 = 35;
pub const CAM_FUNC_FIXD3: C2RustUnnamed_20 = 34;
pub const CAM_FUNC_FIXD2: C2RustUnnamed_20 = 33;
pub const CAM_FUNC_FIXD1: C2RustUnnamed_20 = 32;
pub const CAM_FUNC_FIXD0: C2RustUnnamed_20 = 31;
pub const CAM_FUNC_BATT4: C2RustUnnamed_20 = 30;
pub const CAM_FUNC_BATT3: C2RustUnnamed_20 = 29;
pub const CAM_FUNC_BATT2: C2RustUnnamed_20 = 28;
pub const CAM_FUNC_BATT1: C2RustUnnamed_20 = 27;
pub const CAM_FUNC_BATT0: C2RustUnnamed_20 = 26;
pub const CAM_FUNC_JUMP4: C2RustUnnamed_20 = 25;
pub const CAM_FUNC_JUMP3: C2RustUnnamed_20 = 24;
pub const CAM_FUNC_JUMP2: C2RustUnnamed_20 = 23;
pub const CAM_FUNC_JUMP1: C2RustUnnamed_20 = 22;
pub const CAM_FUNC_JUMP0: C2RustUnnamed_20 = 21;
pub const CAM_FUNC_SUBJ4: C2RustUnnamed_20 = 20;
pub const CAM_FUNC_SUBJ3: C2RustUnnamed_20 = 19;
pub const CAM_FUNC_SUBJ2: C2RustUnnamed_20 = 18;
pub const CAM_FUNC_SUBJ1: C2RustUnnamed_20 = 17;
pub const CAM_FUNC_SUBJ0: C2RustUnnamed_20 = 16;
pub const CAM_FUNC_KEEP4: C2RustUnnamed_20 = 15;
pub const CAM_FUNC_KEEP3: C2RustUnnamed_20 = 14;
pub const CAM_FUNC_KEEP2: C2RustUnnamed_20 = 13;
pub const CAM_FUNC_KEEP1: C2RustUnnamed_20 = 12;
pub const CAM_FUNC_KEEP0: C2RustUnnamed_20 = 11;
pub const CAM_FUNC_PARA4: C2RustUnnamed_20 = 10;
pub const CAM_FUNC_PARA3: C2RustUnnamed_20 = 9;
pub const CAM_FUNC_PARA2: C2RustUnnamed_20 = 8;
pub const CAM_FUNC_PARA1: C2RustUnnamed_20 = 7;
pub const CAM_FUNC_PARA0: C2RustUnnamed_20 = 6;
pub const CAM_FUNC_NORM4: C2RustUnnamed_20 = 5;
pub const CAM_FUNC_NORM3: C2RustUnnamed_20 = 4;
pub const CAM_FUNC_NORM2: C2RustUnnamed_20 = 3;
pub const CAM_FUNC_NORM1: C2RustUnnamed_20 = 2;
pub const CAM_FUNC_NORM0: C2RustUnnamed_20 = 1;
pub const CAM_FUNC_NONE: C2RustUnnamed_20 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SwingAnimation {
    pub collisionClosePoint: Vec3f,
    pub atEyePoly: *mut CollisionPoly,
    pub swingUpdateRate: f32_0,
    pub unk_14: s16,
    pub unk_16: s16,
    pub unk_18: s16,
    pub swingUpdateRateTimer: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Normal1Anim {
    pub swing: SwingAnimation,
    pub yOffset: f32_0,
    pub unk_20: f32_0,
    pub slopePitchAdj: s16,
    pub swingYawTarget: s16,
    pub unk_28: s16,
    pub startSwingTimer: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Normal1 {
    pub yOffset: f32_0,
    pub distMin: f32_0,
    pub distMax: f32_0,
    pub unk_0C: f32_0,
    pub unk_10: f32_0,
    pub unk_14: f32_0,
    pub fovTarget: f32_0,
    pub atLERPScaleMax: f32_0,
    pub pitchTarget: s16,
    pub interfaceFlags: s16,
    pub anim: Normal1Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Normal2Anim {
    pub unk_00: Vec3f,
    pub unk_0C: Vec3f,
    pub unk_18: f32_0,
    pub unk_1C: f32_0,
    pub unk_20: s16,
    pub unk_22: s16,
    pub unk_24: f32_0,
    pub unk_28: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Normal2 {
    pub unk_00: f32_0,
    pub unk_04: f32_0,
    pub unk_08: f32_0,
    pub unk_0C: f32_0,
    pub unk_10: f32_0,
    pub unk_14: f32_0,
    pub unk_18: f32_0,
    pub unk_1C: s16,
    pub interfaceFlags: s16,
    pub anim: Normal2Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Normal3Anim {
    pub swing: SwingAnimation,
    pub unk_1C: f32_0,
    pub unk_20: f32_0,
    pub curPitch: s16,
    pub yawUpdAmt: s16,
    pub yawTimer: s16,
    pub distTimer: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Normal3 {
    pub yOffset: f32_0,
    pub distMin: f32_0,
    pub distMax: f32_0,
    pub yawUpdateSpeed: f32_0,
    pub unk_10: f32_0,
    pub fovTarget: f32_0,
    pub maxAtLERPScale: f32_0,
    pub pitchTarget: s16,
    pub interfaceFlags: s16,
    pub anim: Normal3Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Parallel1Anim {
    pub unk_00: Vec3f,
    pub yTarget: f32_0,
    pub unk_10: s16,
    pub yawTarget: s16,
    pub pitchTarget: s16,
    pub unk_16: s16,
    pub animTimer: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Parallel1 {
    pub unk_00: f32_0,
    pub distTarget: f32_0,
    pub unk_08: f32_0,
    pub unk_0C: f32_0,
    pub fovTarget: f32_0,
    pub unk_14: f32_0,
    pub unk_18: f32_0,
    pub unk_1C: f32_0,
    pub pitchTarget: s16,
    pub yawTarget: s16,
    pub interfaceFlags: s16,
    pub anim: Parallel1Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Jump1Anim {
    pub swing: SwingAnimation,
    pub unk_1C: f32_0,
    pub unk_20: VecSph,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Jump1 {
    pub atYOffset: f32_0,
    pub distMin: f32_0,
    pub distMax: f32_0,
    pub yawUpateRateTarget: f32_0,
    pub maxYawUpdate: f32_0,
    pub unk_14: f32_0,
    pub atLERPScaleMax: f32_0,
    pub interfaceFlags: s16,
    pub anim: Jump1Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Jump2Anim {
    pub floorY: f32_0,
    pub yawTarget: s16,
    pub initYawDiff: s16,
    pub yawAdj: s16,
    pub onFloor: s16,
    pub animTimer: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Jump2 {
    pub atYOffset: f32_0,
    pub minDist: f32_0,
    pub maxDist: f32_0,
    pub minMaxDistFactor: f32_0,
    pub yawUpdRateTarget: f32_0,
    pub xzUpdRateTarget: f32_0,
    pub fovTarget: f32_0,
    pub atLERPStepScale: f32_0,
    pub interfaceFlags: s16,
    pub anim: Jump2Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Jump3Anim {
    pub swing: SwingAnimation,
    pub unk_1C: f32_0,
    pub animTimer: s16,
    pub mode: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Jump3 {
    pub yOffset: f32_0,
    pub distMin: f32_0,
    pub distMax: f32_0,
    pub swingUpdateRate: f32_0,
    pub unk_10: f32_0,
    pub unk_14: f32_0,
    pub fovTarget: f32_0,
    pub unk_1C: f32_0,
    pub pitchTarget: s16,
    pub interfaceFlags: s16,
    pub anim: Jump3Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Battle1Anim {
    pub initialEyeToAtDist: f32_0,
    pub roll: f32_0,
    pub yPosOffset: f32_0,
    pub target: *mut Actor,
    pub unk_10: f32_0,
    pub unk_14: s16,
    pub initialEyeToAtYaw: s16,
    pub initialEyeToAtPitch: s16,
    pub animTimer: s16,
    pub chargeTimer: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Battle1 {
    pub yOffset: f32_0,
    pub distance: f32_0,
    pub swingYawInitial: f32_0,
    pub swingYawFinal: f32_0,
    pub swingPitchInitial: f32_0,
    pub swingPitchFinal: f32_0,
    pub swingPitchAdj: f32_0,
    pub fov: f32_0,
    pub atLERPScaleOnGround: f32_0,
    pub yOffsetOffGround: f32_0,
    pub atLERPScaleOffGround: f32_0,
    pub flags: s16,
    pub anim: Battle1Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Battle4Anim {
    pub animTimer: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Battle4 {
    pub yOffset: f32_0,
    pub rTarget: f32_0,
    pub pitchTarget: s16,
    pub lerpUpdateRate: f32_0,
    pub fovTarget: f32_0,
    pub atLERPTarget: f32_0,
    pub interfaceFlags: s16,
    pub unk_1A: s16,
    pub anim: Battle4Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Keep1Anim {
    pub unk_00: f32_0,
    pub unk_04: f32_0,
    pub unk_08: f32_0,
    pub unk_0C: *mut Actor,
    pub unk_10: s16,
    pub unk_12: s16,
    pub unk_14: s16,
    pub unk_16: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct KeepOn1 {
    pub unk_00: f32_0,
    pub unk_04: f32_0,
    pub unk_08: f32_0,
    pub unk_0C: f32_0,
    pub unk_10: f32_0,
    pub unk_14: f32_0,
    pub unk_18: f32_0,
    pub unk_1C: f32_0,
    pub unk_20: f32_0,
    pub unk_24: f32_0,
    pub unk_28: f32_0,
    pub unk_2C: f32_0,
    pub interfaceFlags: s16,
    pub anim: Keep1Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Keep3Anim {
    pub eyeToAtTarget: Vec3f,
    pub target: *mut Actor,
    pub atTarget: Vec3f,
    pub animTimer: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct KeepOn3 {
    pub yOffset: f32_0,
    pub minDist: f32_0,
    pub maxDist: f32_0,
    pub swingYawInital: f32_0,
    pub swingYawFinal: f32_0,
    pub swingPitchInitial: f32_0,
    pub swingPitchFinal: f32_0,
    pub swingPitchAdj: f32_0,
    pub fovTarget: f32_0,
    pub atLERPScaleMax: f32_0,
    pub initTimer: s16,
    pub flags: s16,
    pub anim: Keep3Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct KeepOn4_Unk20 {
    pub unk_00: f32_0,
    pub unk_04: f32_0,
    pub unk_08: f32_0,
    pub unk_0C: s16,
    pub unk_0E: s16,
    pub unk_10: s16,
    pub unk_12: s16,
    pub unk_14: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct KeepOn4 {
    pub unk_00: f32_0,
    pub unk_04: f32_0,
    pub unk_08: f32_0,
    pub unk_0C: f32_0,
    pub unk_10: f32_0,
    pub unk_14: f32_0,
    pub unk_18: f32_0,
    pub unk_1C: s16,
    pub unk_1E: s16,
    pub unk_20: KeepOn4_Unk20,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct KeepOn0Anim {
    pub fovTarget: f32_0,
    pub animTimer: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct KeepOn0 {
    pub fovScale: f32_0,
    pub yawScale: f32_0,
    pub timerInit: s16,
    pub interfaceFlags: s16,
    pub anim: KeepOn0Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Fixed1Anim {
    pub eyePosRotTarget: PosRot,
    pub fov: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Fixed1 {
    pub unk_00: f32_0,
    pub lerpStep: f32_0,
    pub fov: f32_0,
    pub interfaceFlags: s16,
    pub anim: Fixed1Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Fixed2InitParams {
    pub eye: Vec3f,
    pub fov: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Fixed2 {
    pub yOffset: f32_0,
    pub eyeStepScale: f32_0,
    pub posStepScale: f32_0,
    pub fov: f32_0,
    pub interfaceFlags: s16,
    pub initParams: Fixed2InitParams,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Fixed3Anim {
    pub rot: Vec3s,
    pub fov: s16,
    pub updDirTimer: s16,
    pub jfifId: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Fixed3 {
    pub interfaceFlags: s16,
    pub anim: Fixed3Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Fixed4Anim {
    pub eyeTarget: Vec3f,
    pub followSpeed: f32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Fixed4 {
    pub yOffset: f32_0,
    pub speedToEyePos: f32_0,
    pub followSpeed: f32_0,
    pub fov: f32_0,
    pub interfaceFlags: s16,
    pub anim: Fixed4Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Subj3Anim {
    pub r: f32_0,
    pub yaw: s16,
    pub pitch: s16,
    pub animTimer: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Subj3 {
    pub eyeNextYOffset: f32_0,
    pub eyeDist: f32_0,
    pub eyeNextDist: f32_0,
    pub unk_0C: f32_0,
    pub atOffset: Vec3f,
    pub fovTarget: f32_0,
    pub interfaceFlags: s16,
    pub anim: Subj3Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Subj4Anim {
    pub unk_00: Linef,
    pub unk_18: f32_0,
    pub unk_1C: f32_0,
    pub unk_20: f32_0,
    pub unk_24: f32_0,
    pub unk_28: f32_0,
    pub unk_2C: s16,
    pub unk_2E: s16,
    pub unk_30: s16,
    pub unk_32: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Subj4 {
    pub interfaceFlags: s16,
    pub anim: Subj4Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Data4InitParams {
    pub eyePosRot: PosRot,
    pub unk_14: [libc::c_char; 8],
    pub fov: s16,
    pub jfifId: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Data4 {
    pub yOffset: f32_0,
    pub fov: f32_0,
    pub interfaceFlags: s16,
    pub initParams: Data4InitParams,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Unique1Anim {
    pub unk_00: f32_0,
    pub yawTarget: s16,
    pub yawTargetAdj: s16,
    pub timer: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Unique1 {
    pub yOffset: f32_0,
    pub distMin: f32_0,
    pub distMax: f32_0,
    pub unk_0C: [libc::c_char; 4],
    pub fovTarget: f32_0,
    pub atLERPScaleMax: f32_0,
    pub pitchTarget: s16,
    pub interfaceFlags: s16,
    pub anim: Unique1Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Unique2Unk10 {
    pub unk_00: f32_0,
    pub unk_04: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Unique2 {
    pub yOffset: f32_0,
    pub distTarget: f32_0,
    pub fovTarget: f32_0,
    pub interfaceFlags: s16,
    pub unk_10: Unique2Unk10,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Unique3Anim {
    pub initialFov: f32_0,
    pub initialDist: f32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Unique3Params {
    pub yOffset: f32_0,
    pub fov: f32_0,
    pub interfaceFlags: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DoorParams {
    pub doorActor: *mut Actor,
    pub camDataIdx: s16,
    pub timer1: s16,
    pub timer2: s16,
    pub timer3: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Unique3 {
    pub doorParams: DoorParams,
    pub params: Unique3Params,
    pub anim: Unique3Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Unique0Anim {
    pub initalPos: Vec3f,
    pub animTimer: s16,
    pub sceneCamPosPlayerLine: Linef,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Unique0Params {
    pub interfaceFlags: s16,
    pub anim: Unique0Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Unique0 {
    pub doorParams: DoorParams,
    pub uniq0: Unique0Params,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Unique6 {
    pub interfaceFlags: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union Unique7Unk8 {
    pub unk_00: Vec3s,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Unique7 {
    pub fov: f32_0,
    pub interfaceFlags: s16,
    pub align: s16,
    pub unk_08: Unique7Unk8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OnePointCsFull {
    pub actionFlags: u8_0,
    pub unk_01: u8_0,
    pub initFlags: s16,
    pub timerInit: s16,
    pub rollTargetInit: s16,
    pub fovTargetInit: f32_0,
    pub lerpStepScale: f32_0,
    pub atTargetInit: Vec3f,
    pub eyeTargetInit: Vec3f,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Unique9Anim {
    pub curKeyFrame: *mut OnePointCsFull,
    pub atTarget: Vec3f,
    pub eyeTarget: Vec3f,
    pub playerPos: Vec3f,
    pub fovTarget: f32_0,
    pub atEyeOffsetTarget: VecSph,
    pub rollTarget: s16,
    pub curKeyFrameIdx: s16,
    pub unk_38: s16,
    pub isNewKeyFrame: s16,
    pub keyFrameTimer: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Unique9 {
    pub interfaceFlags: s16,
    pub anim: Unique9Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Unique9OnePointCs {
    pub keyFrameCnt: s32,
    pub keyFrames: *mut OnePointCsFull,
    pub uniq9: Unique9,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Demo1Anim {
    pub curFrame: f32_0,
    pub keyframe: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Demo1 {
    pub interfaceFlags: s16,
    pub anim: Demo1Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Demo3Anim {
    pub initialAt: Vec3f,
    pub unk_0C: f32_0,
    pub animFrame: s16,
    pub yawDir: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Demo3 {
    pub fov: f32_0,
    pub unk_04: f32_0,
    pub interfaceFlags: s16,
    pub anim: Demo3Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Demo6Anim {
    pub animTimer: s16,
    pub atTarget: Vec3f,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Demo6 {
    pub interfaceFlags: s16,
    pub unk_02: s16,
    pub anim: Demo6Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Demo9Anim {
    pub curFrame: f32_0,
    pub keyframe: s16,
    pub doLERPAt: s16,
    pub finishAction: s16,
    pub animTimer: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Demo9 {
    pub interfaceFlags: s16,
    pub anim: Demo9Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct OnePointCsCamera {
    pub atPoints: *mut CutsceneCameraPoint,
    pub eyePoints: *mut CutsceneCameraPoint,
    pub actionParameters: s16,
    pub initTimer: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Demo9OnePointCs {
    pub onePointCs: OnePointCsCamera,
    pub demo9: Demo9,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Special0 {
    pub lerpAtScale: f32_0,
    pub interfaceFlags: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Special4 {
    pub initalTimer: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Special5Anim {
    pub animTimer: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Special5 {
    pub yOffset: f32_0,
    pub eyeDist: f32_0,
    pub minDistForRot: f32_0,
    pub fovTarget: f32_0,
    pub atMaxLERPScale: f32_0,
    pub timerInit: s16,
    pub pitch: s16,
    pub interfaceFlags: s16,
    pub unk_1A: s16,
    pub anim: Special5Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Special7 {
    pub idx: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Special6Anim {
    pub initalPlayerY: f32_0,
    pub animTimer: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Special6 {
    pub interfaceFlags: s16,
    pub anim: Special6Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Special9Anim {
    pub targetYaw: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Special9Params {
    pub yOffset: f32_0,
    pub unk_04: f32_0,
    pub interfaceFlags: s16,
    pub unk_0A: s16,
    pub anim: Special9Anim,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Special9 {
    pub doorParams: DoorParams,
    pub params: Special9Params,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CamColChk {
    pub pos: Vec3f,
    pub norm: Vec3f,
    pub poly: *mut CollisionPoly,
    pub sphNorm: VecSph,
    pub bgId: s32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DbCameraSub {
    pub mode: s16,
    pub nFrames: s16,
    pub nPoints: s16,
    pub unkIdx: s16,
    pub unk_08: s16,
    pub unk_0A: s16,
    pub unk_0C: s32,
    pub unk_10: [libc::c_char; 20],
    pub position: [CutsceneCameraPoint; 129],
    pub lookAt: [CutsceneCameraPoint; 129],
    pub demoCtrlMenu: s16,
    pub demoCtrlActionIdx: s16,
    pub demoCtrlToggleSwitch: s16,
    pub unk_104A: Vec3s,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DbCamera {
    pub unk_00: s32,
    pub at: Vec3f,
    pub eye: Vec3f,
    pub unk_1C: Vec3f,
    pub unk_28: [libc::c_char; 12],
    pub unk_34: s32,
    pub unk_38: s32,
    pub unk_3C: s32,
    pub unk_40: s32,
    pub unk_44: s32,
    pub fov: f32_0,
    pub roll: s16,
    pub unk_4E: [libc::c_char; 2],
    pub rollDegrees: f32_0,
    pub unk_54: Vec3f,
    pub unk_60: Vec3f,
    pub unk_6C: Vec3f,
    pub unk_78: s16,
    pub unk_7A: s16,
    pub sub: DbCameraSub,
}
pub type C2RustUnnamed_21 = libc::c_uint;
pub const SCENE_ID_MAX: C2RustUnnamed_21 = 110;
pub const SCENE_TESTROOM: C2RustUnnamed_21 = 109;
pub const SCENE_SASATEST: C2RustUnnamed_21 = 108;
pub const SCENE_HAIRAL_NIWA2: C2RustUnnamed_21 = 107;
pub const SCENE_SUTARU: C2RustUnnamed_21 = 106;
pub const SCENE_SYOTES2: C2RustUnnamed_21 = 105;
pub const SCENE_SYOTES: C2RustUnnamed_21 = 104;
pub const SCENE_DEPTH_TEST: C2RustUnnamed_21 = 103;
pub const SCENE_BESITU: C2RustUnnamed_21 = 102;
pub const SCENE_TEST01: C2RustUnnamed_21 = 101;
pub const SCENE_GANON_TOU: C2RustUnnamed_21 = 100;
pub const SCENE_SPOT20: C2RustUnnamed_21 = 99;
pub const SCENE_SPOT18: C2RustUnnamed_21 = 98;
pub const SCENE_SPOT17: C2RustUnnamed_21 = 97;
pub const SCENE_SPOT16: C2RustUnnamed_21 = 96;
pub const SCENE_SPOT15: C2RustUnnamed_21 = 95;
pub const SCENE_SPOT13: C2RustUnnamed_21 = 94;
pub const SCENE_SPOT12: C2RustUnnamed_21 = 93;
pub const SCENE_SPOT11: C2RustUnnamed_21 = 92;
pub const SCENE_SPOT10: C2RustUnnamed_21 = 91;
pub const SCENE_SPOT09: C2RustUnnamed_21 = 90;
pub const SCENE_SPOT08: C2RustUnnamed_21 = 89;
pub const SCENE_SPOT07: C2RustUnnamed_21 = 88;
pub const SCENE_SPOT06: C2RustUnnamed_21 = 87;
pub const SCENE_SPOT05: C2RustUnnamed_21 = 86;
pub const SCENE_SPOT04: C2RustUnnamed_21 = 85;
pub const SCENE_SPOT03: C2RustUnnamed_21 = 84;
pub const SCENE_SPOT02: C2RustUnnamed_21 = 83;
pub const SCENE_SPOT01: C2RustUnnamed_21 = 82;
pub const SCENE_SPOT00: C2RustUnnamed_21 = 81;
pub const SCENE_KINSUTA: C2RustUnnamed_21 = 80;
pub const SCENE_GANON_DEMO: C2RustUnnamed_21 = 79;
pub const SCENE_MAHOUYA: C2RustUnnamed_21 = 78;
pub const SCENE_MIHARIGOYA: C2RustUnnamed_21 = 77;
pub const SCENE_SOUKO: C2RustUnnamed_21 = 76;
pub const SCENE_BOWLING: C2RustUnnamed_21 = 75;
pub const SCENE_NAKANIWA: C2RustUnnamed_21 = 74;
pub const SCENE_TURIBORI: C2RustUnnamed_21 = 73;
pub const SCENE_HAKASITARELAY: C2RustUnnamed_21 = 72;
pub const SCENE_HIRAL_DEMO: C2RustUnnamed_21 = 71;
pub const SCENE_HAIRAL_NIWA_N: C2RustUnnamed_21 = 70;
pub const SCENE_HAIRAL_NIWA: C2RustUnnamed_21 = 69;
pub const SCENE_KENJYANOMA: C2RustUnnamed_21 = 68;
pub const SCENE_TOKINOMA: C2RustUnnamed_21 = 67;
pub const SCENE_SYATEKIJYOU: C2RustUnnamed_21 = 66;
pub const SCENE_HAKAANA_OUKE: C2RustUnnamed_21 = 65;
pub const SCENE_HAKAANA2: C2RustUnnamed_21 = 64;
pub const SCENE_HAKAANA: C2RustUnnamed_21 = 63;
pub const SCENE_KAKUSIANA: C2RustUnnamed_21 = 62;
pub const SCENE_YOUSEI_IZUMI_YOKO: C2RustUnnamed_21 = 61;
pub const SCENE_YOUSEI_IZUMI_TATE: C2RustUnnamed_21 = 60;
pub const SCENE_DAIYOUSEI_IZUMI: C2RustUnnamed_21 = 59;
pub const SCENE_HUT: C2RustUnnamed_21 = 58;
pub const SCENE_TENT: C2RustUnnamed_21 = 57;
pub const SCENE_HYLIA_LABO: C2RustUnnamed_21 = 56;
pub const SCENE_LABO: C2RustUnnamed_21 = 55;
pub const SCENE_MALON_STABLE: C2RustUnnamed_21 = 54;
pub const SCENE_IMPA: C2RustUnnamed_21 = 53;
pub const SCENE_LINK_HOME: C2RustUnnamed_21 = 52;
pub const SCENE_FACE_SHOP: C2RustUnnamed_21 = 51;
pub const SCENE_NIGHT_SHOP: C2RustUnnamed_21 = 50;
pub const SCENE_ALLEY_SHOP: C2RustUnnamed_21 = 49;
pub const SCENE_DRAG: C2RustUnnamed_21 = 48;
pub const SCENE_ZOORA: C2RustUnnamed_21 = 47;
pub const SCENE_GOLON: C2RustUnnamed_21 = 46;
pub const SCENE_KOKIRI_SHOP: C2RustUnnamed_21 = 45;
pub const SCENE_SHOP1: C2RustUnnamed_21 = 44;
pub const SCENE_KAKARIKO3: C2RustUnnamed_21 = 43;
pub const SCENE_KAKARIKO: C2RustUnnamed_21 = 42;
pub const SCENE_KOKIRI_HOME5: C2RustUnnamed_21 = 41;
pub const SCENE_KOKIRI_HOME4: C2RustUnnamed_21 = 40;
pub const SCENE_KOKIRI_HOME3: C2RustUnnamed_21 = 39;
pub const SCENE_KOKIRI_HOME: C2RustUnnamed_21 = 38;
pub const SCENE_SHRINE_R: C2RustUnnamed_21 = 37;
pub const SCENE_SHRINE_N: C2RustUnnamed_21 = 36;
pub const SCENE_SHRINE: C2RustUnnamed_21 = 35;
pub const SCENE_MARKET_RUINS: C2RustUnnamed_21 = 34;
pub const SCENE_MARKET_NIGHT: C2RustUnnamed_21 = 33;
pub const SCENE_MARKET_DAY: C2RustUnnamed_21 = 32;
pub const SCENE_MARKET_ALLEY_N: C2RustUnnamed_21 = 31;
pub const SCENE_MARKET_ALLEY: C2RustUnnamed_21 = 30;
pub const SCENE_ENRUI: C2RustUnnamed_21 = 29;
pub const SCENE_ENTRA_N: C2RustUnnamed_21 = 28;
pub const SCENE_ENTRA: C2RustUnnamed_21 = 27;
pub const SCENE_GANON_FINAL: C2RustUnnamed_21 = 26;
pub const SCENE_GANON_BOSS: C2RustUnnamed_21 = 25;
pub const SCENE_HAKADAN_BS: C2RustUnnamed_21 = 24;
pub const SCENE_JYASINBOSS: C2RustUnnamed_21 = 23;
pub const SCENE_MIZUSIN_BS: C2RustUnnamed_21 = 22;
pub const SCENE_FIRE_BS: C2RustUnnamed_21 = 21;
pub const SCENE_MORIBOSSROOM: C2RustUnnamed_21 = 20;
pub const SCENE_BDAN_BOSS: C2RustUnnamed_21 = 19;
pub const SCENE_DDAN_BOSS: C2RustUnnamed_21 = 18;
pub const SCENE_YDAN_BOSS: C2RustUnnamed_21 = 17;
pub const SCENE_TAKARAYA: C2RustUnnamed_21 = 16;
pub const SCENE_GANONTIKA_SONOGO: C2RustUnnamed_21 = 15;
pub const SCENE_GANON_SONOGO: C2RustUnnamed_21 = 14;
pub const SCENE_GANONTIKA: C2RustUnnamed_21 = 13;
pub const SCENE_GERUDOWAY: C2RustUnnamed_21 = 12;
pub const SCENE_MEN: C2RustUnnamed_21 = 11;
pub const SCENE_GANON: C2RustUnnamed_21 = 10;
pub const SCENE_ICE_DOUKUTO: C2RustUnnamed_21 = 9;
pub const SCENE_HAKADANCH: C2RustUnnamed_21 = 8;
pub const SCENE_HAKADAN: C2RustUnnamed_21 = 7;
pub const SCENE_JYASINZOU: C2RustUnnamed_21 = 6;
pub const SCENE_MIZUSIN: C2RustUnnamed_21 = 5;
pub const SCENE_HIDAN: C2RustUnnamed_21 = 4;
pub const SCENE_BMORI1: C2RustUnnamed_21 = 3;
pub const SCENE_BDAN: C2RustUnnamed_21 = 2;
pub const SCENE_DDAN: C2RustUnnamed_21 = 1;
pub const SCENE_YDAN: C2RustUnnamed_21 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GameInfo {
    pub regPage: s32,
    pub regGroup: s32,
    pub regCur: s32,
    pub dpadLast: s32,
    pub repeat: s32,
    pub data: [s16; 2784],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct QuakeCamCalc {
    pub atOffset: Vec3f,
    pub eyeOffset: Vec3f,
    pub rotZ: s16,
    pub unk_1A: s16,
    pub zoom: s16,
    pub unk_20: f32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CameraModeValue {
    pub val: s16,
    pub param: s16,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CameraMode {
    pub funcIdx: s16,
    pub valueCnt: s16,
    pub values: *mut CameraModeValue,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CameraSetting {
    pub c2rust_unnamed: C2RustUnnamed_22,
    pub cameraModes: *mut CameraMode,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_22 {
    pub unk_00: u32_0,
    pub c2rust_unnamed: C2RustUnnamed_23,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct C2RustUnnamed_23 {
    #[bitfield(name = "unk_bit0", ty = "u32_0", bits = "0..=0")]
    #[bitfield(name = "unk_bit1", ty = "u32_0", bits = "1..=1")]
    #[bitfield(name = "validModes", ty = "u32_0", bits = "2..=31")]
    pub unk_bit0_unk_bit1_validModes: [u8; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EnHorse {
    pub actor: Actor,
    pub action: EnHorseAction,
    pub noInputTimer: s32,
    pub noInputTimerMax: s32,
    pub type_0: s32,
    pub bankIndex: s8,
    pub skin: PSkinAwb,
    pub stateFlags: u32_0,
    pub lastPos: Vec3f,
    pub lastYaw: s16,
    pub curRaceWaypoint: s32,
    pub boostSpeed: s32,
    pub playerControlled: s32,
    pub animationIdx: s32,
    pub curFrame: f32_0,
    pub soundTimer: s32,
    pub unk_21C: Vec3f,
    pub unk_228: Vec3f,
    pub unk_234: s32,
    pub numBoosts: u8_0,
    pub boostRegenTime: s32,
    pub boostTimer: s32,
    pub postDrawFunc: EnHorsePostdrawFunc,
    pub yFront: f32_0,
    pub yBack: f32_0,
    pub followTimer: s16,
    pub unk_252: s16,
    pub prevAction: EnHorseAction,
    pub riderPos: Vec3f,
    pub curStick: Vec2f,
    pub lastStick: Vec2f,
    pub jumpStartY: f32_0,
    pub cyl1: ColliderCylinder,
    pub cyl2: ColliderCylinder,
    pub jntSph: ColliderJntSph,
    pub jntSphList: ColliderJntSphElement,
    pub playerDir: u32_0,
    pub unk_374: s16,
    pub angleToPlayer: s16,
    pub followPlayerTurnSpeed: s16,
    pub blinkTimer: u8_0,
    pub waitTimer: s16,
    pub unk_37E: s16,
    pub cutsceneAction: s32,
    pub cutsceneFlags: u16_0,
    pub inRace: s32,
    pub rider: *mut Actor,
    pub unk_390: u32_0,
    pub ingoRaceFlags: u16_0,
    pub ingoHorseMaxSpeed: f32_0,
    pub unk_39C: s32,
    pub hbaStarted: s32,
    pub hbaFlags: s32,
    pub hbaTimer: s32,
    pub bridgeJumpIdx: u8_0,
    pub bridgeJumpStart: Vec3f,
    pub bridgeJumpTimer: s32,
    pub bridgeJumpYVel: f32_0,
    pub bridgeJumpRelAngle: s16,
    pub unk_3C6: s16,
    pub dustFlags: u16_0,
    pub frontRightHoof: Vec3f,
    pub frontLeftHoof: Vec3f,
    pub backRightHoof: Vec3f,
    pub backLeftHoof: Vec3f,
}
pub type EnHorseAction = libc::c_uint;
pub const ENHORSE_ACT_FLEE_PLAYER: EnHorseAction = 19;
pub const ENHORSE_ACT_HBA: EnHorseAction = 18;
pub const ENHORSE_ACT_CS_UPDATE: EnHorseAction = 17;
pub const ENHORSE_ACT_BRIDGE_JUMP: EnHorseAction = 16;
pub const ENHORSE_ACT_HIGH_JUMP: EnHorseAction = 15;
pub const ENHORSE_ACT_LOW_JUMP: EnHorseAction = 14;
pub const ENHORSE_ACT_REVERSE: EnHorseAction = 13;
pub const ENHORSE_ACT_STOPPING: EnHorseAction = 12;
pub const ENHORSE_ACT_MOUNTED_REARING: EnHorseAction = 11;
pub const ENHORSE_ACT_MOUNTED_GALLOP: EnHorseAction = 10;
pub const ENHORSE_ACT_MOUNTED_TROT: EnHorseAction = 9;
pub const ENHORSE_ACT_MOUNTED_WALK: EnHorseAction = 8;
pub const ENHORSE_ACT_MOUNTED_TURN: EnHorseAction = 7;
pub const ENHORSE_ACT_MOUNTED_IDLE_WHINNEYING: EnHorseAction = 6;
pub const ENHORSE_ACT_MOUNTED_IDLE: EnHorseAction = 5;
pub const ENHORSE_ACT_INGO_RACE: EnHorseAction = 4;
pub const ENHORSE_ACT_FOLLOW_PLAYER: EnHorseAction = 3;
pub const ENHORSE_ACT_IDLE: EnHorseAction = 2;
pub const ENHORSE_ACT_INACTIVE: EnHorseAction = 1;
pub const ENHORSE_ACT_FROZEN: EnHorseAction = 0;
pub type EnHorsePostdrawFunc
    =
    Option<unsafe extern "C" fn(_: *mut EnHorse, _: *mut GlobalContext)
               -> ()>;
#[no_mangle]
pub static mut sOREGInit: [s16; 53] =
    [0 as libc::c_int as s16, 1 as libc::c_int as s16,
     5 as libc::c_int as s16, 5 as libc::c_int as s16,
     5 as libc::c_int as s16, 14500 as libc::c_int as s16,
     20 as libc::c_int as s16, 16 as libc::c_int as s16,
     150 as libc::c_int as s16, 25 as libc::c_int as s16,
     150 as libc::c_int as s16, 6 as libc::c_int as s16,
     10 as libc::c_int as s16, 10 as libc::c_int as s16,
     0 as libc::c_int as s16, 0 as libc::c_int as s16,
     1 as libc::c_int as s16, 100 as libc::c_int as s16,
     250 as libc::c_int as s16, 120 as libc::c_int as s16,
     80 as libc::c_int as s16, 30 as libc::c_int as s16,
     120 as libc::c_int as s16, 4 as libc::c_int as s16,
     1 as libc::c_int as s16, 50 as libc::c_int as s16,
     20 as libc::c_int as s16, 1800 as libc::c_int as s16,
     50 as libc::c_int as s16, 50 as libc::c_int as s16,
     50 as libc::c_int as s16, 20 as libc::c_int as s16,
     20 as libc::c_int as s16, -(10 as libc::c_int) as s16,
     -(5460 as libc::c_int) as s16, -(9100 as libc::c_int) as s16,
     -(6 as libc::c_int) as s16, 8 as libc::c_int as s16,
     15 as libc::c_int as s16, 75 as libc::c_int as s16,
     60 as libc::c_int as s16, 12 as libc::c_int as s16,
     110 as libc::c_int as s16, 40 as libc::c_int as s16,
     50 as libc::c_int as s16, 250 as libc::c_int as s16,
     -(10 as libc::c_int) as s16, 30 as libc::c_int as s16,
     30 as libc::c_int as s16, 70 as libc::c_int as s16,
     20 as libc::c_int as s16, 20 as libc::c_int as s16,
     20 as libc::c_int as s16];
#[no_mangle]
pub static mut sOREGInitCnt: s16 = 53 as libc::c_int as s16;
#[no_mangle]
pub static mut sPREGInit: [s16; 27] =
    [-(20 as libc::c_int) as s16, 200 as libc::c_int as s16,
     300 as libc::c_int as s16, 10 as libc::c_int as s16,
     12 as libc::c_int as s16, 10 as libc::c_int as s16,
     35 as libc::c_int as s16, 60 as libc::c_int as s16,
     60 as libc::c_int as s16, 3 as libc::c_int as s16,
     0 as libc::c_int as s16, -(40 as libc::c_int) as s16,
     20 as libc::c_int as s16, 25 as libc::c_int as s16,
     45 as libc::c_int as s16, -(5 as libc::c_int) as s16,
     15 as libc::c_int as s16, 15 as libc::c_int as s16,
     20 as libc::c_int as s16, 0 as libc::c_int as s16,
     0 as libc::c_int as s16, 0 as libc::c_int as s16,
     6 as libc::c_int as s16, 60 as libc::c_int as s16,
     30 as libc::c_int as s16, 0 as libc::c_int as s16,
     5 as libc::c_int as s16];
#[no_mangle]
pub static mut sPREGInitCnt: s16 = 27 as libc::c_int as s16;
#[no_mangle]
pub static mut sCameraSettingNames: [[libc::c_char; 12]; 66] =
    unsafe {
        [*::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"NONE      \x00\x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"NORMAL0    \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"NORMAL1    \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"DUNGEON0   \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"DUNGEON1   \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"NORMAL3    \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"HORSE0     \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"BOSS_GOMA  \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"BOSS_DODO  \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"BOSS_BARI  \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"BOSS_FGANON\x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"BOSS_BAL   \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"BOSS_SHADES\x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"BOSS_MOFA  \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"BOSS_TWIN0 \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"BOSS_TWIN1 \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"BOSS_GANON1\x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"BOSS_GANON2\x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"TOWER0     \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"TOWER1     \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"FIXED0     \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"FIXED1     \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"CIRCLE0    \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"CIRCLE2    \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"CIRCLE3    \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"PREREND0   \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"PREREND1   \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"PREREND3   \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"DOOR0      \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"DOORC      \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"RAIL3      \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"START0     \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"START1     \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"FREE0      \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"FREE2      \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"CIRCLE4    \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"CIRCLE5    \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"DEMO0      \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"DEMO1      \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"MORI1      \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"ITEM0      \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"ITEM1      \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"DEMO3      \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"DEMO4      \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"UFOBEAN    \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"LIFTBEAN   \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"SCENE0     \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"SCENE1     \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"HIDAN1     \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"HIDAN2     \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"MORI2      \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"MORI3      \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"TAKO       \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"SPOT05A    \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"SPOT05B    \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"HIDAN3     \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"ITEM2      \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"CIRCLE6    \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"NORMAL2    \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"FISHING    \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"DEMOC      \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"UO_FIBER   \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"DUNGEON2   \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"TEPPEN     \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"CIRCLE7    \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"NORMAL4    \x00")]
    };
#[no_mangle]
pub static mut sCameraModeNames: [[libc::c_char; 12]; 21] =
    unsafe {
        [*::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"NORMAL     \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"PARALLEL   \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"KEEPON     \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"TALK       \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"BATTLE     \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"CLIMB      \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"SUBJECT    \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"BOWARROW   \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"BOWARROWZ  \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"FOOKSHOT   \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"BOOMERANG  \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"PACHINCO   \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"CLIMBZ     \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"JUMP       \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"HANG       \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"HANGZ      \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"FREEFALL   \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"CHARGE     \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"STILL      \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"PUSHPULL   \x00"),
         *::std::mem::transmute::<&[u8; 12],
                                  &mut [libc::c_char; 12]>(b"BOOKEEPON  \x00")]
    };
#[no_mangle]
pub static mut D_8011A3A0: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 12 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 35 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A3C8: [CameraModeValue; 11] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 10 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x200a as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A3F4: [CameraModeValue; 13] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 120 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 140 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(5 as libc::c_int) as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2001 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(50 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A428: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(30 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3500 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A458: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 180 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2002 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A488: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 18 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A4AC: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 19 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 20 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 21 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A4D0: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: -(7 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 14 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 19 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(30 as libc::c_int) as s16,
                             param: 20 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(5 as libc::c_int) as s16,
                             param: 21 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A4F4: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(120 as libc::c_int) as s16,
                             param: 19 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 20 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 21 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A518: [CameraModeValue; 8] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 6 as libc::c_int as s16,
                             param: 22 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A538: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 19 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 20 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 21 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A55C: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: -(7 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 14 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(9 as libc::c_int) as s16,
                             param: 19 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(63 as libc::c_int) as s16,
                             param: 20 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(30 as libc::c_int) as s16,
                             param: 21 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A580: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 18 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 999 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2006 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A5A4: [CameraModeValue; 8] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 12 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 35 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A5C4: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(80 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A5E0: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(120 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A5FC: [CameraModeValue; 8] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A61C: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 2 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0xf000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A638: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0xf003 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A660: [CameraModeValue; 11] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 10 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x206a as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A68C: [CameraModeValue; 13] =
    [{
         let mut init =
             CameraModeValue{val: -(5 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 120 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 140 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 85 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2001 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(15 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetNorm1ModeNormVals: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 400 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 12 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetNorm1ModeParaVals: [CameraModeValue; 11] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 10 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2002 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A714: [CameraModeValue; 13] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 120 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 140 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(5 as libc::c_int) as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2001 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(50 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A748: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 65 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2002 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A778: [CameraModeValue; 8] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 6 as libc::c_int as s16,
                             param: 22 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A798: [CameraModeValue; 8] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 400 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A7B8: [CameraModeValue; 8] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 400 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A7D8: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 400 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 18 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A7FC: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 400 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 18 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 999 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2006 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A820: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 2 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0xf000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A83C: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(80 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 400 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A858: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(120 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 400 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 400 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A874: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 400 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0xf003 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A89C: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(10 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A8C4: [CameraModeValue; 11] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 10 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x200a as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A8F0: [CameraModeValue; 13] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 120 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 140 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(5 as libc::c_int) as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2001 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A924: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 180 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2002 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A954: [CameraModeValue; 8] =
    [{
         let mut init =
             CameraModeValue{val: -(10 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A974: [CameraModeValue; 8] =
    [{
         let mut init =
             CameraModeValue{val: -(10 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A994: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 18 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A9B8: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 18 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 999 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2006 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A9DC: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(10 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 2 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0xf000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011A9F8: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(80 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AA14: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(120 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AA30: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(10 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0xf003 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AA58: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AA80: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3500 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AAB0: [CameraModeValue; 8] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AAD0: [CameraModeValue; 8] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 180 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 12 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AAF0: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 18 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AB14: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 18 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 999 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2006 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AB38: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 2 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0xf000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AB54: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(80 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AB70: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(120 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AB8C: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0xf003 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011ABB4: [CameraModeValue; 11] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 180 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 10 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x206a as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetNorm3ModeNormVals: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 280 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x4 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AC08: [CameraModeValue; 11] =
    [{
         let mut init =
             CameraModeValue{val: -(50 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 10 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x200a as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(50 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AC34: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(30 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3500 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetNorm3ModeBoomVals: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(5 as libc::c_int) as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 18 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x5 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetHrse0ModeNormVals: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: -(50 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 220 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 16 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x600 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetHrse0ModeParaVals: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 180 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 220 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(2 as libc::c_int) as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 12 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2600 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011ACD4: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: -(7 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 14 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 19 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(30 as libc::c_int) as s16,
                             param: 20 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(5 as libc::c_int) as s16,
                             param: 21 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2600 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011ACF8: [CameraModeValue; 13] =
    [{
         let mut init =
             CameraModeValue{val: -(60 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 180 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 220 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(5 as libc::c_int) as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2601 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(60 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AD2C: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(60 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 140 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3500 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AD5C: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x1 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AD84: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(30 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(10 as libc::c_int) as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2002 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(50 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011ADB4: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 12 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011ADDC: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 160 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(5 as libc::c_int) as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2002 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AE0C: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(5 as libc::c_int) as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AE34: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(30 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 125 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2002 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(50 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AE64: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AE8C: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(5 as libc::c_int) as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 35 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2002 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AEBC: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 16 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AEE4: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2002 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AF14: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x83 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AF3C: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2082 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AF6C: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x83 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AF94: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(10 as libc::c_int) as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AFBC: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(10 as libc::c_int) as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2002 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011AFEC: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B014: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 400 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(10 as libc::c_int) as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2002 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B044: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(10 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(10 as libc::c_int) as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 12 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B06C: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 330 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 330 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(5 as libc::c_int) as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B094: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 2 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0xf000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B0B0: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B0D8: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 180 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2002 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B108: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 120 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 280 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 23 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 8 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B12C: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 120 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 280 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 23 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 8 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x80 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B150: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 270 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 120 as libc::c_int as s16,
                             param: 23 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 8 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B174: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 270 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 120 as libc::c_int as s16,
                             param: 23 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 6 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetFixd0ModeNormVals: [CameraModeValue; 4] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B1A8: [CameraModeValue; 4] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B1B8: [CameraModeValue; 4] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3500 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B1C8: [CameraModeValue; 4] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetCirc0ModeNormVals: [CameraModeValue; 5] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x1 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetCirc2ModeNormVals: [CameraModeValue; 3] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3f00 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B1F8: [CameraModeValue; 5] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x4 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B20C: [CameraModeValue; 1] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetPR0ModeKeepTalkVals: [CameraModeValue; 1] =
    [{
         let mut init =
             CameraModeValue{val: 0x2000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetPR1ModeNormVals: [CameraModeValue; 2] =
    [{
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetPR1ModeKeepVals: [CameraModeValue; 2] =
    [{
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetPreRend1ModeTalkVals: [CameraModeValue; 4] =
    [{
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 24 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 25 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 4 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3500 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetDoor0ModeNormVals: [CameraModeValue; 3] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3200 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetDoorCModeNormVals: [CameraModeValue; 3] =
    [{
         let mut init =
             CameraModeValue{val: -(5 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3202 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetDoorCModeParaVals: [CameraModeValue; 3] =
    [{
         let mut init =
             CameraModeValue{val: -(5 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x320a as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetRail3ModeNormVals: [CameraModeValue; 6] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 2 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3200 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B270: [CameraModeValue; 1] =
    [{
         let mut init =
             CameraModeValue{val: 0x1 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetFree0ModeNormVals: [CameraModeValue; 1] =
    [{
         let mut init =
             CameraModeValue{val: 0xff00 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetFree1ModeNormVals: [CameraModeValue; 1] =
    [{
         let mut init =
             CameraModeValue{val: 0xff01 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetCirc4ModeNormVals: [CameraModeValue; 5] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B290: [CameraModeValue; 4] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B2A0: [CameraModeValue; 4] =
    [{
         let mut init =
             CameraModeValue{val: -(30 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2001 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B2B0: [CameraModeValue; 1] =
    [{
         let mut init =
             CameraModeValue{val: 0x3200 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetMori1ModeNormVals: [CameraModeValue; 11] =
    [{
         let mut init =
             CameraModeValue{val: -(50 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 450 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 180 as libc::c_int as s16,
                             param: 10 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0xc as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(50 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B2E0: [CameraModeValue; 1] =
    [{
         let mut init =
             CameraModeValue{val: 0x3501 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B2E4: [CameraModeValue; 3] =
    [{
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3200 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetDemo3ModeNormVals: [CameraModeValue; 1] =
    [{
         let mut init =
             CameraModeValue{val: 0x3212 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B2F4: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(50 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B31C: [CameraModeValue; 11] =
    [{
         let mut init =
             CameraModeValue{val: -(50 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 10 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x200a as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B348: [CameraModeValue; 8] =
    [{
         let mut init =
             CameraModeValue{val: -(50 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 12 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 35 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B368: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(80 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B384: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(120 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B3A0: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 350 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0xf002 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B3C8: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(50 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 16 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B3F0: [CameraModeValue; 11] =
    [{
         let mut init =
             CameraModeValue{val: -(50 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 10 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x200a as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B41C: [CameraModeValue; 8] =
    [{
         let mut init =
             CameraModeValue{val: -(50 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 12 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 35 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B43C: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(80 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B458: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(120 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B474: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0xf002 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetScn0ModeNormVals: [CameraModeValue; 3] =
    [{
         let mut init =
             CameraModeValue{val: -(30 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x10a as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B4A8: [CameraModeValue; 4] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 150 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x210 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B4B8: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 400 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 35 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 14 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x12 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B4E0: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2002 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B510: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 8 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x12 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B538: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x12 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B560: [CameraModeValue; 11] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 10 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x201a as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B58C: [CameraModeValue; 11] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 10 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x201a as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B5B8: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x12 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B5E0: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 750 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 750 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x12 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B608: [CameraModeValue; 11] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 750 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 10 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x201a as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B634: [CameraModeValue; 11] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 750 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 10 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x200a as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B660: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 750 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 750 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x12 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B688: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B6B0: [CameraModeValue; 11] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 10 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x200a as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B6DC: [CameraModeValue; 11] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 10 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x200a as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B708: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 500 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B730: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: -(30 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 120 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(10 as libc::c_int) as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 170 as libc::c_int as s16,
                             param: 10 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 21 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2502 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 6 as libc::c_int as s16,
                             param: 22 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetCirc6ModeNormVals: [CameraModeValue; 2] =
    [{
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3200 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B75C: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 12 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 35 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B784: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 12 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 35 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 55 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0xf02 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B7AC: [CameraModeValue; 11] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 10 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2f0a as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B7D8: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 55 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2f02 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B808: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(30 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3f20 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B838: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 19 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 20 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 21 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0xf00 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B85C: [CameraModeValue; 8] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 12 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 35 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0xf00 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B87C: [CameraModeValue; 8] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0xf00 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B89C: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(80 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0xf00 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B8B8: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(120 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2f00 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetDemoCModeNormVals: [CameraModeValue; 1] =
    [{
         let mut init =
             CameraModeValue{val: 0x3f00 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B8D8: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 300 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 26 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B900: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(30 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 160 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2002 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(50 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B930: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 350 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 350 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B958: [CameraModeValue; 11] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 10 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x200a as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sSetDung2ModeBattVals: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 180 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(10 as libc::c_int) as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2002 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B9B4: [CameraModeValue; 8] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 350 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 350 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B9D4: [CameraModeValue; 8] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 350 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 350 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 15 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011B9F4: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 350 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 350 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 18 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011BA18: [CameraModeValue; 9] =
    [{
         let mut init =
             CameraModeValue{val: -(40 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 350 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 350 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 18 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 999 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2006 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011BA3C: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(50 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 350 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 350 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011BA58: [CameraModeValue; 7] =
    [{
         let mut init =
             CameraModeValue{val: -(100 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 350 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 350 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2000 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011BA74: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(10 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 350 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 350 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 100 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0xf003 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011BA9C: [CameraModeValue; 11] =
    [{
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 280 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 25 as libc::c_int as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 10 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x206a as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011BAC8: [CameraModeValue; 10] =
    [{
         let mut init =
             CameraModeValue{val: -(10 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 280 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 320 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(8 as libc::c_int) as s16,
                             param: 3 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 5 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 6 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 60 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 80 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011BAF0: [CameraModeValue; 13] =
    [{
         let mut init =
             CameraModeValue{val: -(20 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 180 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 35 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(5 as libc::c_int) as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 20 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x2001 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(50 as libc::c_int) as s16,
                             param: 11 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 12 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011BB24: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(80 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 250 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(8 as libc::c_int) as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: -(8 as libc::c_int) as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 30 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x3520 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011BB54: [CameraModeValue; 12] =
    [{
         let mut init =
             CameraModeValue{val: -(30 as libc::c_int) as s16,
                             param: 0 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 1 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 200 as libc::c_int as s16,
                             param: 2 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 40 as libc::c_int as s16,
                             param: 13 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 14 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0 as libc::c_int as s16,
                             param: 15 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 5 as libc::c_int as s16,
                             param: 16 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 70 as libc::c_int as s16,
                             param: 17 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 45 as libc::c_int as s16,
                             param: 7 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 50 as libc::c_int as s16,
                             param: 8 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 10 as libc::c_int as s16,
                             param: 4 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             CameraModeValue{val: 0x35a0 as libc::c_int as s16,
                             param: 9 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut sCamSetNorm0Modes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A3A0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A458.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5FC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetNorm1Modes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values:
                                sSetNorm1ModeNormVals.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values:
                                sSetNorm1ModeParaVals.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A714.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A748.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A7D8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A778.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A7FC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A798.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A83C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A858.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A7B8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A820.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A874.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetDungeon0Modes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A89C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A8C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A8F0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A924.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A994.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A778.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A9B8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A954.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A9F8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011AA14.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A974.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A9DC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011AA30.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetDungeon1Modes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011AA58.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A8C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A714.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011AA80.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A924.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011AAF0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A778.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011AB14.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011AAB0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011AB54.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011AB70.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011AAD0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011AB38.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011AB8C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011ABB4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetNorm3Modes: [CameraMode; 20] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP3 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values:
                                sSetNorm3ModeNormVals.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011AC08.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011AC34.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A458.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP3 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values:
                                sSetNorm3ModeBoomVals.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetHorse0Modes: [CameraMode; 9] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values:
                                sSetHrse0ModeNormVals.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values:
                                sSetHrse0ModeParaVals.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011ACF8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011AD2C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011ACD4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetBossGomaModes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011AD5C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011AD84.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A9DC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetBossDodoModes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011ADB4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011ADDC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetBossBariModes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011AE0C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011AE34.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetBossFGanonModes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011AE64.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011AE8C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetBossBalModes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011AEBC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011AEE4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetBossShadesModes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011AF14.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011AF3C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011AF6C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011AF6C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetBossMofaModes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011AF94.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011AFBC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetBossTwin0Modes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011AFEC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011B014.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetBossTwin1Modes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B044.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011B014.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetBossGanon1Modes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B06C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011AE8C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011B094.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetBossGanon2Modes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B0B0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011B0D8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetTower0Modes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011B108.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A458.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011B12C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetTower1Modes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011B150.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A458.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011B174.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetFixed0Modes: [CameraMode; 4] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_FIXD1 as libc::c_int as s16,
                            valueCnt: 4 as libc::c_int as s16,
                            values:
                                sSetFixd0ModeNormVals.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_FIXD1 as libc::c_int as s16,
                            valueCnt: 4 as libc::c_int as s16,
                            values: D_8011B1A8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_FIXD1 as libc::c_int as s16,
                            valueCnt: 4 as libc::c_int as s16,
                            values: D_8011B1B8.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetFixed1Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_FIXD1 as libc::c_int as s16,
                            valueCnt: 4 as libc::c_int as s16,
                            values: D_8011B1C8.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetCirc0Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_FIXD2 as libc::c_int as s16,
                            valueCnt: 5 as libc::c_int as s16,
                            values:
                                sSetCirc0ModeNormVals.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetCirc2Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_DATA4 as libc::c_int as s16,
                            valueCnt: 3 as libc::c_int as s16,
                            values:
                                sSetCirc2ModeNormVals.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetCirc3Modes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_FIXD4 as libc::c_int as s16,
                            valueCnt: 5 as libc::c_int as s16,
                            values: D_8011B1F8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A748.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetPreRend0Modes: [CameraMode; 4] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_FIXD3 as libc::c_int as s16,
                            valueCnt: 1 as libc::c_int as s16,
                            values: D_8011B20C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_FIXD3 as libc::c_int as s16,
                            valueCnt: 1 as libc::c_int as s16,
                            values:
                                sSetPR0ModeKeepTalkVals.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_FIXD3 as libc::c_int as s16,
                            valueCnt: 1 as libc::c_int as s16,
                            values:
                                sSetPR0ModeKeepTalkVals.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetPreRend1Modes: [CameraMode; 4] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ7 as libc::c_int as s16,
                            valueCnt: 2 as libc::c_int as s16,
                            values: sSetPR1ModeNormVals.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ7 as libc::c_int as s16,
                            valueCnt: 2 as libc::c_int as s16,
                            values: sSetPR1ModeKeepVals.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP0 as libc::c_int as s16,
                            valueCnt: 4 as libc::c_int as s16,
                            values:
                                sSetPreRend1ModeTalkVals.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetPreRend3Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC6 as libc::c_int as s16,
                            valueCnt: 1 as libc::c_int as s16,
                            values: D_8011B20C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetDoor0Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ3 as libc::c_int as s16,
                            valueCnt: 3 as libc::c_int as s16,
                            values:
                                sSetDoor0ModeNormVals.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetDoorCModes: [CameraMode; 2] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC9 as libc::c_int as s16,
                            valueCnt: 3 as libc::c_int as s16,
                            values:
                                sSetDoorCModeNormVals.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC9 as libc::c_int as s16,
                            valueCnt: 3 as libc::c_int as s16,
                            values:
                                sSetDoorCModeParaVals.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetRail3Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ4 as libc::c_int as s16,
                            valueCnt: 6 as libc::c_int as s16,
                            values:
                                sSetRail3ModeNormVals.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetStart0Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ0 as libc::c_int as s16,
                            valueCnt: 1 as libc::c_int as s16,
                            values: D_8011B20C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetStart1Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ0 as libc::c_int as s16,
                            valueCnt: 1 as libc::c_int as s16,
                            values: D_8011B270.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetFree0Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ6 as libc::c_int as s16,
                            valueCnt: 1 as libc::c_int as s16,
                            values:
                                sSetFree0ModeNormVals.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetFree1Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ6 as libc::c_int as s16,
                            valueCnt: 1 as libc::c_int as s16,
                            values:
                                sSetFree1ModeNormVals.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetCirc4Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_FIXD2 as libc::c_int as s16,
                            valueCnt: 5 as libc::c_int as s16,
                            values:
                                sSetCirc4ModeNormVals.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetCirc5Modes: [CameraMode; 2] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ2 as libc::c_int as s16,
                            valueCnt: 4 as libc::c_int as s16,
                            values: D_8011B290.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ2 as libc::c_int as s16,
                            valueCnt: 4 as libc::c_int as s16,
                            values: D_8011B2A0.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetDemo0Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_DEMO1 as libc::c_int as s16,
                            valueCnt: 1 as libc::c_int as s16,
                            values: D_8011B2B0.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetDemo1Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_DEMO2 as libc::c_int as s16,
                            valueCnt: 1 as libc::c_int as s16,
                            values: D_8011B2B0.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetMori1Modes: [CameraMode; 4] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values:
                                sSetMori1ModeNormVals.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA3 as libc::c_int as s16,
                            valueCnt: 1 as libc::c_int as s16,
                            values: D_8011B2E0.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetItem0Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_DEMO3 as libc::c_int as s16,
                            valueCnt: 3 as libc::c_int as s16,
                            values: D_8011B2E4.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetItem1Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_DEMO4 as libc::c_int as s16,
                            valueCnt: 3 as libc::c_int as s16,
                            values: D_8011B2E4.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetDemo3Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_DEMO9 as libc::c_int as s16,
                            valueCnt: 1 as libc::c_int as s16,
                            values:
                                sSetDemo3ModeNormVals.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetDemo4Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_DEMO5 as libc::c_int as s16,
                            valueCnt: 1 as libc::c_int as s16,
                            values: D_8011B2B0.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetUFOBeanModes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B2F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011B31C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A748.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011B348.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011B368.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011B384.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B3A0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetLiftBeanModes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011B3F0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A748.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011B41C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011B43C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011B458.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B474.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetScene0Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC9 as libc::c_int as s16,
                            valueCnt: 3 as libc::c_int as s16,
                            values: sSetScn0ModeNormVals.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetScene1Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ2 as libc::c_int as s16,
                            valueCnt: 4 as libc::c_int as s16,
                            values: D_8011B4A8.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetHidan1Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC7 as libc::c_int as s16,
                            valueCnt: 1 as libc::c_int as s16,
                            values: D_8011B20C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetHidan2Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC4 as libc::c_int as s16,
                            valueCnt: 1 as libc::c_int as s16,
                            values: D_8011B2B0.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetMori2Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ5 as libc::c_int as s16,
                            valueCnt: 1 as libc::c_int as s16,
                            values: D_8011B2B0.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetMori3Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_DEMO6 as libc::c_int as s16,
                            valueCnt: 1 as libc::c_int as s16,
                            values: D_8011B2B0.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetTakoModes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B4B8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A8C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A8F0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011B4E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A994.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A778.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A9B8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A954.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A9F8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011AA14.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A974.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A9DC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B510.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetSpot05AModes: [CameraMode; 6] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011B560.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: 0 as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: 0 as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011B58C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B5B8.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetSpot05BModes: [CameraMode; 6] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011B608.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: 0 as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: 0 as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011B634.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B660.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetHidan3Modes: [CameraMode; 6] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B688.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011B6B0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: 0 as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: 0 as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011B6DC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B708.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetItem2Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP4 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011B730.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetCirc6Modes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC0 as libc::c_int as s16,
                            valueCnt: 2 as libc::c_int as s16,
                            values:
                                sSetCirc6ModeNormVals.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetNorm2Modes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B75C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A748.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetFishingModes: [CameraMode; 17] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B784.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011B7AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011B7D8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011B808.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011B7D8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011B838.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011B85C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011B89C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011B8B8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011B87C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetDemoCModes: [CameraMode; 1] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ9 as libc::c_int as s16,
                            valueCnt: 1 as libc::c_int as s16,
                            values:
                                sSetDemoCModeNormVals.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetUOFiberModes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B8D8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011B900.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetDungeon2Modes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B930.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011B958.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A8F0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values:
                                sSetDung2ModeBattVals.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011B9F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A778.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011BA18.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011B9B4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011BA3C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011BA58.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011B9D4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011BA74.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011BA9C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetTeppenModes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011BAC8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011BAF0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011BB24.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A458.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetCirc7Modes: [CameraMode; 12] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_FIXD4 as libc::c_int as s16,
                            valueCnt: 5 as libc::c_int as s16,
                            values: D_8011B1F8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_FIXD4 as libc::c_int as s16,
                            valueCnt: 5 as libc::c_int as s16,
                            values: D_8011B1F8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A428.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NONE as libc::c_int as s16,
                            valueCnt: 0 as libc::c_int as s16,
                            values:
                                0 as *const CameraModeValue as
                                    *mut CameraModeValue,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCamSetNorm4Modes: [CameraMode; 21] =
    unsafe {
        [{
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011B75C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A3C8.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A3F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP3 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011BB54.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT1 as libc::c_int as s16,
                            valueCnt: 12 as libc::c_int as s16,
                            values: D_8011A748.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A488.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4AC.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4D0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A4F4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SPEC5 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A518.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A538.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_SUBJ3 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A55C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP2 as libc::c_int as s16,
                            valueCnt: 9 as libc::c_int as s16,
                            values: D_8011A580.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5C4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_UNIQ1 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A5E0.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_JUMP1 as libc::c_int as s16,
                            valueCnt: 8 as libc::c_int as s16,
                            values: D_8011A5A4.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_BATT4 as libc::c_int as s16,
                            valueCnt: 7 as libc::c_int as s16,
                            values: D_8011A61C.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_NORM1 as libc::c_int as s16,
                            valueCnt: 10 as libc::c_int as s16,
                            values: D_8011A638.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_PARA1 as libc::c_int as s16,
                            valueCnt: 11 as libc::c_int as s16,
                            values: D_8011A660.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraMode{funcIdx: CAM_FUNC_KEEP1 as libc::c_int as s16,
                            valueCnt: 13 as libc::c_int as s16,
                            values: D_8011A68C.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCameraSettings: [CameraSetting; 66] =
    unsafe {
        [{
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0 as libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   0 as *const CameraMode as
                                       *mut CameraMode,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetNorm0Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetNorm1Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetDungeon0Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetDungeon1Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x50ff7ff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetNorm3Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x8500018f as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetHorse0Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetBossGomaModes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetBossDodoModes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetBossBariModes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetBossFGanonModes.as_ptr() as
                                       *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetBossBalModes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetBossShadesModes.as_ptr() as
                                       *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetBossMofaModes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetBossTwin0Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetBossTwin1Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetBossGanon1Modes.as_ptr() as
                                       *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetBossGanon2Modes.as_ptr() as
                                       *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x851fffff as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetTower0Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x851fffff as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetTower1Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x8500000d as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetFixed0Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x85000001 as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetFixed1Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x85000001 as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetCirc0Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x85000001 as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetCirc2Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x851e1fff as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetCirc3Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x8c00000d as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetPreRend0Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x8c00000d as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetPreRend1Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x8c000001 as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetPreRend3Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0xc5000001 as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetDoor0Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0xc5000003 as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetDoorCModes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0xc5000001 as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetRail3Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0xc5000001 as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetStart0Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0xc5000001 as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetStart1Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x5000001 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetFree0Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x5000001 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetFree1Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x85000001 as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetCirc4Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x5000003 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetCirc5Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0xce000001 as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetDemo0Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x4e000001 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetDemo1Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x5000009 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetMori1Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x45000001 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetItem0Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x45000001 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetItem1Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x45000001 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetDemo3Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x45000001 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetDemo4Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x451fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetUFOBeanModes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x451fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetLiftBeanModes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0xc5000001 as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetScene0Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x45000001 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetScene1Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x5000001 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetHidan1Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x45000001 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetHidan2Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x45000001 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetMori2Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x45000001 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetMori3Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x451fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetTakoModes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x5000033 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetSpot05AModes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x5000033 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetSpot05BModes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x5000033 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetHidan3Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x4a000001 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetItem2Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x5000001 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetCirc6Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetNorm2Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x501e05f as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetFishingModes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x45000001 as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetDemoCModes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetUOFiberModes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetDungeon2Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetTeppenModes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0xc5000ecd as
                                                            libc::c_uint,},
                               cameraModes:
                                   sCamSetCirc7Modes.as_ptr() as *mut _,};
             init
         },
         {
             let mut init =
                 CameraSetting{c2rust_unnamed:
                                   C2RustUnnamed_22{unk_00:
                                                        0x51fffff as
                                                            libc::c_int as
                                                            u32_0,},
                               cameraModes:
                                   sCamSetNorm4Modes.as_ptr() as *mut _,};
             init
         }]
    };
#[no_mangle]
pub static mut sCameraFunctions:
           [Option<unsafe extern "C" fn(_: *mut Camera) -> s32>; 71] =
    unsafe {
        [None,
         Some(Camera_Normal0 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Normal1 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Normal2 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Normal3 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Normal4 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Parallel0 as
                  unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Parallel1 as
                  unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Parallel2 as
                  unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Parallel3 as
                  unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Parallel4 as
                  unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_KeepOn0 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_KeepOn1 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_KeepOn2 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_KeepOn3 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_KeepOn4 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Subj0 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Subj1 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Subj2 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Subj3 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Subj4 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Jump0 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Jump1 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Jump2 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Jump3 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Jump4 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Battle0 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Battle1 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Battle2 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Battle3 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Battle4 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Fixed0 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Fixed1 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Fixed2 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Fixed3 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Fixed4 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Data0 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Data1 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Data2 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Data3 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Data4 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Unique0 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Unique1 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Unique2 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Unique3 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Unique4 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Unique5 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Unique6 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Unique7 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Unique8 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Unique9 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Demo0 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Demo1 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Demo2 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Demo3 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Demo4 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Demo5 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Demo6 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Demo7 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Demo8 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Demo9 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Special0 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Special1 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Special2 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Special3 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Special4 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Special5 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Special6 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Special7 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Special8 as unsafe extern "C" fn(_: *mut Camera) -> s32),
         Some(Camera_Special9 as unsafe extern "C" fn(_: *mut Camera) -> s32)]
    };
#[no_mangle]
pub static mut sInitRegs: s32 = 1 as libc::c_int;
#[no_mangle]
pub static mut gDbgCamEnabled: s32 = 0 as libc::c_int;
#[no_mangle]
pub static mut sDbgModeIdx: s32 = -(1 as libc::c_int);
#[no_mangle]
pub static mut sNextUID: s16 = 0 as libc::c_int as s16;
#[no_mangle]
pub static mut sCameraInterfaceFlags: s32 = 1 as libc::c_int;
#[no_mangle]
pub static mut sCameraInterfaceAlpha: s32 = 0x2 as libc::c_int;
#[no_mangle]
pub static mut sCameraShrinkWindowVal: s32 = 0x20 as libc::c_int;
#[no_mangle]
pub static mut D_8011D3AC: s32 = -(1 as libc::c_int);
#[no_mangle]
pub static mut D_8011D3B0: [s16; 14] =
    [0xaaa as libc::c_int as s16, 0xf556 as libc::c_int as s16,
     0x1555 as libc::c_int as s16, 0xeaab as libc::c_int as s16,
     0x2aaa as libc::c_int as s16, 0xd556 as libc::c_int as s16,
     0x3fff as libc::c_int as s16, 0xc001 as libc::c_int as s16,
     0x5555 as libc::c_int as s16, 0xaaab as libc::c_int as s16,
     0x6aaa as libc::c_int as s16, 0x9556 as libc::c_int as s16,
     0x7fff as libc::c_int as s16, 0 as libc::c_int as s16];
#[no_mangle]
pub static mut D_8011D3CC: [s16; 14] =
    [0 as libc::c_int as s16, 0x2c6 as libc::c_int as s16,
     0x58c as libc::c_int as s16, 0 as libc::c_int as s16,
     0 as libc::c_int as s16, 0xfd3a as libc::c_int as s16,
     0 as libc::c_int as s16, 0x852 as libc::c_int as s16,
     0 as libc::c_int as s16, 0 as libc::c_int as s16,
     0xb18 as libc::c_int as s16, 0x2c6 as libc::c_int as s16,
     0xfa74 as libc::c_int as s16, 0 as libc::c_int as s16];
#[no_mangle]
pub static mut sUpdateCameraDirection: s32 = 0 as libc::c_int;
#[no_mangle]
pub static mut D_8011D3EC: s32 = 0 as libc::c_int;
#[no_mangle]
pub static mut D_8011D3F0: s32 = 0 as libc::c_int;
#[no_mangle]
pub static mut sDemo5PrevAction12Frame: s32 = -(16 as libc::c_int);
#[no_mangle]
pub static mut sCameraFunctionNames: [[libc::c_char; 8]; 76] =
    unsafe {
        [*::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"NONE   \x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"NORM0()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"NORM1()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"NORM2()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"NORM3()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"NORM4()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"PARA0()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"PARA1()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"PARA2()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"PARA3()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"PARA4()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"KEEP0()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"KEEP1()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"KEEP2()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"KEEP3()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"KEEP4()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"SUBJ0()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"SUBJ1()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"SUBJ2()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"SUBJ3()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"SUBJ4()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"JUMP0()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"JUMP1()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"JUMP2()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"JUMP3()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"JUMP4()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"BATT0()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"BATT1()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"BATT2()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"BATT3()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"BATT4()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"FIXD0()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"FIXD1()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"FIXD2()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"FIXD3()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"FIXD4()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"DATA0()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"DATA1()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"DATA2()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"DATA3()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"DATA4()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"UNIQ0()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"UNIQ1()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"UNIQ2()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"UNIQ3()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"UNIQ4()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"UNIQ5()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"UNIQ6()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"UNIQ7()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"UNIQ8()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"UNIQ9()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"DEMO0()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"DEMO1()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"DEMO2()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"DEMO3()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"DEMO4()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"DEMO5()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"DEMO6()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"DEMO7()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"DEMO8()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"DEMO9()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"SPEC0()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"SPEC1()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"SPEC2()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"SPEC3()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"SPEC4()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"SPEC5()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"SPEC6()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"SPEC7()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"SPEC8()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"SPEC9()\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"\x00\x00\x00\x00\x00\x00\x00\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"\x00\x00\x00\x00\x00\x00\x00\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"\x00\x00\x00\x00\x00\x00\x00\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"\x00\x00\x00\x00\x00\x00\x00\x00"),
         *::std::mem::transmute::<&[u8; 8],
                                  &mut [libc::c_char; 8]>(b"\x00\x00\x00\x00\x00\x00\x00\x00")]
    };
#[no_mangle]
pub static mut D_8011D658: [VecSph; 4] =
    [{
         let mut init =
             VecSph{r: 50.0f32,
                    pitch: 0xee3a as libc::c_int as s16,
                    yaw: 0xd558 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             VecSph{r: 75.0f32,
                    pitch: 0 as libc::c_int as s16,
                    yaw: 0x8008 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             VecSph{r: 80.0f32,
                    pitch: 0xee3a as libc::c_int as s16,
                    yaw: 0x8008 as libc::c_int as s16,};
         init
     },
     {
         let mut init =
             VecSph{r: 15.0f32,
                    pitch: 0xee3a as libc::c_int as s16,
                    yaw: 0x8008 as libc::c_int as s16,};
         init
     }];
#[no_mangle]
pub static mut D_8011D678: [Vec3f; 4] =
    [{ let mut init = Vec3f{x: 0.0f32, y: 40.0f32, z: 20.0f32,}; init },
     { let mut init = Vec3f{x: 0.0f32, y: 40.0f32, z: 0.0f32,}; init },
     { let mut init = Vec3f{x: 0.0f32, y: 3.0f32, z: -3.0f32,}; init },
     {
         let mut init = Vec3f{x: 0.0f32, y: 3.0f32, z: -3.0f64 as f32_0,};
         init
     }];
#[no_mangle]
pub static mut sDemo5PrevSfxFrame: s32 = -(200 as libc::c_int);
#[no_mangle]
pub static mut D_8011D6AC: [OnePointCsFull; 3] =
    [{
         let mut init =
             OnePointCsFull{actionFlags: 0x8f as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0x2 as libc::c_int as s16,
                            timerInit: 0x1 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 60.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 0.0f32,
                                              z: 0.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 0.0f32,
                                              z: 0.0f32,};
                                    init
                                },};
         init
     },
     {
         let mut init =
             OnePointCsFull{actionFlags: 0x81 as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0x303 as libc::c_int as s16,
                            timerInit: 0x13 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 45.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 20.0f32,
                                              z: 0.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 20.0f32,
                                              z: 0.0f32,};
                                    init
                                },};
         init
     },
     {
         let mut init =
             OnePointCsFull{actionFlags: 0x12 as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0 as libc::c_int as s16,
                            timerInit: 0x1 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 60.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: -1.0f32,
                                              y: -1.0f32,
                                              z: -1.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: -1.0f32,
                                              y: -1.0f32,
                                              z: -1.0f32,};
                                    init
                                },};
         init
     }];
#[no_mangle]
pub static mut D_8011D724: [OnePointCsFull; 3] =
    [{
         let mut init =
             OnePointCsFull{actionFlags: 0x8f as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0x2424 as libc::c_int as s16,
                            timerInit: 0x1 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 60.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 0.0f32,
                                              z: 0.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 10.0f32,
                                              z: -20.0f32,};
                                    init
                                },};
         init
     },
     {
         let mut init =
             OnePointCsFull{actionFlags: 0x81 as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0x2121 as libc::c_int as s16,
                            timerInit: 0x13 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 50.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: -10.0f32,
                                              z: 0.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 0.0f32,
                                              z: 60.0f32,};
                                    init
                                },};
         init
     },
     {
         let mut init =
             OnePointCsFull{actionFlags: 0x12 as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0 as libc::c_int as s16,
                            timerInit: 0x1 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 60.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: -1.0f32,
                                              y: -1.0f32,
                                              z: -1.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: -1.0f32,
                                              y: -1.0f32,
                                              z: -1.0f32,};
                                    init
                                },};
         init
     }];
#[no_mangle]
pub static mut D_8011D79C: [OnePointCsFull; 4] =
    [{
         let mut init =
             OnePointCsFull{actionFlags: 0xcf as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0x2 as libc::c_int as s16,
                            timerInit: 0x1 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 60.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 0.0f32,
                                              z: 0.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 0.0f32,
                                              z: 0.0f32,};
                                    init
                                },};
         init
     },
     {
         let mut init =
             OnePointCsFull{actionFlags: 0xc1 as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0x303 as libc::c_int as s16,
                            timerInit: 0x13 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 45.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: -20.0f32,
                                              z: 0.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: -10.0f32,
                                              z: 5.0f32,};
                                    init
                                },};
         init
     },
     {
         let mut init =
             OnePointCsFull{actionFlags: 0xc1 as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0x303 as libc::c_int as s16,
                            timerInit: 0x9 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 60.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 10.0f32,
                                              z: 0.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 10.0f32,
                                              z: 0.0f32,};
                                    init
                                },};
         init
     },
     {
         let mut init =
             OnePointCsFull{actionFlags: 0x12 as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0 as libc::c_int as s16,
                            timerInit: 0x1 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 60.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: -1.0f32,
                                              y: -1.0f32,
                                              z: -1.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: -1.0f32,
                                              y: -1.0f32,
                                              z: -1.0f32,};
                                    init
                                },};
         init
     }];
#[no_mangle]
pub static mut D_8011D83C: [OnePointCsFull; 2] =
    [{
         let mut init =
             OnePointCsFull{actionFlags: 0x83 as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0x2141 as libc::c_int as s16,
                            timerInit: 0x14 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 45.0f32,
                            lerpStepScale: 0.2f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 0.0f32,
                                              z: 10.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 0.0f32,
                                              z: 10.0f32,};
                                    init
                                },};
         init
     },
     {
         let mut init =
             OnePointCsFull{actionFlags: 0x12 as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0 as libc::c_int as s16,
                            timerInit: 0x1 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 60.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: -1.0f32,
                                              y: -1.0f32,
                                              z: -1.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: -1.0f32,
                                              y: -1.0f32,
                                              z: -1.0f32,};
                                    init
                                },};
         init
     }];
#[no_mangle]
pub static mut D_8011D88C: [OnePointCsFull; 2] =
    [{
         let mut init =
             OnePointCsFull{actionFlags: 0x81 as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0x303 as libc::c_int as s16,
                            timerInit: 0x14 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 45.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 0.0f32,
                                              z: 0.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 0.0f32,
                                              z: 0.0f32,};
                                    init
                                },};
         init
     },
     {
         let mut init =
             OnePointCsFull{actionFlags: 0x12 as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0 as libc::c_int as s16,
                            timerInit: 0x1 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 60.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: -1.0f32,
                                              y: -1.0f32,
                                              z: -1.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: -1.0f32,
                                              y: -1.0f32,
                                              z: -1.0f32,};
                                    init
                                },};
         init
     }];
#[no_mangle]
pub static mut D_8011D8DC: [OnePointCsFull; 3] =
    [{
         let mut init =
             OnePointCsFull{actionFlags: 0x8f as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0x404 as libc::c_int as s16,
                            timerInit: 0x14 as libc::c_int as s16,
                            rollTargetInit: 0x1 as libc::c_int as s16,
                            fovTargetInit: 50.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 5.0f32,
                                              z: 10.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 10.0f32,
                                              z: -80.0f32,};
                                    init
                                },};
         init
     },
     {
         let mut init =
             OnePointCsFull{actionFlags: 0x82 as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0x2121 as libc::c_int as s16,
                            timerInit: 0x5 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 60.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 5.0f32,
                                              z: 0.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 5.0f32,
                                              y: 5.0f32,
                                              z: -200.0f32,};
                                    init
                                },};
         init
     },
     {
         let mut init =
             OnePointCsFull{actionFlags: 0x12 as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0 as libc::c_int as s16,
                            timerInit: 0x1 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 60.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: -1.0f32,
                                              y: -1.0f32,
                                              z: -1.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: -1.0f32,
                                              y: -1.0f32,
                                              z: -1.0f32,};
                                    init
                                },};
         init
     }];
#[no_mangle]
pub static mut D_8011D954: [OnePointCsFull; 4] =
    [{
         let mut init =
             OnePointCsFull{actionFlags: 0xf as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0xc1c1 as libc::c_int as s16,
                            timerInit: 0x14 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 60.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 0.0f32,
                                              z: 50.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 0.0f32,
                                              z: 250.0f32,};
                                    init
                                },};
         init
     },
     {
         let mut init =
             OnePointCsFull{actionFlags: 0x83 as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0x5b1 as libc::c_int as s16,
                            timerInit: 0x5 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 60.0f32,
                            lerpStepScale: 0.1f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 10.0f32,
                                              z: 50.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 10.0f32,
                                              z: 100.0f32,};
                                    init
                                },};
         init
     },
     {
         let mut init =
             OnePointCsFull{actionFlags: 0x82 as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0x2121 as libc::c_int as s16,
                            timerInit: 0x5 as libc::c_int as s16,
                            rollTargetInit: 0x2 as libc::c_int as s16,
                            fovTargetInit: 60.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 10.0f32,
                                              z: 0.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 20.0f32,
                                              z: -150.0f32,};
                                    init
                                },};
         init
     },
     {
         let mut init =
             OnePointCsFull{actionFlags: 0x12 as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0 as libc::c_int as s16,
                            timerInit: 0x1 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 60.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: -1.0f32,
                                              y: -1.0f32,
                                              z: -1.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: -1.0f32,
                                              y: -1.0f32,
                                              z: -1.0f32,};
                                    init
                                },};
         init
     }];
#[no_mangle]
pub static mut D_8011D9F4: [OnePointCsFull; 3] =
    [{
         let mut init =
             OnePointCsFull{actionFlags: 0x8f as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0x504 as libc::c_int as s16,
                            timerInit: 0x14 as libc::c_int as s16,
                            rollTargetInit: 0x2 as libc::c_int as s16,
                            fovTargetInit: 60.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 5.0f32,
                                              z: 50.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 20.0f32,
                                              z: 300.0f32,};
                                    init
                                },};
         init
     },
     {
         let mut init =
             OnePointCsFull{actionFlags: 0x82 as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0x2121 as libc::c_int as s16,
                            timerInit: 0x5 as libc::c_int as s16,
                            rollTargetInit: 0x2 as libc::c_int as s16,
                            fovTargetInit: 60.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 10.0f32,
                                              z: 0.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: 0.0f32,
                                              y: 20.0f32,
                                              z: -150.0f32,};
                                    init
                                },};
         init
     },
     {
         let mut init =
             OnePointCsFull{actionFlags: 0x12 as libc::c_int as u8_0,
                            unk_01: 0xff as libc::c_int as u8_0,
                            initFlags: 0 as libc::c_int as s16,
                            timerInit: 0x1 as libc::c_int as s16,
                            rollTargetInit: 0 as libc::c_int as s16,
                            fovTargetInit: 60.0f32,
                            lerpStepScale: 1.0f32,
                            atTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: -1.0f32,
                                              y: -1.0f32,
                                              z: -1.0f32,};
                                    init
                                },
                            eyeTargetInit:
                                {
                                    let mut init =
                                        Vec3f{x: -1.0f32,
                                              y: -1.0f32,
                                              z: -1.0f32,};
                                    init
                                },};
         init
     }];
#[no_mangle]
pub static mut D_8011DA6C: [Vec3f; 4] =
    [{ let mut init = Vec3f{x: 3050.0f32, y: 700.0f32, z: 0.0f32,}; init },
     {
         let mut init = Vec3f{x: 1755.0f32, y: 3415.0f32, z: -380.0f32,};
         init
     },
     {
         let mut init = Vec3f{x: -3120.0f32, y: 3160.0f32, z: 245.0f32,};
         init
     }, { let mut init = Vec3f{x: 0.0f32, y: -10.0f32, z: 240.0f32,}; init }];
#[no_mangle]
pub static mut D_8011DA9C: [Vec3f; 4] =
    [{ let mut init = Vec3f{x: 3160.0f32, y: 2150.0f32, z: 0.0f32,}; init },
     {
         let mut init = Vec3f{x: 1515.0f32, y: 4130.0f32, z: -835.0f32,};
         init
     },
     {
         let mut init = Vec3f{x: -3040.0f32, y: 4135.0f32, z: 230.0f32,};
         init
     },
     { let mut init = Vec3f{x: -50.0f32, y: 600.0f32, z: -75.0f32,}; init }];
#[no_mangle]
pub static mut D_8011DACC: [f32_0; 4] =
    [1570.0f32, 3680.0f32, 3700.0f32, 395.0f32];
#[no_mangle]
pub static mut D_8011DADC: [f32_0; 4] =
    [320.0f32, 320.0f32, 320.0f32, 0.0f32];
#[no_mangle]
pub static mut D_8011DAEC: [s16; 8] =
    [-(2000 as libc::c_int) as s16, -(1000 as libc::c_int) as s16,
     0 as libc::c_int as s16, 0 as libc::c_int as s16,
     0 as libc::c_int as s16, 0 as libc::c_int as s16,
     0 as libc::c_int as s16, 0 as libc::c_int as s16];
#[no_mangle]
pub static mut D_8011DAFC: [s16; 6] =
    [CAM_SET_NORMAL0 as libc::c_int as s16,
     CAM_SET_NORMAL1 as libc::c_int as s16,
     CAM_SET_NORMAL2 as libc::c_int as s16,
     CAM_SET_DUNGEON0 as libc::c_int as s16,
     CAM_SET_DUNGEON1 as libc::c_int as s16,
     CAM_SET_DUNGEON2 as libc::c_int as s16];
#[no_mangle]
pub static mut D_8015BD7C: *mut GlobalContext =
    0 as *const GlobalContext as *mut GlobalContext;
#[no_mangle]
pub static mut D_8015BD80: DbCamera =
    DbCamera{unk_00: 0,
             at: Vec3f{x: 0., y: 0., z: 0.,},
             eye: Vec3f{x: 0., y: 0., z: 0.,},
             unk_1C: Vec3f{x: 0., y: 0., z: 0.,},
             unk_28: [0; 12],
             unk_34: 0,
             unk_38: 0,
             unk_3C: 0,
             unk_40: 0,
             unk_44: 0,
             fov: 0.,
             roll: 0,
             unk_4E: [0; 2],
             rollDegrees: 0.,
             unk_54: Vec3f{x: 0., y: 0., z: 0.,},
             unk_60: Vec3f{x: 0., y: 0., z: 0.,},
             unk_6C: Vec3f{x: 0., y: 0., z: 0.,},
             unk_78: 0,
             unk_7A: 0,
             sub:
                 DbCameraSub{mode: 0,
                             nFrames: 0,
                             nPoints: 0,
                             unkIdx: 0,
                             unk_08: 0,
                             unk_0A: 0,
                             unk_0C: 0,
                             unk_10: [0; 20],
                             position:
                                 [CutsceneCameraPoint{continueFlag: 0,
                                                      cameraRoll: 0,
                                                      nextPointFrame: 0,
                                                      viewAngle: 0.,
                                                      pos:
                                                          Vec3s{x: 0,
                                                                y: 0,
                                                                z: 0,},};
                                     129],
                             lookAt:
                                 [CutsceneCameraPoint{continueFlag: 0,
                                                      cameraRoll: 0,
                                                      nextPointFrame: 0,
                                                      viewAngle: 0.,
                                                      pos:
                                                          Vec3s{x: 0,
                                                                y: 0,
                                                                z: 0,},};
                                     129],
                             demoCtrlMenu: 0,
                             demoCtrlActionIdx: 0,
                             demoCtrlToggleSwitch: 0,
                             unk_104A: Vec3s{x: 0, y: 0, z: 0,},},};
#[no_mangle]
pub static mut playerFloorPoly: *mut CollisionPoly =
    0 as *const CollisionPoly as *mut CollisionPoly;
/*===============================================================*/
/* *
 * Interpolates along a curve between 0 and 1 with a period of
 * -a <= p <= a at time `b`
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_InterpolateCurve(mut a: f32_0, mut b: f32_0)
 -> f32_0 {
    let mut ret: f32_0 = 0.;
    let mut absB: f32_0 = 0.;
    let mut t: f32_0 = 0.4f32;
    let mut t2: f32_0 = 0.;
    let mut t3: f32_0 = 0.;
    let mut t4: f32_0 = 0.;
    absB = fabsf(b);
    if a < absB {
        ret = 1.0f32
    } else {
        t2 = 1.0f32 - t;
        if a * t2 > absB {
            t3 = b * b * (1.0f32 - t);
            t4 = a * t2 * (a * t2);
            ret = t3 / t4
        } else {
            t3 = (a - absB) * (a - absB) * t;
            t4 = 0.4f32 * a * (0.4f32 * a);
            ret = 1.0f32 - t3 / t4
        }
    }
    return ret;
}
/*
 * Performs linear interpoloation between `cur` and `target`.  If `cur` is within
 * `minDiff` units, The result is rounded up to `target`
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_LERPCeilF(mut target: f32_0, mut cur: f32_0,
                                          mut stepScale: f32_0,
                                          mut minDiff: f32_0) -> f32_0 {
    let mut diff: f32_0 = target - cur;
    let mut step: f32_0 = 0.;
    let mut ret: f32_0 = 0.;
    if fabsf(diff) >= minDiff {
        step = diff * stepScale;
        ret = cur + step
    } else { ret = target }
    return ret;
}
/*
 * Performs linear interpoloation between `cur` and `target`.  If `cur` is within
 * `minDiff` units, The result is rounded down to `cur`
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_LERPFloorF(mut target: f32_0, mut cur: f32_0,
                                           mut stepScale: f32_0,
                                           mut minDiff: f32_0) -> f32_0 {
    let mut diff: f32_0 = target - cur;
    let mut step: f32_0 = 0.;
    let mut ret: f32_0 = 0.;
    if fabsf(diff) >= minDiff {
        step = diff * stepScale;
        ret = cur + step
    } else { ret = cur }
    return ret;
}
/*
 * Performs linear interpoloation between `cur` and `target`.  If `cur` is within
 * `minDiff` units, The result is rounded up to `target`
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_LERPCeilS(mut target: s16, mut cur: s16,
                                          mut stepScale: f32_0,
                                          mut minDiff: s16) -> s16 {
    let mut diff: s16 = (target as libc::c_int - cur as libc::c_int) as s16;
    let mut step: s16 = 0;
    let mut ret: s32 = 0;
    if (if diff as libc::c_int >= 0 as libc::c_int {
            diff as libc::c_int
        } else { -(diff as libc::c_int) }) >= minDiff as libc::c_int {
        step =
            (diff as libc::c_int as libc::c_float * stepScale + 0.5f32) as
                s16;
        ret = cur as libc::c_int + step as libc::c_int
    } else { ret = target as s32 }
    return ret as s16;
}
/*
 * Performs linear interpoloation between `cur` and `target`.  If `cur` is within
 * `minDiff` units, The result is rounded down to `cur`
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_LERPFloorS(mut target: s16, mut cur: s16,
                                           mut stepScale: f32_0,
                                           mut minDiff: s16) -> s16 {
    let mut diff: s16 = (target as libc::c_int - cur as libc::c_int) as s16;
    let mut step: s16 = 0;
    let mut ret: s32 = 0;
    if (if diff as libc::c_int >= 0 as libc::c_int {
            diff as libc::c_int
        } else { -(diff as libc::c_int) }) >= minDiff as libc::c_int {
        step =
            (diff as libc::c_int as libc::c_float * stepScale + 0.5f32) as
                s16;
        ret = cur as libc::c_int + step as libc::c_int
    } else { ret = cur as s32 }
    return ret as s16;
}
/*
 * Performs linear interpoloation between `cur` and `target`.  If `cur` is within
 * `minDiff` units, The result is rounded up to `target`
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_LERPCeilVec3f(mut target: *mut Vec3f,
                                              mut cur: *mut Vec3f,
                                              mut yStepScale: f32_0,
                                              mut xzStepScale: f32_0,
                                              mut minDiff: f32_0) {
    (*cur).x = Camera_LERPCeilF((*target).x, (*cur).x, xzStepScale, minDiff);
    (*cur).y = Camera_LERPCeilF((*target).y, (*cur).y, yStepScale, minDiff);
    (*cur).z = Camera_LERPCeilF((*target).z, (*cur).z, xzStepScale, minDiff);
}
#[no_mangle]
pub unsafe extern "C" fn func_80043ABC(mut camera: *mut Camera) {
    (*camera).yawUpdateRateInv = 100.0f32;
    (*camera).pitchUpdateRateInv =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 7 as libc::c_int) as usize]
            as f32_0;
    (*camera).rUpdateRateInv =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 6 as libc::c_int) as usize]
            as f32_0;
    (*camera).xzOffsetUpdateRate =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 2 as libc::c_int) as usize]
            as libc::c_int as libc::c_float * 0.01f32;
    (*camera).yOffsetUpdateRate =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 3 as libc::c_int) as usize]
            as libc::c_int as libc::c_float * 0.01f32;
    (*camera).fovUpdateRate =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 4 as libc::c_int) as usize]
            as libc::c_int as libc::c_float * 0.01f32;
}
#[no_mangle]
pub unsafe extern "C" fn func_80043B60(mut camera: *mut Camera) {
    (*camera).rUpdateRateInv =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 27 as libc::c_int) as
                              usize] as f32_0;
    (*camera).yawUpdateRateInv =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 27 as libc::c_int) as
                              usize] as f32_0;
    (*camera).pitchUpdateRateInv =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 27 as libc::c_int) as
                              usize] as f32_0;
    (*camera).xzOffsetUpdateRate = 0.001f32;
    (*camera).yOffsetUpdateRate = 0.001f32;
    (*camera).fovUpdateRate = 0.001f32;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Vec3sToVec3f(mut dest: *mut Vec3f,
                                             mut src: *mut Vec3s)
 -> *mut Vec3f {
    let mut copy: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    copy.x = (*src).x as f32_0;
    copy.y = (*src).y as f32_0;
    copy.z = (*src).z as f32_0;
    *dest = copy;
    return dest;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Vec3fVecSphGeoAdd(mut dest: *mut Vec3f,
                                                  mut a: *mut Vec3f,
                                                  mut b: *mut VecSph)
 -> *mut Vec3f {
    let mut copy: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut vecB: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    OLib_VecSphGeoToVec3f(&mut vecB, b);
    copy.x = (*a).x + vecB.x;
    copy.y = (*a).y + vecB.y;
    copy.z = (*a).z + vecB.z;
    *dest = copy;
    return dest;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Vec3fTranslateByUnitVector(mut dest:
                                                               *mut Vec3f,
                                                           mut src:
                                                               *mut Vec3f,
                                                           mut unitVector:
                                                               *mut Vec3f,
                                                           mut uvScale: f32_0)
 -> *mut Vec3f {
    let mut copy: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    copy.x = (*src).x + (*unitVector).x * uvScale;
    copy.y = (*src).y + (*unitVector).y * uvScale;
    copy.z = (*src).z + (*unitVector).z * uvScale;
    *dest = copy;
    return dest;
}
/* *
 * Detects the collision poly between `from` and `to`, places collision info in `to`
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_BGCheckInfo(mut camera: *mut Camera,
                                            mut from: *mut Vec3f,
                                            mut to: *mut CamColChk) -> s32 {
    let mut colCtx: *mut CollisionContext =
        &mut (*(*camera).globalCtx).colCtx;
    let mut toNewPos: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut toPoint: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut fromToNorm: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut floorPolyY: f32_0 = 0.;
    let mut floorPoly: *mut CollisionPoly = 0 as *mut CollisionPoly;
    let mut floorBgId: s32 = 0;
    let mut fromToOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    OLib_Vec3fDiffToVecSphGeo(&mut fromToOffset, from, &mut (*to).pos);
    fromToOffset.r += 8.0f32;
    Camera_Vec3fVecSphGeoAdd(&mut toPoint, from, &mut fromToOffset);
    if BgCheck_CameraLineTest1(colCtx, from, &mut toPoint, &mut toNewPos,
                               &mut (*to).poly, 1 as libc::c_int,
                               1 as libc::c_int, 1 as libc::c_int,
                               -(1 as libc::c_int), &mut (*to).bgId) == 0 {
        // no poly in path.
        OLib_Vec3fDistNormalize(&mut fromToNorm, from, &mut (*to).pos);
        (*to).norm.x = -fromToNorm.x;
        (*to).norm.y = -fromToNorm.y;
        (*to).norm.z = -fromToNorm.z;
        toNewPos = (*to).pos;
        toNewPos.y += 5.0f32;
        floorPolyY =
            BgCheck_CameraRaycastFloor2(colCtx, &mut floorPoly,
                                        &mut floorBgId, &mut toNewPos);
        if (*to).pos.y - floorPolyY > 5.0f32 {
            // if the y distance from the check point to the floor is more than 5 units
            // the point is not colliding with any collision.
            (*to).pos.x += (*to).norm.x;
            (*to).pos.y += (*to).norm.y;
            (*to).pos.z += (*to).norm.z;
            return 0 as libc::c_int
        }
        (*to).poly = floorPoly;
        toNewPos.y = floorPolyY + 1.0f32;
        (*to).bgId = floorBgId
    }
    (*to).norm.x =
        (*(*to).poly).normal.x as libc::c_int as libc::c_float *
            (1.0f32 / 32767.0f32);
    (*to).norm.y =
        (*(*to).poly).normal.y as libc::c_int as libc::c_float *
            (1.0f32 / 32767.0f32);
    (*to).norm.z =
        (*(*to).poly).normal.z as libc::c_int as libc::c_float *
            (1.0f32 / 32767.0f32);
    (*to).pos.x = (*to).norm.x + toNewPos.x;
    (*to).pos.y = (*to).norm.y + toNewPos.y;
    (*to).pos.z = (*to).norm.z + toNewPos.z;
    return floorBgId + 1 as libc::c_int;
}
/* *
 * Detects if there is collision between `from` and `to`
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_BGCheck(mut camera: *mut Camera,
                                        mut from: *mut Vec3f,
                                        mut to: *mut Vec3f) -> s32 {
    let mut toCol: CamColChk =
        CamColChk{pos: Vec3f{x: 0., y: 0., z: 0.,},
                  norm: Vec3f{x: 0., y: 0., z: 0.,},
                  poly: 0 as *mut CollisionPoly,
                  sphNorm: VecSph{r: 0., pitch: 0, yaw: 0,},
                  bgId: 0,};
    let mut bgId: s32 = 0;
    toCol.pos = *to;
    bgId = Camera_BGCheckInfo(camera, from, &mut toCol);
    *to = toCol.pos;
    return bgId;
}
#[no_mangle]
pub unsafe extern "C" fn func_80043F94(mut camera: *mut Camera,
                                       mut from: *mut Vec3f,
                                       mut to: *mut CamColChk) -> s32 {
    let mut colCtx: *mut CollisionContext =
        &mut (*(*camera).globalCtx).colCtx;
    let mut toNewPos: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut toPos: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut fromToNorm: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut playerFloorNormF: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut floorY: f32_0 = 0.;
    let mut floorPoly: *mut CollisionPoly = 0 as *mut CollisionPoly;
    let mut bgId: s32 = 0;
    let mut fromToGeo: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    OLib_Vec3fDiffToVecSphGeo(&mut fromToGeo, from, &mut (*to).pos);
    fromToGeo.r += 8.0f32;
    Camera_Vec3fVecSphGeoAdd(&mut toPos, from, &mut fromToGeo);
    if BgCheck_CameraLineTest1(colCtx, from, &mut toPos, &mut toNewPos,
                               &mut (*to).poly, 1 as libc::c_int,
                               1 as libc::c_int, 1 as libc::c_int,
                               -(1 as libc::c_int), &mut (*to).bgId) == 0 {
        OLib_Vec3fDistNormalize(&mut fromToNorm, from, &mut (*to).pos);
        (*to).norm.x = -fromToNorm.x;
        (*to).norm.y = -fromToNorm.y;
        (*to).norm.z = -fromToNorm.z;
        toNewPos = (*to).pos;
        toNewPos.y += 5.0f32;
        floorY =
            BgCheck_CameraRaycastFloor2(colCtx, &mut floorPoly, &mut bgId,
                                        &mut toNewPos);
        if (*to).pos.y - floorY > 5.0f32 {
            // to is not on the ground or below it.
            (*to).pos.x += (*to).norm.x;
            (*to).pos.y += (*to).norm.y;
            (*to).pos.z += (*to).norm.z;
            return 0 as libc::c_int
        }
        // to is touching the ground, move it up 1 unit.
        (*to).poly = floorPoly;
        toNewPos.y = floorY + 1.0f32;
        (*to).bgId = bgId
    }
    (*to).norm.x =
        (*(*to).poly).normal.x as libc::c_int as libc::c_float *
            (1.0f32 / 32767.0f32);
    (*to).norm.y =
        (*(*to).poly).normal.y as libc::c_int as libc::c_float *
            (1.0f32 / 32767.0f32);
    (*to).norm.z =
        (*(*to).poly).normal.z as libc::c_int as libc::c_float *
            (1.0f32 / 32767.0f32);
    if (*to).norm.y > 0.5f32 || (*to).norm.y < -0.8f32 {
        (*to).pos.x = (*to).norm.x + toNewPos.x;
        (*to).pos.y = (*to).norm.y + toNewPos.y;
        (*to).pos.z = (*to).norm.z + toNewPos.z
    } else if !playerFloorPoly.is_null() {
        playerFloorNormF.x =
            (*playerFloorPoly).normal.x as libc::c_int as libc::c_float *
                (1.0f32 / 32767.0f32);
        playerFloorNormF.y =
            (*playerFloorPoly).normal.y as libc::c_int as libc::c_float *
                (1.0f32 / 32767.0f32);
        playerFloorNormF.z =
            (*playerFloorPoly).normal.z as libc::c_int as libc::c_float *
                (1.0f32 / 32767.0f32);
        if Math3D_LineSegVsPlane(playerFloorNormF.x, playerFloorNormF.y,
                                 playerFloorNormF.z,
                                 (*playerFloorPoly).dist as f32_0, from,
                                 &mut toPos, &mut toNewPos, 1 as libc::c_int)
               != 0 {
            // line is from->to is touching the poly the player is on.
            (*to).norm = playerFloorNormF;
            (*to).poly = playerFloorPoly;
            (*to).bgId = (*camera).bgCheckId as s32;
            (*to).pos.x = (*to).norm.x + toNewPos.x;
            (*to).pos.y = (*to).norm.y + toNewPos.y;
            (*to).pos.z = (*to).norm.z + toNewPos.z
        } else {
            OLib_Vec3fDistNormalize(&mut fromToNorm, from, &mut (*to).pos);
            (*to).norm.x = -fromToNorm.x;
            (*to).norm.y = -fromToNorm.y;
            (*to).norm.z = -fromToNorm.z;
            (*to).pos.x += (*to).norm.x;
            (*to).pos.y += (*to).norm.y;
            (*to).pos.z += (*to).norm.z;
            return 0 as libc::c_int
        }
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn func_80044340(mut camera: *mut Camera,
                                       mut arg1: *mut Vec3f,
                                       mut arg2: *mut Vec3f) {
    let mut sp20: CamColChk =
        CamColChk{pos: Vec3f{x: 0., y: 0., z: 0.,},
                  norm: Vec3f{x: 0., y: 0., z: 0.,},
                  poly: 0 as *mut CollisionPoly,
                  sphNorm: VecSph{r: 0., pitch: 0, yaw: 0,},
                  bgId: 0,};
    let mut unused: Vec3s = Vec3s{x: 0, y: 0, z: 0,};
    sp20.pos = *arg2;
    func_80043F94(camera, arg1, &mut sp20);
    *arg2 = sp20.pos;
}
/* *
 * Checks if `from` to `to` is looking from the outside of a poly towards the front
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_CheckOOB(mut camera: *mut Camera,
                                         mut from: *mut Vec3f,
                                         mut to: *mut Vec3f) -> s32 {
    let mut pad: s32 = 0;
    let mut intersect: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut pad2: s32 = 0;
    let mut bgId: s32 = 0;
    let mut poly: *mut CollisionPoly = 0 as *mut CollisionPoly;
    let mut colCtx: *mut CollisionContext =
        &mut (*(*camera).globalCtx).colCtx;
    poly = 0 as *mut CollisionPoly;
    if BgCheck_CameraLineTest1(colCtx, from, to, &mut intersect, &mut poly,
                               1 as libc::c_int, 1 as libc::c_int,
                               1 as libc::c_int, 0 as libc::c_int, &mut bgId)
           != 0 &&
           CollisionPoly_GetPointDistanceFromPlane(poly, from) < 0.0f32 {
        // if there is a poly between `from` and `to` and the `from` is behind the poly.
        return 1 as libc::c_int
    }
    return 0 as libc::c_int;
}
/* *
 * Gets the floor position underneath `chkPos`, and returns the normal of the floor to `floorNorm`,
 * and bgId to `bgId`.  If no floor is found, then the normal is a flat surface pointing upwards.
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_GetFloorYNorm(mut camera: *mut Camera,
                                              mut floorNorm: *mut Vec3f,
                                              mut chkPos: *mut Vec3f,
                                              mut bgId: *mut s32) -> f32_0 {
    let mut pad: s32 = 0;
    let mut floorPoly: *mut CollisionPoly = 0 as *mut CollisionPoly;
    let mut floorY: f32_0 =
        BgCheck_EntityRaycastFloor3(&mut (*(*camera).globalCtx).colCtx,
                                    &mut floorPoly, bgId, chkPos);
    if floorY == -32000.0f32 {
        // no floor
        (*floorNorm).x = 0.0f32;
        (*floorNorm).y = 1.0f32;
        (*floorNorm).z = 0.0f32
    } else {
        (*floorNorm).x =
            (*floorPoly).normal.x as libc::c_int as libc::c_float *
                (1.0f32 / 32767.0f32);
        (*floorNorm).y =
            (*floorPoly).normal.y as libc::c_int as libc::c_float *
                (1.0f32 / 32767.0f32);
        (*floorNorm).z =
            (*floorPoly).normal.z as libc::c_int as libc::c_float *
                (1.0f32 / 32767.0f32)
    }
    return floorY;
}
/* *
 * Gets the position of the floor from `pos`
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_GetFloorY(mut camera: *mut Camera,
                                          mut pos: *mut Vec3f) -> f32_0 {
    let mut posCheck: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut floorNorm: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut bgId: s32 = 0;
    posCheck = *pos;
    posCheck.y += 80.0f32;
    return Camera_GetFloorYNorm(camera, &mut floorNorm, &mut posCheck,
                                &mut bgId);
}
/* *
 * Gets the position of the floor from `pos`, and if the floor is considered not solid,
 * it checks the next floor below that up to 3 times.  Returns the normal of the floor into `norm`
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_GetFloorYLayer(mut camera: *mut Camera,
                                               mut norm: *mut Vec3f,
                                               mut pos: *mut Vec3f,
                                               mut bgId: *mut s32) -> f32_0 {
    let mut floorPoly: *mut CollisionPoly = 0 as *mut CollisionPoly;
    let mut colCtx: *mut CollisionContext =
        &mut (*(*camera).globalCtx).colCtx;
    let mut floorY: f32_0 = 0.;
    let mut i: s32 = 0;
    i = 3 as libc::c_int;
    while i > 0 as libc::c_int {
        floorY =
            BgCheck_CameraRaycastFloor2(colCtx, &mut floorPoly, bgId, pos);
        if floorY == -32000.0f32 ||
               (*camera).playerGroundY < floorY &&
                   !((*floorPoly).normal.y as libc::c_int as libc::c_float *
                         (1.0f32 / 32767.0f32) > 0.5f32) {
            // no floor, or player is below the floor and floor is not considered steep
            (*norm).x = 0.0f32;
            (*norm).y = 1.0f32;
            (*norm).z = 0.0f32;
            floorY = -32000.0f32;
            break ;
        } else if func_80041D4C(colCtx, floorPoly, *bgId) ==
                      1 as libc::c_int as libc::c_uint {
            // floor is not solid, check below that floor.
            (*pos).y = floorY - 10.0f32;
            i -= 1
        } else {
            (*norm).x =
                (*floorPoly).normal.x as libc::c_int as libc::c_float *
                    (1.0f32 / 32767.0f32);
            (*norm).y =
                (*floorPoly).normal.y as libc::c_int as libc::c_float *
                    (1.0f32 / 32767.0f32);
            (*norm).z =
                (*floorPoly).normal.z as libc::c_int as libc::c_float *
                    (1.0f32 / 32767.0f32);
            break ;
        }
    }
    if i == 0 as libc::c_int {
        osSyncPrintf(b"\x1b[43;30mcamera: foward check: too many layer!\n\x1b[m\x00"
                         as *const u8 as *const libc::c_char);
    }
    return floorY;
}
/* *
 * Returns the CameraSettingType of the camera at index `camDataIdx`
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_GetCamDataSetting(mut camera: *mut Camera,
                                                  mut camDataIdx: s32)
 -> s16 {
    return func_80041A4C(&mut (*(*camera).globalCtx).colCtx,
                         camDataIdx as u32_0, 50 as libc::c_int) as s16;
}
/* *
 * Returns the scene camera info for the current camera data index
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_GetCamBGData(mut camera: *mut Camera)
 -> *mut Vec3s {
    return func_80041C10(&mut (*(*camera).globalCtx).colCtx,
                         (*camera).camDataIdx as s32, 50 as libc::c_int);
}
/* *
 * Gets the scene's camera index for the poly `poly`, returns -1 if
 * there is no camera data for that poly.
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_GetDataIdxForPoly(mut camera: *mut Camera,
                                                  mut bgId: *mut s32,
                                                  mut poly:
                                                      *mut CollisionPoly)
 -> s32 {
    let mut camDataIdx: s32 = 0; // unused.
    let mut playerPosRot: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut ret: s32 = 0;
    Actor_GetWorldPosShapeRot(&mut playerPosRot,
                              &mut (*(*camera).player).actor);
    camDataIdx =
        SurfaceType_GetCamDataIndex(&mut (*(*camera).globalCtx).colCtx, poly,
                                    *bgId) as s32;
    if func_80041A4C(&mut (*(*camera).globalCtx).colCtx, camDataIdx as u32_0,
                     *bgId) as libc::c_int == CAM_SET_NONE as libc::c_int {
        ret = -(1 as libc::c_int)
    } else { ret = camDataIdx }
    return ret;
}
/* *
 * Returns the scene camera info for the floor under the player.
 * If there is no floor then there is no camera data, returns the number of
 * pieces of data there are in `dataCnt`
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_GetCamBgDataUnderPlayer(mut camera:
                                                            *mut Camera,
                                                        mut dataCnt:
                                                            *mut u16_0)
 -> *mut Vec3s {
    let mut floorPoly: *mut CollisionPoly = 0 as *mut CollisionPoly;
    let mut pad: s32 = 0;
    let mut bgId: s32 = 0;
    let mut playerPosShape: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    Actor_GetWorldPosShapeRot(&mut playerPosShape,
                              &mut (*(*camera).player).actor);
    playerPosShape.pos.y += Player_GetHeight((*camera).player);
    if BgCheck_EntityRaycastFloor3(&mut (*(*camera).globalCtx).colCtx,
                                   &mut floorPoly, &mut bgId,
                                   &mut playerPosShape.pos) == -32000.0f32 {
        // no floor
        return 0 as *mut Vec3s
    }
    *dataCnt =
        SurfaceType_GetNumCameras(&mut (*(*camera).globalCtx).colCtx,
                                  floorPoly, bgId);
    return SurfaceType_GetCamPosData(&mut (*(*camera).globalCtx).colCtx,
                                     floorPoly, bgId);
}
/* *
 * Gets the Camera information for the water box the player is in.
 * Returns -1 if the player is not in a water box, or does not have a swimming state.
 * Returns -2 if there is no camera index for the water box.
 * Returns the camera data index otherwise.
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_GetWaterBoxDataIdx(mut camera: *mut Camera,
                                                   mut waterY: *mut f32_0)
 -> s32 {
    let mut playerPosShape: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut waterBox: *mut WaterBox = 0 as *mut WaterBox;
    let mut ret: s32 = 0;
    Actor_GetWorldPosShapeRot(&mut playerPosShape,
                              &mut (*(*camera).player).actor);
    *waterY = playerPosShape.pos.y;
    if WaterBox_GetSurface1((*camera).globalCtx,
                            &mut (*(*camera).globalCtx).colCtx,
                            playerPosShape.pos.x, playerPosShape.pos.z,
                            waterY, &mut waterBox) == 0 {
        // player's position is not in a water box.
        *waterY = -32000.0f32;
        return -(1 as libc::c_int)
    }
    if (*(*camera).player).stateFlags1 &
           0x8000000 as libc::c_int as libc::c_uint == 0 {
        // player is not swimming
        *waterY = -32000.0f32;
        return -(1 as libc::c_int)
    }
    ret =
        WaterBox_GetCamDataIndex(&mut (*(*camera).globalCtx).colCtx, waterBox)
            as s32;
    if ret <= 0 as libc::c_int ||
           WaterBox_GetCameraSType(&mut (*(*camera).globalCtx).colCtx,
                                   waterBox) as libc::c_int <=
               0 as libc::c_int {
        // no camera data idx, or no CameraSettingType
        return -(2 as libc::c_int)
    }
    return ret;
}
/* *
 * Checks if `chkPos` is inside a waterbox. If there is no water box below `chkPos`
 * or if `chkPos` is above the water surface, return BGCHECK_Y_MIN, output
 * environment properites to `envProp` if `chkPos` is inside the waterbox.
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_GetWaterSurface(mut camera: *mut Camera,
                                                mut chkPos: *mut Vec3f,
                                                mut envProp: *mut s32)
 -> f32_0 {
    let mut playerPosRot: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut waterY: f32_0 = 0.;
    let mut waterBox: *mut WaterBox = 0 as *mut WaterBox;
    Actor_GetWorldPosShapeRot(&mut playerPosRot,
                              &mut (*(*camera).player).actor);
    waterY = playerPosRot.pos.y;
    if WaterBox_GetSurface1((*camera).globalCtx,
                            &mut (*(*camera).globalCtx).colCtx, (*chkPos).x,
                            (*chkPos).z, &mut waterY, &mut waterBox) == 0 {
        // chkPos is not within the x/z boundaries of a water box.
        return -32000.0f32
    }
    if waterY < (*chkPos).y {
        // the water's y position is below the check position
        // meaning the position is NOT in the water.
        return -32000.0f32
    }
    *envProp =
        WaterBox_GetLightSettingIndex(&mut (*(*camera).globalCtx).colCtx,
                                      waterBox) as s32;
    return waterY;
}
/* *
 * Calculates the angle between points `from` and `to`
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_XZAngle(mut to: *mut Vec3f,
                                        mut from: *mut Vec3f) -> s16 {
    return (Math_FAtan2F((*from).x - (*to).x, (*from).z - (*to).z) *
                (180.0f32 / 3.14159265358979323846f32) * 182.04167f32 +
                0.5f32) as s16;
}
#[no_mangle]
pub unsafe extern "C" fn func_80044ADC(mut camera: *mut Camera, mut yaw: s16,
                                       mut arg2: s16) -> s16 {
    static mut D_8015CE50: f32_0 = 0.;
    static mut D_8015CE54: f32_0 = 0.;
    static mut D_8015CE58: CamColChk =
        CamColChk{pos: Vec3f{x: 0., y: 0., z: 0.,},
                  norm: Vec3f{x: 0., y: 0., z: 0.,},
                  poly: 0 as *mut CollisionPoly,
                  sphNorm: VecSph{r: 0., pitch: 0, yaw: 0,},
                  bgId: 0,};
    let mut playerPos: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut rotatedPos: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut floorNorm: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut temp_f2: f32_0 = 0.;
    let mut temp_s0: s16 = 0;
    let mut temp_s1: s16 = 0;
    let mut phi_f18: f32_0 = 0.;
    let mut sinYaw: f32_0 = 0.;
    let mut cosYaw: f32_0 = 0.;
    let mut bgId: s32 = 0;
    let mut sp30: f32_0 = 0.;
    let mut sp2C: f32_0 = 0.;
    let mut phi_f16: f32_0 = 0.;
    let mut playerHeight: f32_0 = 0.;
    sinYaw = Math_SinS(yaw);
    cosYaw = Math_CosS(yaw);
    playerHeight = Player_GetHeight((*camera).player);
    temp_f2 =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 19 as libc::c_int) as
                              usize] as libc::c_int as libc::c_float * 0.01f32
            * playerHeight;
    sp30 =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 17 as libc::c_int) as
                              usize] as libc::c_int as libc::c_float * 0.01f32
            * playerHeight;
    sp2C =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 18 as libc::c_int) as
                              usize] as libc::c_int as libc::c_float * 0.01f32
            * playerHeight;
    playerPos.x = (*camera).playerPosRot.pos.x;
    playerPos.y = (*camera).playerGroundY + temp_f2;
    playerPos.z = (*camera).playerPosRot.pos.z;
    rotatedPos.x = playerPos.x + sp30 * sinYaw;
    rotatedPos.y = playerPos.y;
    rotatedPos.z = playerPos.z + sp30 * cosYaw;
    if arg2 as libc::c_int != 0 ||
           (*(*camera).globalCtx).state.frames.wrapping_rem(2 as libc::c_int
                                                                as
                                                                libc::c_uint)
               == 0 as libc::c_int as libc::c_uint {
        D_8015CE58.pos.x = playerPos.x + sp2C * sinYaw;
        D_8015CE58.pos.y = playerPos.y;
        D_8015CE58.pos.z = playerPos.z + sp2C * cosYaw;
        Camera_BGCheckInfo(camera, &mut playerPos, &mut D_8015CE58);
        if arg2 != 0 {
            D_8015CE54 = (*camera).playerGroundY;
            D_8015CE50 = D_8015CE54
        }
    } else {
        sp2C = OLib_Vec3fDistXZ(&mut playerPos, &mut D_8015CE58.pos);
        D_8015CE58.pos.x += D_8015CE58.norm.x * 5.0f32;
        D_8015CE58.pos.y += D_8015CE58.norm.y * 5.0f32;
        D_8015CE58.pos.z += D_8015CE58.norm.z * 5.0f32;
        if sp2C < sp30 {
            sp30 = sp2C;
            D_8015CE54 =
                Camera_GetFloorYLayer(camera, &mut floorNorm,
                                      &mut D_8015CE58.pos, &mut bgId);
            D_8015CE50 = D_8015CE54
        } else {
            D_8015CE50 =
                Camera_GetFloorYLayer(camera, &mut floorNorm, &mut rotatedPos,
                                      &mut bgId);
            D_8015CE54 =
                Camera_GetFloorYLayer(camera, &mut floorNorm,
                                      &mut D_8015CE58.pos, &mut bgId)
        }
        if D_8015CE50 == -32000.0f32 { D_8015CE50 = (*camera).playerGroundY }
        if D_8015CE54 == -32000.0f32 { D_8015CE54 = D_8015CE50 }
    }
    phi_f16 =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 20 as libc::c_int) as
                              usize] as libc::c_int as libc::c_float * 0.01f32
            * (D_8015CE50 - (*camera).playerGroundY);
    phi_f18 =
        (1.0f32 -
             (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                    16 as libc::c_int + 20 as libc::c_int) as
                                   usize] as libc::c_int as libc::c_float *
                 0.01f32) * (D_8015CE54 - (*camera).playerGroundY);
    temp_s0 =
        (Math_FAtan2F(phi_f16, sp30) * (180.0f32 / 3.14159265358979323846f32)
             * 182.04167f32 + 0.5f32) as s16;
    temp_s1 =
        (Math_FAtan2F(phi_f18, sp2C) * (180.0f32 / 3.14159265358979323846f32)
             * 182.04167f32 + 0.5f32) as s16;
    return (temp_s0 as libc::c_int + temp_s1 as libc::c_int) as s16;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_CalcUpFromPitchYawRoll(mut dest: *mut Vec3f,
                                                       mut pitch: s16,
                                                       mut yaw: s16,
                                                       mut roll: s16)
 -> *mut Vec3f {
    let mut sinPitch: f32_0 = 0.;
    let mut cosPitch: f32_0 = 0.;
    let mut sinYaw: f32_0 = 0.;
    let mut cosYaw: f32_0 = 0.;
    let mut sinNegRoll: f32_0 = 0.;
    let mut cosNegRoll: f32_0 = 0.;
    let mut spA4: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut pad: f32_0 = 0.;
    let mut sp54: f32_0 = 0.;
    let mut sp4C: f32_0 = 0.;
    let mut cosPitchCosYawSinRoll: f32_0 = 0.;
    let mut negSinPitch: f32_0 = 0.;
    let mut temp_f10_2: f32_0 = 0.;
    let mut cosPitchcosYaw: f32_0 = 0.;
    let mut temp_f14: f32_0 = 0.;
    let mut negSinPitchSinYaw: f32_0 = 0.;
    let mut negSinPitchCosYaw: f32_0 = 0.;
    let mut cosPitchSinYaw: f32_0 = 0.;
    let mut temp_f4_2: f32_0 = 0.;
    let mut temp_f6: f32_0 = 0.;
    let mut temp_f8: f32_0 = 0.;
    let mut temp_f8_2: f32_0 = 0.;
    let mut temp_f8_3: f32_0 = 0.;
    sinPitch = Math_SinS(pitch);
    cosPitch = Math_CosS(pitch);
    sinYaw = Math_SinS(yaw);
    cosYaw = Math_CosS(yaw);
    negSinPitch = -sinPitch;
    sinNegRoll = Math_SinS(-(roll as libc::c_int) as s16);
    cosNegRoll = Math_CosS(-(roll as libc::c_int) as s16);
    negSinPitchSinYaw = negSinPitch * sinYaw;
    temp_f14 = 1.0f32 - cosNegRoll;
    cosPitchSinYaw = cosPitch * sinYaw;
    sp54 = cosPitchSinYaw * cosPitchSinYaw;
    sp4C = cosPitchSinYaw * sinPitch * temp_f14;
    cosPitchcosYaw = cosPitch * cosYaw;
    temp_f4_2 = (1.0f32 - sp54) * cosNegRoll + sp54;
    cosPitchCosYawSinRoll = cosPitchcosYaw * sinNegRoll;
    negSinPitchCosYaw = negSinPitch * cosYaw;
    temp_f6 = cosPitchcosYaw * cosPitchSinYaw * temp_f14;
    temp_f10_2 = sinPitch * sinNegRoll;
    spA4.x =
        negSinPitchSinYaw * temp_f4_2 +
            cosPitch * (sp4C - cosPitchCosYawSinRoll) +
            negSinPitchCosYaw * (temp_f6 + temp_f10_2);
    sp54 = sinPitch * sinPitch;
    temp_f4_2 = sinPitch * cosPitchcosYaw * temp_f14;
    temp_f8_3 = cosPitchSinYaw * sinNegRoll;
    temp_f8 = sp4C + cosPitchCosYawSinRoll;
    spA4.y =
        negSinPitchSinYaw * temp_f8 +
            cosPitch * ((1.0f32 - sp54) * cosNegRoll + sp54) +
            negSinPitchCosYaw * (temp_f4_2 - temp_f8_3);
    temp_f8_2 = temp_f6 - temp_f10_2;
    spA4.z =
        negSinPitchSinYaw * temp_f8_2 + cosPitch * (temp_f4_2 + temp_f8_3) +
            negSinPitchCosYaw *
                ((1.0f32 - cosPitchcosYaw * cosPitchcosYaw) * cosNegRoll +
                     cosPitchcosYaw * cosPitchcosYaw);
    *dest = spA4;
    return dest;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_ClampLERPScale(mut camera: *mut Camera,
                                               mut maxLERPScale: f32_0)
 -> f32_0 {
    let mut ret: f32_0 = 0.;
    if (*camera).atLERPStepScale <
           (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 41 as libc::c_int) as
                                 usize] as libc::c_int as libc::c_float *
               0.01f32 {
        ret =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 41 as libc::c_int) as
                                  usize] as libc::c_int as libc::c_float *
                0.01f32
    } else if (*camera).atLERPStepScale >= maxLERPScale {
        ret = maxLERPScale
    } else {
        ret =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 42 as libc::c_int) as
                                  usize] as libc::c_int as libc::c_float *
                0.01f32 * (*camera).atLERPStepScale
    }
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_CopyModeValuesToPREG(mut camera: *mut Camera,
                                                     mut mode: s16) {
    let mut values: *mut CameraModeValue = 0 as *mut CameraModeValue;
    let mut valueP: *mut CameraModeValue = 0 as *mut CameraModeValue;
    let mut i: s32 = 0;
    if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 82 as libc::c_int) as usize]
           != 0 {
        osSyncPrintf(b"camera: res: stat (%d/%d/%d)\n\x00" as *const u8 as
                         *const libc::c_char,
                     (*camera).thisIdx as libc::c_int,
                     (*camera).setting as libc::c_int, mode as libc::c_int);
    }
    values =
        (*sCameraSettings[(*camera).setting as
                              usize].cameraModes.offset(mode as
                                                            isize)).values;
    i = 0 as libc::c_int;
    while i <
              (*sCameraSettings[(*camera).setting as
                                    usize].cameraModes.offset(mode as
                                                                  isize)).valueCnt
                  as libc::c_int {
        valueP = &mut *values.offset(i as isize) as *mut CameraModeValue;
        (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int +
                               (*valueP).param as libc::c_int) as usize] =
            (*valueP).val;
        if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 82 as libc::c_int) as
                                 usize] != 0 {
            osSyncPrintf(b"camera: res: PREG(%02d) = %d\n\x00" as *const u8 as
                             *const libc::c_char,
                         (*valueP).param as libc::c_int,
                         (*valueP).val as libc::c_int);
        }
        i += 1
    }
    (*camera).animState = 0 as libc::c_int as s16;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_CopyPREGToModeValues(mut camera: *mut Camera)
 -> s32 {
    let mut values: *mut CameraModeValue =
        (*sCameraSettings[(*camera).setting as
                              usize].cameraModes.offset((*camera).mode as
                                                            isize)).values;
    let mut valueP: *mut CameraModeValue = 0 as *mut CameraModeValue;
    let mut i: s32 = 0;
    i = 0 as libc::c_int;
    while i <
              (*sCameraSettings[(*camera).setting as
                                    usize].cameraModes.offset((*camera).mode
                                                                  as
                                                                  isize)).valueCnt
                  as libc::c_int {
        valueP = &mut *values.offset(i as isize) as *mut CameraModeValue;
        (*valueP).val =
            (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int +
                                   (*valueP).param as libc::c_int) as usize];
        if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 82 as libc::c_int) as
                                 usize] != 0 {
            osSyncPrintf(b"camera: res: %d = PREG(%02d)\n\x00" as *const u8 as
                             *const libc::c_char,
                         (*valueP).val as libc::c_int,
                         (*valueP).param as libc::c_int);
        }
        i += 1
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_UpdateInterface(mut flags: s16) {
    let mut interfaceAlpha: s16 = 0;
    if flags as libc::c_int & 0xf000 as libc::c_int != 0xf000 as libc::c_int {
        match flags as libc::c_int & 0x7000 as libc::c_int {
            4096 => { sCameraShrinkWindowVal = 0x1a as libc::c_int }
            8192 => { sCameraShrinkWindowVal = 0x1b as libc::c_int }
            12288 => { sCameraShrinkWindowVal = 0x20 as libc::c_int }
            _ => { sCameraShrinkWindowVal = 0 as libc::c_int }
        }
        if flags as libc::c_int & 0x8000 as libc::c_int != 0 {
            ShrinkWindow_SetCurrentVal(sCameraShrinkWindowVal);
        } else { ShrinkWindow_SetVal(sCameraShrinkWindowVal); }
    }
    if flags as libc::c_int & 0xf00 as libc::c_int != 0xf00 as libc::c_int {
        interfaceAlpha =
            ((flags as libc::c_int & 0xf00 as libc::c_int) >>
                 8 as libc::c_int) as s16;
        if interfaceAlpha as libc::c_int == 0 as libc::c_int {
            interfaceAlpha = 0x32 as libc::c_int as s16
        }
        if interfaceAlpha as libc::c_int != sCameraInterfaceAlpha {
            sCameraInterfaceAlpha = interfaceAlpha as s32;
            Interface_ChangeAlpha(sCameraInterfaceAlpha as u16_0);
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn Camera_BGCheckCorner(mut dst: *mut Vec3f,
                                              mut linePointA: *mut Vec3f,
                                              mut linePointB: *mut Vec3f,
                                              mut pointAColChk:
                                                  *mut CamColChk,
                                              mut pointBColChk:
                                                  *mut CamColChk)
 -> *mut Vec3f {
    let mut closestPoint: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    if func_800427B4((*pointAColChk).poly, (*pointBColChk).poly, linePointA,
                     linePointB, &mut closestPoint) == 0 {
        osSyncPrintf(b"\x1b[43;30mcamera: corner check no cross point %x %x\n\x1b[m\x00"
                         as *const u8 as *const libc::c_char, pointAColChk,
                     pointBColChk);
        *dst = (*pointAColChk).pos;
        return dst
    }
    *dst = closestPoint;
    return dst;
}
/* *
 * Checks collision between at and eyeNext, if `checkEye` is set, if there is no collsion between
 * eyeNext->at, then eye->at is also checked.
 * Returns:
 * 0 if no collsion is found between at->eyeNext
 * 2 if the angle between the polys is between 60 degrees and 120 degrees
 * 3 ?
 * 6 if the angle between the polys is greater than 120 degrees
 */
#[no_mangle]
pub unsafe extern "C" fn func_80045508(mut camera: *mut Camera,
                                       mut diffSph: *mut VecSph,
                                       mut eyeChk: *mut CamColChk,
                                       mut atChk: *mut CamColChk,
                                       mut checkEye: s16) -> s32 {
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut eyePos: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut atEyeBgId: s32 = 0;
    let mut eyeAtBgId: s32 = 0;
    let mut ret: s32 = 0;
    let mut cosEyeAt: f32_0 = 0.;
    (*eyeChk).pos = (*camera).eyeNext;
    ret = 0 as libc::c_int;
    atEyeBgId = Camera_BGCheckInfo(camera, at, eyeChk);
    if atEyeBgId != 0 as libc::c_int {
        // collision found between at->eye
        (*atChk).pos = (*camera).at;
        OLib_Vec3fToVecSphGeo(&mut (*eyeChk).sphNorm, &mut (*eyeChk).norm);
        if (*eyeChk).sphNorm.pitch as libc::c_int >= 0x2ee1 as libc::c_int {
            (*eyeChk).sphNorm.yaw = (*diffSph).yaw
        }
        eyeAtBgId = Camera_BGCheckInfo(camera, eyeNext, atChk);
        if eyeAtBgId == 0 as libc::c_int {
            // no collision from eyeNext->at
            if checkEye as libc::c_int & 1 as libc::c_int != 0 {
                (*atChk).pos = *at;
                eyePos = *eye;
                if Camera_BGCheckInfo(camera, &mut eyePos, atChk) ==
                       0 as libc::c_int {
                    // no collision from eye->at
                    return 3 as libc::c_int
                } else {
                    if (*eyeChk).poly == (*atChk).poly {
                        // at->eye and eye->at is the same poly
                        return 3 as libc::c_int
                    }
                }
            } else { return 3 as libc::c_int }
        } else if (*eyeChk).poly == (*atChk).poly {
            // at->eyeNext and eyeNext->at is the same poly
            return 3 as libc::c_int
        }
        OLib_Vec3fToVecSphGeo(&mut (*atChk).sphNorm, &mut (*atChk).norm);
        if (*atChk).sphNorm.pitch as libc::c_int >= 0x2ee1 as libc::c_int {
            (*atChk).sphNorm.yaw =
                ((*diffSph).yaw as libc::c_int - 0x7fff as libc::c_int) as s16
        }
        if atEyeBgId != eyeAtBgId {
            // different bgIds for at->eye[Next] and eye[Next]->at
            ret = 3 as libc::c_int
        } else {
            cosEyeAt = Math3D_Cos(&mut (*eyeChk).norm, &mut (*atChk).norm);
            if cosEyeAt < -0.5f32 {
                ret = 6 as libc::c_int
            } else if cosEyeAt > 0.5f32 {
                ret = 3 as libc::c_int
            } else { ret = 2 as libc::c_int }
        }
    }
    return ret;
}
/* *
 * Calculates how much to adjust the camera at's y value when on a slope.
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_CalcSlopeYAdj(mut floorNorm: *mut Vec3f,
                                              mut playerYRot: s16,
                                              mut eyeAtYaw: s16,
                                              mut adjAmt: f32_0) -> f32_0 {
    let mut tmp: f32_0 = 0.;
    let mut floorNormSph: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    OLib_Vec3fToVecSphGeo(&mut floorNormSph, floorNorm);
    tmp =
        Math_CosS(floorNormSph.pitch) *
            Math_CosS((playerYRot as libc::c_int -
                           floorNormSph.yaw as libc::c_int) as s16);
    return fabsf(tmp) * adjAmt *
               Math_CosS((playerYRot as libc::c_int - eyeAtYaw as libc::c_int)
                             as s16);
}
/* *
 * Calculates new at vector for the camera pointing in `eyeAtDir`
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_CalcAtDefault(mut camera: *mut Camera,
                                              mut eyeAtDir: *mut VecSph,
                                              mut extraYOffset: f32_0,
                                              mut calcSlope: s16) -> s32 {
    let mut at: *mut Vec3f = &mut (*camera).at; // unused
    let mut posOffsetTarget: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut atTarget: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut pad2: s32 = 0;
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut yOffset: f32_0 = 0.;
    yOffset = Player_GetHeight((*camera).player);
    posOffsetTarget.x = 0.0f32;
    posOffsetTarget.y = yOffset + extraYOffset;
    posOffsetTarget.z = 0.0f32;
    if calcSlope != 0 {
        posOffsetTarget.y -=
            OLib_ClampMaxDist(Camera_CalcSlopeYAdj(&mut (*camera).floorNorm,
                                                   (*playerPosRot).rot.y,
                                                   (*eyeAtDir).yaw,
                                                   (*gGameInfo).data[(2 as
                                                                          libc::c_int
                                                                          *
                                                                          6 as
                                                                              libc::c_int
                                                                          *
                                                                          16
                                                                              as
                                                                              libc::c_int
                                                                          +
                                                                          9 as
                                                                              libc::c_int)
                                                                         as
                                                                         usize]
                                                       as f32_0), yOffset)
    }
    Camera_LERPCeilVec3f(&mut posOffsetTarget, &mut (*camera).posOffset,
                         (*camera).yOffsetUpdateRate,
                         (*camera).xzOffsetUpdateRate, 0.1f32);
    atTarget.x = (*playerPosRot).pos.x + (*camera).posOffset.x;
    atTarget.y = (*playerPosRot).pos.y + (*camera).posOffset.y;
    atTarget.z = (*playerPosRot).pos.z + (*camera).posOffset.z;
    Camera_LERPCeilVec3f(&mut atTarget, at, (*camera).atLERPStepScale,
                         (*camera).atLERPStepScale, 0.2f32);
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn func_800458D4(mut camera: *mut Camera,
                                       mut eyeAtDir: *mut VecSph,
                                       mut arg2: f32_0, mut arg3: *mut f32_0,
                                       mut arg4: s16) -> s32 {
    let mut phi_f2: f32_0 = 0.;
    let mut posOffsetTarget: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut atTarget: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut eyeAtAngle: f32_0 = 0.;
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut deltaY: f32_0 = 0.;
    let mut pad: [s32; 2] = [0; 2];
    posOffsetTarget.y = Player_GetHeight((*camera).player) + arg2;
    posOffsetTarget.x = 0.0f32;
    posOffsetTarget.z = 0.0f32;
    if arg4 != 0 {
        posOffsetTarget.y -=
            Camera_CalcSlopeYAdj(&mut (*camera).floorNorm,
                                 (*playerPosRot).rot.y, (*eyeAtDir).yaw,
                                 (*gGameInfo).data[(2 as libc::c_int *
                                                        6 as libc::c_int *
                                                        16 as libc::c_int +
                                                        9 as libc::c_int) as
                                                       usize] as f32_0)
    }
    deltaY = (*playerPosRot).pos.y - *arg3;
    eyeAtAngle =
        Math_FAtan2F(deltaY,
                     OLib_Vec3fDistXZ(&mut (*camera).at, &mut (*camera).eye));
    if eyeAtAngle >
           (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 32 as libc::c_int) as
                                 usize] as libc::c_int as libc::c_float *
               (3.14159265358979323846f32 / 180.0f32) {
        phi_f2 =
            1.0f32 -
                sinf(eyeAtAngle -
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                32 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float *
                             (3.14159265358979323846f32 / 180.0f32))
    } else if eyeAtAngle <
                  (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                         16 as libc::c_int +
                                         33 as libc::c_int) as usize] as
                      libc::c_int as libc::c_float *
                      (3.14159265358979323846f32 / 180.0f32) {
        phi_f2 =
            1.0f32 -
                sinf((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                            16 as libc::c_int +
                                            33 as libc::c_int) as usize] as
                         libc::c_int as libc::c_float *
                         (3.14159265358979323846f32 / 180.0f32) - eyeAtAngle)
    } else { phi_f2 = 1.0f32 }
    posOffsetTarget.y -= deltaY * phi_f2;
    Camera_LERPCeilVec3f(&mut posOffsetTarget, &mut (*camera).posOffset,
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                29 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32,
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                30 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32,
                         0.1f32);
    atTarget.x = (*playerPosRot).pos.x + (*camera).posOffset.x;
    atTarget.y = (*playerPosRot).pos.y + (*camera).posOffset.y;
    atTarget.z = (*playerPosRot).pos.z + (*camera).posOffset.z;
    Camera_LERPCeilVec3f(&mut atTarget, &mut (*camera).at,
                         (*camera).atLERPStepScale, (*camera).atLERPStepScale,
                         0.2f32);
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn func_80045B08(mut camera: *mut Camera,
                                       mut eyeAtDir: *mut VecSph,
                                       mut yExtra: f32_0, mut arg3: s16)
 -> s32 {
    let mut phi_f2: f32_0 = 0.;
    let mut posOffsetTarget: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut atTarget: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut sp38: f32_0 = 0.;
    let mut temp_ret: f32_0 = 0.;
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    posOffsetTarget.y = Player_GetHeight((*camera).player) + yExtra;
    posOffsetTarget.x = 0.0f32;
    posOffsetTarget.z = 0.0f32;
    temp_ret = Math_SinS(arg3);
    if temp_ret < 0.0f32 {
        phi_f2 =
            Math_CosS(((*playerPosRot).rot.y as libc::c_int -
                           (*eyeAtDir).yaw as libc::c_int) as s16)
    } else {
        phi_f2 =
            -Math_CosS(((*playerPosRot).rot.y as libc::c_int -
                            (*eyeAtDir).yaw as libc::c_int) as s16)
    }
    posOffsetTarget.y -=
        temp_ret * phi_f2 *
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 9 as libc::c_int) as
                                  usize] as libc::c_int as libc::c_float;
    Camera_LERPCeilVec3f(&mut posOffsetTarget, &mut (*camera).posOffset,
                         (*camera).yOffsetUpdateRate,
                         (*camera).xzOffsetUpdateRate, 0.1f32);
    atTarget.x = (*playerPosRot).pos.x + (*camera).posOffset.x;
    atTarget.y = (*playerPosRot).pos.y + (*camera).posOffset.y;
    atTarget.z = (*playerPosRot).pos.z + (*camera).posOffset.z;
    Camera_LERPCeilVec3f(&mut atTarget, &mut (*camera).at,
                         (*camera).atLERPStepScale, (*camera).atLERPStepScale,
                         0.2f32);
    return 1 as libc::c_int;
}
/* *
 * Adjusts the camera's at position for Camera_Parallel1
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_CalcAtForParallel(mut camera: *mut Camera,
                                                  mut arg1: *mut VecSph,
                                                  mut arg2: f32_0,
                                                  mut arg3: *mut f32_0,
                                                  mut arg4: s16) -> s32 {
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut posOffsetTarget: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut atTarget: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut temp_f2: f32_0 = 0.;
    let mut phi_f16: f32_0 = 0.;
    let mut sp54: f32_0 = 0.;
    let mut phi_f20: f32_0 = 0.;
    let mut temp_f0_4: f32_0 = 0.;
    temp_f0_4 = Player_GetHeight((*camera).player);
    posOffsetTarget.x = 0.0f32;
    posOffsetTarget.y = temp_f0_4 + arg2;
    posOffsetTarget.z = 0.0f32;
    if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 76 as libc::c_int) as usize]
           as libc::c_int != 0 && arg4 as libc::c_int != 0 {
        posOffsetTarget.y -=
            Camera_CalcSlopeYAdj(&mut (*camera).floorNorm,
                                 (*playerPosRot).rot.y, (*arg1).yaw,
                                 (*gGameInfo).data[(2 as libc::c_int *
                                                        6 as libc::c_int *
                                                        16 as libc::c_int +
                                                        9 as libc::c_int) as
                                                       usize] as f32_0)
    }
    if (*camera).playerGroundY == (*camera).playerPosRot.pos.y ||
           (*(*camera).player).actor.gravity > -0.1f32 ||
           (*(*camera).player).stateFlags1 &
               0x200000 as libc::c_int as libc::c_uint != 0 {
        *arg3 =
            Camera_LERPCeilF((*playerPosRot).pos.y, *arg3,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    43 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32, 0.1f32);
        phi_f20 = (*playerPosRot).pos.y - *arg3;
        posOffsetTarget.y -= phi_f20;
        Camera_LERPCeilVec3f(&mut posOffsetTarget, &mut (*camera).posOffset,
                             (*camera).yOffsetUpdateRate,
                             (*camera).xzOffsetUpdateRate, 0.1f32);
    } else {
        if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 75 as libc::c_int) as
                                 usize] == 0 {
            phi_f20 = (*playerPosRot).pos.y - *arg3;
            sp54 = OLib_Vec3fDistXZ(at, &mut (*camera).eye);
            phi_f16 = sp54;
            Math_FAtan2F(phi_f20, sp54);
            temp_f2 =
                Math_FTanF((*camera).fov * 0.4f32 *
                               (3.14159265358979323846f32 / 180.0f32)) *
                    phi_f16;
            if temp_f2 < phi_f20 {
                *arg3 += phi_f20 - temp_f2;
                phi_f20 = temp_f2
            } else if phi_f20 < -temp_f2 {
                *arg3 += phi_f20 + temp_f2;
                phi_f20 = -temp_f2
            }
            posOffsetTarget.y -= phi_f20
        } else {
            phi_f20 = (*playerPosRot).pos.y - *arg3;
            temp_f2 = Math_FAtan2F(phi_f20, OLib_Vec3fDistXZ(at, eye));
            if (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                      16 as libc::c_int + 32 as libc::c_int)
                                     as usize] as libc::c_int as libc::c_float
                   * (3.14159265358979323846f32 / 180.0f32) < temp_f2 {
                phi_f16 =
                    1 as libc::c_int as libc::c_float -
                        sinf(temp_f2 -
                                 (*gGameInfo).data[(2 as libc::c_int *
                                                        6 as libc::c_int *
                                                        16 as libc::c_int +
                                                        32 as libc::c_int) as
                                                       usize] as libc::c_int
                                     as libc::c_float *
                                     (3.14159265358979323846f32 / 180.0f32))
            } else if temp_f2 <
                          (*gGameInfo).data[(2 as libc::c_int *
                                                 6 as libc::c_int *
                                                 16 as libc::c_int +
                                                 33 as libc::c_int) as usize]
                              as libc::c_int as libc::c_float *
                              (3.14159265358979323846f32 / 180.0f32) {
                phi_f16 =
                    1 as libc::c_int as libc::c_float -
                        sinf((*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    33 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float *
                                 (3.14159265358979323846f32 / 180.0f32) -
                                 temp_f2)
            } else { phi_f16 = 1 as libc::c_int as f32_0 }
            posOffsetTarget.y -= phi_f20 * phi_f16
        }
        Camera_LERPCeilVec3f(&mut posOffsetTarget, &mut (*camera).posOffset,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    29 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    30 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32, 0.1f32);
        (*camera).yOffsetUpdateRate =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 29 as libc::c_int) as
                                  usize] as libc::c_int as libc::c_float *
                0.01f32;
        (*camera).xzOffsetUpdateRate =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 30 as libc::c_int) as
                                  usize] as libc::c_int as libc::c_float *
                0.01f32
    }
    atTarget.x = (*playerPosRot).pos.x + (*camera).posOffset.x;
    atTarget.y = (*playerPosRot).pos.y + (*camera).posOffset.y;
    atTarget.z = (*playerPosRot).pos.z + (*camera).posOffset.z;
    Camera_LERPCeilVec3f(&mut atTarget, at, (*camera).atLERPStepScale,
                         (*camera).atLERPStepScale, 0.2f32);
    return 1 as libc::c_int;
}
/* *
 * Adjusts at position for Camera_Battle1 and Camera_KeepOn1
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_CalcAtForLockOn(mut camera: *mut Camera,
                                                mut eyeAtDir: *mut VecSph,
                                                mut targetPos: *mut Vec3f,
                                                mut yOffset: f32_0,
                                                mut distance: f32_0,
                                                mut yPosOffset: *mut f32_0,
                                                mut outPlayerToTargetDir:
                                                    *mut VecSph,
                                                mut flags: s16) -> s32 {
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut tmpPos0: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut tmpPos1: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut lookFromOffset: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut floorNorm: *mut Vec3f = &mut (*camera).floorNorm;
    let mut playerToTargetDir: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut yPosDelta: f32_0 = 0.;
    let mut phi_f16: f32_0 = 0.;
    let mut eyeAtDist: f32_0 = 0.;
    let mut temp_f0_2: f32_0 = 0.;
    let mut playerHeight: f32_0 = 0.;
    playerHeight = Player_GetHeight((*camera).player);
    tmpPos0.x = 0.0f32;
    tmpPos0.y = playerHeight + yOffset;
    tmpPos0.z = 0.0f32;
    if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 76 as libc::c_int) as usize]
           as libc::c_int != 0 &&
           flags as libc::c_int & (1 as libc::c_int) << 0 as libc::c_int != 0
       {
        tmpPos0.y -=
            Camera_CalcSlopeYAdj(floorNorm, (*playerPosRot).rot.y,
                                 (*eyeAtDir).yaw,
                                 (*gGameInfo).data[(2 as libc::c_int *
                                                        6 as libc::c_int *
                                                        16 as libc::c_int +
                                                        9 as libc::c_int) as
                                                       usize] as f32_0)
    }
    // tmpPos1 is player's head
    tmpPos1 = (*playerPosRot).pos;
    tmpPos1.y += playerHeight;
    OLib_Vec3fDiffToVecSphGeo(outPlayerToTargetDir, &mut tmpPos1, targetPos);
    playerToTargetDir = *outPlayerToTargetDir;
    if distance < playerToTargetDir.r {
        playerToTargetDir.r =
            playerToTargetDir.r *
                ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                        16 as libc::c_int + 38 as libc::c_int)
                                       as usize] as libc::c_int as
                     libc::c_float * 0.01f32)
    } else {
        // ratio of player's height off ground to player's height.
        temp_f0_2 =
            OLib_ClampMaxDist(((*playerPosRot).pos.y -
                                   (*camera).playerGroundY) / playerHeight,
                              1.0f32);
        playerToTargetDir.r =
            playerToTargetDir.r *
                ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                        16 as libc::c_int + 39 as libc::c_int)
                                       as usize] as libc::c_int as
                     libc::c_float * 0.01f32) -
                ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                        16 as libc::c_int + 39 as libc::c_int)
                                       as usize] as libc::c_int as
                     libc::c_float * 0.01f32 -
                     (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                            16 as libc::c_int +
                                            38 as libc::c_int) as usize] as
                         libc::c_int as libc::c_float * 0.01f32) *
                    playerToTargetDir.r * (playerToTargetDir.r / distance);
        playerToTargetDir.r =
            playerToTargetDir.r - playerToTargetDir.r * temp_f0_2 * temp_f0_2
    }
    if flags as libc::c_int & (1 as libc::c_int) << 7 as libc::c_int != 0 {
        playerToTargetDir.r *= 0.2f32;
        (*camera).yOffsetUpdateRate = 0.01f32;
        (*camera).xzOffsetUpdateRate = (*camera).yOffsetUpdateRate
    }
    OLib_VecSphGeoToVec3f(&mut lookFromOffset, &mut playerToTargetDir);
    if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 89 as libc::c_int) as usize]
           != 0 {
        osSyncPrintf(b"%f (%f %f %f) %f\n\x00" as *const u8 as
                         *const libc::c_char,
                     (playerToTargetDir.r / distance) as libc::c_double,
                     lookFromOffset.x as libc::c_double,
                     lookFromOffset.y as libc::c_double,
                     lookFromOffset.z as libc::c_double,
                     (*camera).atLERPStepScale as libc::c_double);
    }
    tmpPos0.x = tmpPos0.x + lookFromOffset.x;
    tmpPos0.y = tmpPos0.y + lookFromOffset.y;
    tmpPos0.z = tmpPos0.z + lookFromOffset.z;
    if (*camera).playerGroundY == (*camera).playerPosRot.pos.y ||
           (*(*camera).player).actor.gravity > -0.1f32 ||
           (*(*camera).player).stateFlags1 &
               0x200000 as libc::c_int as libc::c_uint != 0 {
        *yPosOffset =
            Camera_LERPCeilF((*playerPosRot).pos.y, *yPosOffset,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    43 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32, 0.1f32);
        yPosDelta = (*playerPosRot).pos.y - *yPosOffset;
        tmpPos0.y -= yPosDelta;
        Camera_LERPCeilVec3f(&mut tmpPos0, &mut (*camera).posOffset,
                             (*camera).yOffsetUpdateRate,
                             (*camera).xzOffsetUpdateRate, 0.1f32);
    } else {
        if flags as libc::c_int & (1 as libc::c_int) << 7 as libc::c_int == 0
           {
            yPosDelta = (*playerPosRot).pos.y - *yPosOffset;
            eyeAtDist = OLib_Vec3fDistXZ(at, &mut (*camera).eye);
            phi_f16 = eyeAtDist;
            Math_FAtan2F(yPosDelta, eyeAtDist);
            temp_f0_2 =
                Math_FTanF((*camera).fov * 0.4f32 *
                               (3.14159265358979323846f32 / 180.0f32)) *
                    phi_f16;
            if temp_f0_2 < yPosDelta {
                *yPosOffset = *yPosOffset + (yPosDelta - temp_f0_2);
                yPosDelta = temp_f0_2
            } else if yPosDelta < -temp_f0_2 {
                *yPosOffset = *yPosOffset + (yPosDelta + temp_f0_2);
                yPosDelta = -temp_f0_2
            }
            tmpPos0.y = tmpPos0.y - yPosDelta
        } else {
            yPosDelta = (*playerPosRot).pos.y - *yPosOffset;
            temp_f0_2 =
                Math_FAtan2F(yPosDelta,
                             OLib_Vec3fDistXZ(at, &mut (*camera).eye));
            if temp_f0_2 >
                   (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                          16 as libc::c_int +
                                          32 as libc::c_int) as usize] as
                       libc::c_int as libc::c_float *
                       (3.14159265358979323846f32 / 180.0f32) {
                phi_f16 =
                    1.0f32 -
                        sinf(temp_f0_2 -
                                 (*gGameInfo).data[(2 as libc::c_int *
                                                        6 as libc::c_int *
                                                        16 as libc::c_int +
                                                        32 as libc::c_int) as
                                                       usize] as libc::c_int
                                     as libc::c_float *
                                     (3.14159265358979323846f32 / 180.0f32))
            } else if temp_f0_2 <
                          (*gGameInfo).data[(2 as libc::c_int *
                                                 6 as libc::c_int *
                                                 16 as libc::c_int +
                                                 33 as libc::c_int) as usize]
                              as libc::c_int as libc::c_float *
                              (3.14159265358979323846f32 / 180.0f32) {
                phi_f16 =
                    1.0f32 -
                        sinf((*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    33 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float *
                                 (3.14159265358979323846f32 / 180.0f32) -
                                 temp_f0_2)
            } else { phi_f16 = 1.0f32 }
            tmpPos0.y -= yPosDelta * phi_f16
        }
        Camera_LERPCeilVec3f(&mut tmpPos0, &mut (*camera).posOffset,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    29 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    30 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32, 0.1f32);
        (*camera).yOffsetUpdateRate =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 29 as libc::c_int) as
                                  usize] as libc::c_int as libc::c_float *
                0.01f32;
        (*camera).xzOffsetUpdateRate =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 30 as libc::c_int) as
                                  usize] as libc::c_int as libc::c_float *
                0.01f32
    }
    tmpPos1.x = (*playerPosRot).pos.x + (*camera).posOffset.x;
    tmpPos1.y = (*playerPosRot).pos.y + (*camera).posOffset.y;
    tmpPos1.z = (*playerPosRot).pos.z + (*camera).posOffset.z;
    Camera_LERPCeilVec3f(&mut tmpPos1, at, (*camera).atLERPStepScale,
                         (*camera).atLERPStepScale, 0.2f32);
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_CalcAtForHorse(mut camera: *mut Camera,
                                               mut eyeAtDir: *mut VecSph,
                                               mut yOffset: f32_0,
                                               mut yPosOffset: *mut f32_0,
                                               mut calcSlope: s16) -> s32 {
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut posOffsetTarget: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut atTarget: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut pad: s32 = 0;
    let mut pad2: s32 = 0;
    let mut playerHeight: f32_0 = 0.;
    let mut player: *mut Player = 0 as *mut Player;
    let mut horsePosRot: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    playerHeight = Player_GetHeight((*camera).player);
    player = (*camera).player;
    Actor_GetWorldPosShapeRot(&mut horsePosRot, (*player).rideActor);
    if if (*((*player).rideActor as *mut EnHorse)).stateFlags &
              ((1 as libc::c_int) << 2 as libc::c_int) as libc::c_uint != 0 {
           1 as libc::c_int
       } else { 0 as libc::c_int } != 0 {
        horsePosRot.pos.y -= 49.0f32;
        *yPosOffset =
            Camera_LERPCeilF(horsePosRot.pos.y, *yPosOffset, 0.1f32, 0.2f32);
        (*camera).atLERPStepScale =
            Camera_LERPCeilF(0.4f32, (*camera).atLERPStepScale, 0.2f32,
                             0.02f32)
    } else {
        *yPosOffset =
            Camera_LERPCeilF(horsePosRot.pos.y, *yPosOffset, 0.5f32, 0.2f32)
    }
    posOffsetTarget.x = 0.0f32;
    posOffsetTarget.y = playerHeight + yOffset;
    posOffsetTarget.z = 0.0f32;
    if calcSlope as libc::c_int != 0 as libc::c_int {
        posOffsetTarget.y -=
            Camera_CalcSlopeYAdj(&mut (*camera).floorNorm,
                                 (*camera).playerPosRot.rot.y,
                                 (*eyeAtDir).yaw,
                                 (*gGameInfo).data[(2 as libc::c_int *
                                                        6 as libc::c_int *
                                                        16 as libc::c_int +
                                                        9 as libc::c_int) as
                                                       usize] as f32_0)
    }
    Camera_LERPCeilVec3f(&mut posOffsetTarget, &mut (*camera).posOffset,
                         (*camera).yOffsetUpdateRate,
                         (*camera).xzOffsetUpdateRate, 0.1f32);
    atTarget.x = (*camera).posOffset.x + horsePosRot.pos.x;
    atTarget.y = (*camera).posOffset.y + horsePosRot.pos.y;
    atTarget.z = (*camera).posOffset.z + horsePosRot.pos.z;
    Camera_LERPCeilVec3f(&mut atTarget, at, (*camera).atLERPStepScale,
                         (*camera).atLERPStepScale, 0.2f32);
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_LERPClampDist(mut camera: *mut Camera,
                                              mut dist: f32_0, mut min: f32_0,
                                              mut max: f32_0) -> f32_0 {
    let mut distTarget: f32_0 = 0.;
    let mut rUpdateRateInvTarget: f32_0 = 0.;
    if dist < min {
        distTarget = min;
        rUpdateRateInvTarget =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 6 as libc::c_int) as
                                  usize] as f32_0
    } else if dist > max {
        distTarget = max;
        rUpdateRateInvTarget =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 6 as libc::c_int) as
                                  usize] as f32_0
    } else { distTarget = dist; rUpdateRateInvTarget = 1.0f32 }
    (*camera).rUpdateRateInv =
        Camera_LERPCeilF(rUpdateRateInvTarget, (*camera).rUpdateRateInv,
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                25 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32,
                         0.1f32);
    return Camera_LERPCeilF(distTarget, (*camera).dist,
                            1.0f32 / (*camera).rUpdateRateInv, 0.2f32);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_ClampDist(mut camera: *mut Camera,
                                          mut dist: f32_0, mut minDist: f32_0,
                                          mut maxDist: f32_0, mut timer: s16)
 -> f32_0 {
    let mut distTarget: f32_0 = 0.;
    let mut rUpdateRateInvTarget: f32_0 = 0.;
    if dist < minDist {
        distTarget = minDist;
        rUpdateRateInvTarget =
            if timer as libc::c_int != 0 as libc::c_int {
                ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                        16 as libc::c_int + 6 as libc::c_int)
                                       as usize] as libc::c_int as
                     libc::c_float) * 0.5f32
            } else {
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 6 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float
            }
    } else if maxDist < dist {
        distTarget = maxDist;
        rUpdateRateInvTarget =
            if timer as libc::c_int != 0 as libc::c_int {
                ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                        16 as libc::c_int + 6 as libc::c_int)
                                       as usize] as libc::c_int as
                     libc::c_float) * 0.5f32
            } else {
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 6 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float
            }
    } else {
        distTarget = dist;
        rUpdateRateInvTarget =
            if timer as libc::c_int != 0 as libc::c_int {
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 6 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float
            } else { 1.0f32 }
    }
    (*camera).rUpdateRateInv =
        Camera_LERPCeilF(rUpdateRateInvTarget, (*camera).rUpdateRateInv,
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                25 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32,
                         0.1f32);
    return Camera_LERPCeilF(distTarget, (*camera).dist,
                            1.0f32 / (*camera).rUpdateRateInv, 0.2f32);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_CalcDefaultPitch(mut camera: *mut Camera,
                                                 mut arg1: s16, mut arg2: s16,
                                                 mut arg3: s16) -> s16 {
    let mut pad: f32_0 = 0.;
    let mut phi_a2: f32_0 = 0.;
    let mut t: f32_0 = 0.;
    let mut phi_v0: s16 = 0;
    let mut phi_v1: s16 = 0;
    let mut sp1C: s16 = 0;
    phi_v1 =
        if arg1 as libc::c_int >= 0 as libc::c_int {
            arg1 as libc::c_int
        } else { -(arg1 as libc::c_int) } as s16;
    phi_v0 =
        if arg3 as libc::c_int > 0 as libc::c_int {
            (Math_CosS(arg3) * arg3 as libc::c_int as libc::c_float) as s16 as
                libc::c_int
        } else { arg3 as libc::c_int } as s16;
    sp1C = (arg2 as libc::c_int - phi_v0 as libc::c_int) as s16;
    if (if sp1C as libc::c_int >= 0 as libc::c_int {
            sp1C as libc::c_int
        } else { -(sp1C as libc::c_int) }) < phi_v1 as libc::c_int {
        phi_a2 = 1.0f32 / (*camera).pitchUpdateRateInv * 3.0f32
    } else {
        t =
            phi_v1 as libc::c_int as libc::c_float *
                (1.0f32 /
                     (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                            16 as libc::c_int +
                                            5 as libc::c_int) as usize] as
                         libc::c_int as libc::c_float);
        pad = Camera_InterpolateCurve(0.8f32, 1.0f32 - t);
        phi_a2 = 1.0f32 / (*camera).pitchUpdateRateInv * pad
    }
    return Camera_LERPCeilS(sp1C, arg1, phi_a2, 0xa as libc::c_int as s16);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_CalcDefaultYaw(mut camera: *mut Camera,
                                               mut cur: s16, mut target: s16,
                                               mut arg3: f32_0,
                                               mut accel: f32_0) -> s16 {
    let mut velocity: f32_0 = 0.;
    let mut angDelta: s16 = 0;
    let mut updSpeed: f32_0 = 0.;
    let mut speedT: f32_0 = 0.;
    let mut velFactor: f32_0 = 0.;
    let mut yawUpdRate: f32_0 = 0.;
    if (*camera).xzSpeed > 0.001f32 {
        angDelta =
            (target as libc::c_int -
                 (cur as libc::c_int - 0x7fff as libc::c_int) as s16 as
                     libc::c_int) as s16;
        speedT =
            (angDelta as libc::c_int - 0x7fff as libc::c_int) as s16 as
                libc::c_int as libc::c_float * (1.0f32 / 32767.0f32)
    } else {
        angDelta =
            (target as libc::c_int -
                 (cur as libc::c_int - 0x7fff as libc::c_int) as s16 as
                     libc::c_int) as s16;
        speedT =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 48 as libc::c_int) as
                                  usize] as libc::c_int as libc::c_float *
                0.01f32
    }
    updSpeed = Camera_InterpolateCurve(arg3, speedT);
    velocity = updSpeed + (1.0f32 - updSpeed) * accel;
    if velocity < 0.0f32 { velocity = 0.0f32 }
    velFactor = Camera_InterpolateCurve(0.5f32, (*camera).speedRatio);
    yawUpdRate = 1.0f32 / (*camera).yawUpdateRateInv;
    return (cur as libc::c_int +
                (angDelta as libc::c_int as libc::c_float * velocity *
                     velFactor * yawUpdRate) as s16 as libc::c_int) as s16;
}
#[no_mangle]
pub unsafe extern "C" fn func_80046E20(mut camera: *mut Camera,
                                       mut eyeAdjustment: *mut VecSph,
                                       mut minDist: f32_0, mut arg3: f32_0,
                                       mut arg4: *mut f32_0,
                                       mut anim: *mut SwingAnimation) {
    static mut atEyeColChk: CamColChk =
        CamColChk{pos: Vec3f{x: 0., y: 0., z: 0.,},
                  norm: Vec3f{x: 0., y: 0., z: 0.,},
                  poly: 0 as *mut CollisionPoly,
                  sphNorm: VecSph{r: 0., pitch: 0, yaw: 0,},
                  bgId: 0,};
    static mut eyeAtColChk: CamColChk =
        CamColChk{pos: Vec3f{x: 0., y: 0., z: 0.,},
                  norm: Vec3f{x: 0., y: 0., z: 0.,},
                  poly: 0 as *mut CollisionPoly,
                  sphNorm: VecSph{r: 0., pitch: 0, yaw: 0,},
                  bgId: 0,};
    static mut newEyeColChk: CamColChk =
        CamColChk{pos: Vec3f{x: 0., y: 0., z: 0.,},
                  norm: Vec3f{x: 0., y: 0., z: 0.,},
                  poly: 0 as *mut CollisionPoly,
                  sphNorm: VecSph{r: 0., pitch: 0, yaw: 0,},
                  bgId: 0,};
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut temp_v0: s32 = 0;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut peekAroundPoint: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut temp_f0: f32_0 = 0.;
    let mut newEyeAdjustment: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut sp40: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    temp_v0 =
        func_80045508(camera, eyeAdjustment, &mut atEyeColChk,
                      &mut eyeAtColChk,
                      ((*anim).unk_18 == 0) as libc::c_int as s16);
    let mut current_block_57: u64;
    match temp_v0 {
        1 | 2 => {
            // angle between polys is between 60 and 120 degrees.
            Camera_BGCheckCorner(&mut (*anim).collisionClosePoint, at,
                                 eyeNext, &mut atEyeColChk, &mut eyeAtColChk);
            peekAroundPoint.x =
                (*anim).collisionClosePoint.x +
                    (atEyeColChk.norm.x + eyeAtColChk.norm.x);
            peekAroundPoint.y =
                (*anim).collisionClosePoint.y +
                    (atEyeColChk.norm.y + eyeAtColChk.norm.y);
            peekAroundPoint.z =
                (*anim).collisionClosePoint.z +
                    (atEyeColChk.norm.z + eyeAtColChk.norm.z);
            temp_f0 = OLib_Vec3fDist(at, &mut atEyeColChk.pos);
            *arg4 =
                if temp_f0 > minDist { 1.0f32 } else { (temp_f0) / minDist };
            (*anim).swingUpdateRate =
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 10 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32;
            (*anim).unk_18 = 1 as libc::c_int as s16;
            (*anim).atEyePoly = eyeAtColChk.poly;
            OLib_Vec3fDiffToVecSphGeo(&mut newEyeAdjustment, at,
                                      &mut peekAroundPoint);
            newEyeAdjustment.r = (*eyeAdjustment).r;
            Camera_Vec3fVecSphGeoAdd(eye, at, &mut newEyeAdjustment);
            newEyeColChk.pos = *eye;
            if Camera_BGCheckInfo(camera, at, &mut newEyeColChk) ==
                   0 as libc::c_int {
                // no collision found between at->newEyePos
                newEyeAdjustment.yaw =
                    (newEyeAdjustment.yaw as libc::c_int +
                         (((*eyeAdjustment).yaw as libc::c_int -
                               newEyeAdjustment.yaw as libc::c_int) as s16 as
                              libc::c_int >> 1 as libc::c_int)) as s16;
                newEyeAdjustment.pitch =
                    (newEyeAdjustment.pitch as libc::c_int +
                         (((*eyeAdjustment).pitch as libc::c_int -
                               newEyeAdjustment.pitch as libc::c_int) as s16
                              as libc::c_int >> 1 as libc::c_int)) as s16;
                Camera_Vec3fVecSphGeoAdd(eye, at, &mut newEyeAdjustment);
                if (atEyeColChk.sphNorm.pitch as libc::c_int) <
                       0x2aa8 as libc::c_int {
                    // ~ 60 degrees
                    (*anim).unk_16 = newEyeAdjustment.yaw;
                    (*anim).unk_14 = newEyeAdjustment.pitch
                } else {
                    (*anim).unk_16 = (*eyeAdjustment).yaw;
                    (*anim).unk_14 = (*eyeAdjustment).pitch
                }
                peekAroundPoint.x =
                    (*anim).collisionClosePoint.x -
                        (atEyeColChk.norm.x + eyeAtColChk.norm.x);
                peekAroundPoint.y =
                    (*anim).collisionClosePoint.y -
                        (atEyeColChk.norm.y + eyeAtColChk.norm.y);
                peekAroundPoint.z =
                    (*anim).collisionClosePoint.z -
                        (atEyeColChk.norm.z + eyeAtColChk.norm.z);
                OLib_Vec3fDiffToVecSphGeo(&mut newEyeAdjustment, at,
                                          &mut peekAroundPoint);
                newEyeAdjustment.r = (*eyeAdjustment).r;
                Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut newEyeAdjustment);
                current_block_57 = 6545907279487748450;
            } else {
                (*camera).eye = newEyeColChk.pos;
                atEyeColChk = newEyeColChk;
                current_block_57 = 18099125730856134369;
            }
        }
        3 | 6 => { current_block_57 = 18099125730856134369; }
        _ => {
            if (*anim).unk_18 as libc::c_int != 0 as libc::c_int {
                (*anim).swingUpdateRateTimer =
                    (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                           16 as libc::c_int +
                                           52 as libc::c_int) as usize];
                *eyeNext = *eye;
                (*anim).unk_18 = 0 as libc::c_int as s16
            }
            (*anim).swingUpdateRate = arg3;
            (*anim).atEyePoly = 0 as *mut CollisionPoly;
            (*eye).x = atEyeColChk.pos.x + atEyeColChk.norm.x;
            (*eye).y = atEyeColChk.pos.y + atEyeColChk.norm.y;
            (*eye).z = atEyeColChk.pos.z + atEyeColChk.norm.z;
            current_block_57 = 6545907279487748450;
        }
    }
    match current_block_57 {
        18099125730856134369 => {
            if (*anim).unk_18 as libc::c_int != 0 as libc::c_int {
                (*anim).swingUpdateRateTimer =
                    (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                           16 as libc::c_int +
                                           52 as libc::c_int) as usize];
                (*anim).unk_18 = 0 as libc::c_int as s16;
                *eyeNext = *eye
            }
            temp_f0 = OLib_Vec3fDist(at, &mut atEyeColChk.pos);
            *arg4 =
                if temp_f0 > minDist { 1.0f32 } else { (temp_f0) / minDist };
            (*anim).swingUpdateRate = *arg4 * arg3;
            Camera_Vec3fTranslateByUnitVector(eye, &mut atEyeColChk.pos,
                                              &mut atEyeColChk.norm, 1.0f32);
            (*anim).atEyePoly = 0 as *mut CollisionPoly;
            if temp_f0 <
                   (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                          16 as libc::c_int +
                                          21 as libc::c_int) as usize] as
                       libc::c_int as libc::c_float {
                sp40.yaw = (*eyeAdjustment).yaw;
                sp40.pitch =
                    (Math_SinS((atEyeColChk.sphNorm.pitch as libc::c_int +
                                    0x3fff as libc::c_int) as s16) *
                         16380.0f32) as s16;
                sp40.r =
                    ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                            16 as libc::c_int +
                                            21 as libc::c_int) as usize] as
                         libc::c_int as libc::c_float - temp_f0) *
                        ((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                22 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32);
                Camera_Vec3fVecSphGeoAdd(eye, eye, &mut sp40);
            }
        }
        _ => { }
    };
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Noop(mut camera: *mut Camera) -> s32 {
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Normal1(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut spA0: f32_0 = 0.;
    let mut sp9C: f32_0 = 0.;
    let mut sp98: f32_0 = 0.;
    let mut sp94: f32_0 = 0.;
    let mut sp88: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut wiggleAdj: s16 = 0;
    let mut t: s16 = 0;
    let mut eyeAdjustment: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut atEyeGeo: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut atEyeNextGeo: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut norm1: *mut Normal1 =
        (*camera).paramData.as_mut_ptr() as *mut Normal1;
    let mut anim: *mut Normal1Anim = &mut (*norm1).anim;
    let mut playerHeight: f32_0 = 0.;
    let mut rate: f32_0 = 0.1f32;
    playerHeight = Player_GetHeight((*camera).player);
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let mut yNormal: f32_0 =
            1.0f32 +
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 -
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 * (68.0f32 / playerHeight);
        sp94 = yNormal * (playerHeight * 0.01f32);
        let fresh0 = values;
        values = values.offset(1);
        (*norm1).yOffset =
            (*fresh0).val as libc::c_int as libc::c_float * sp94;
        let fresh1 = values;
        values = values.offset(1);
        (*norm1).distMin =
            (*fresh1).val as libc::c_int as libc::c_float * sp94;
        let fresh2 = values;
        values = values.offset(1);
        (*norm1).distMax =
            (*fresh2).val as libc::c_int as libc::c_float * sp94;
        let fresh3 = values;
        values = values.offset(1);
        (*norm1).pitchTarget =
            ((*fresh3).val as libc::c_int as libc::c_float * 182.04167f32 +
                 0.5f32) as s16;
        let fresh4 = values;
        values = values.offset(1);
        (*norm1).unk_0C = (*fresh4).val as f32_0;
        let fresh5 = values;
        values = values.offset(1);
        (*norm1).unk_10 = (*fresh5).val as f32_0;
        let fresh6 = values;
        values = values.offset(1);
        (*norm1).unk_14 =
            (*fresh6).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh7 = values;
        values = values.offset(1);
        (*norm1).fovTarget = (*fresh7).val as f32_0;
        let fresh8 = values;
        values = values.offset(1);
        (*norm1).atLERPScaleMax =
            (*fresh8).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh9 = values;
        values = values.offset(1);
        (*norm1).interfaceFlags = (*fresh9).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    sCameraInterfaceFlags = (*norm1).interfaceFlags as s32;
    OLib_Vec3fDiffToVecSphGeo(&mut atEyeGeo, at, eye);
    OLib_Vec3fDiffToVecSphGeo(&mut atEyeNextGeo, at, eyeNext);
    let mut current_block_32: u64;
    match (*camera).animState as libc::c_int {
        20 => {
            (*camera).yawUpdateRateInv =
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 27 as libc::c_int)
                                      as usize] as f32_0;
            (*camera).pitchUpdateRateInv =
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 27 as libc::c_int)
                                      as usize] as f32_0;
            current_block_32 = 18066077593202603566;
        }
        0 | 10 | 25 => { current_block_32 = 18066077593202603566; }
        _ => { current_block_32 = 10758786907990354186; }
    }
    match current_block_32 {
        18066077593202603566 => {
            (*anim).swing.atEyePoly = 0 as *mut CollisionPoly;
            (*anim).slopePitchAdj = 0 as libc::c_int as s16;
            (*anim).unk_28 = 0xa as libc::c_int as s16;
            (*anim).swing.unk_18 = 0 as libc::c_int as s16;
            (*anim).swing.unk_14 = (*anim).swing.unk_18;
            (*anim).swing.unk_16 = (*anim).swing.unk_14;
            (*anim).swing.swingUpdateRate = (*norm1).unk_0C;
            (*anim).yOffset = (*camera).playerPosRot.pos.y;
            (*anim).unk_20 = (*camera).xzSpeed;
            (*anim).swing.swingUpdateRateTimer = 0 as libc::c_int as s16;
            (*anim).swingYawTarget = atEyeGeo.yaw;
            sUpdateCameraDirection = 0 as libc::c_int;
            (*anim).startSwingTimer =
                ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                        16 as libc::c_int + 50 as libc::c_int)
                                       as usize] as libc::c_int +
                     (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                            16 as libc::c_int +
                                            51 as libc::c_int) as usize] as
                         libc::c_int) as s16
        }
        _ => { }
    }
    (*camera).animState = 1 as libc::c_int as s16;
    sUpdateCameraDirection = 1 as libc::c_int;
    if (*anim).unk_28 as libc::c_int != 0 as libc::c_int {
        (*anim).unk_28 -= 1
    }
    if (*camera).xzSpeed > 0.001f32 {
        (*anim).startSwingTimer =
            ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                    16 as libc::c_int + 50 as libc::c_int) as
                                   usize] as libc::c_int +
                 (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                        16 as libc::c_int + 51 as libc::c_int)
                                       as usize] as libc::c_int) as s16
    } else if (*anim).startSwingTimer as libc::c_int > 0 as libc::c_int {
        if (*anim).startSwingTimer as libc::c_int >
               (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                      16 as libc::c_int + 50 as libc::c_int)
                                     as usize] as libc::c_int {
            (*anim).swingYawTarget =
                (atEyeGeo.yaw as libc::c_int +
                     (((*camera).playerPosRot.rot.y as libc::c_int -
                           0x7fff as libc::c_int) as s16 as libc::c_int -
                          atEyeGeo.yaw as libc::c_int) as s16 as libc::c_int /
                         (*anim).startSwingTimer as libc::c_int) as s16
        }
        (*anim).startSwingTimer -= 1
    }
    spA0 =
        (*camera).speedRatio *
            ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                    16 as libc::c_int + 25 as libc::c_int) as
                                   usize] as libc::c_int as libc::c_float *
                 0.01f32);
    sp9C =
        (*camera).speedRatio *
            ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                    16 as libc::c_int + 26 as libc::c_int) as
                                   usize] as libc::c_int as libc::c_float *
                 0.01f32);
    sp98 =
        if (*anim).swing.unk_18 as libc::c_int != 0 as libc::c_int {
            ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                    16 as libc::c_int + 25 as libc::c_int) as
                                   usize] as libc::c_int as libc::c_float) *
                0.01f32
        } else { spA0 };
    sp94 = ((*camera).xzSpeed - (*anim).unk_20) * 0.333333f32;
    if sp94 > 1.0f32 { sp94 = 1.0f32 }
    if sp94 > -1.0f32 { sp94 = -1.0f32 }
    (*anim).unk_20 = (*camera).xzSpeed;
    if (*anim).swing.swingUpdateRateTimer as libc::c_int != 0 as libc::c_int {
        (*camera).yawUpdateRateInv =
            Camera_LERPCeilF((*anim).swing.swingUpdateRate +
                                 ((*anim).swing.swingUpdateRateTimer as
                                      libc::c_int * 2 as libc::c_int) as
                                     f32_0, (*camera).yawUpdateRateInv, sp98,
                             rate);
        (*camera).pitchUpdateRateInv =
            Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    7 as libc::c_int) as
                                                   usize] as f32_0 +
                                 ((*anim).swing.swingUpdateRateTimer as
                                      libc::c_int * 2 as libc::c_int) as
                                     f32_0, (*camera).pitchUpdateRateInv,
                             sp9C, rate);
        (*anim).swing.swingUpdateRateTimer -= 1
    } else {
        (*camera).yawUpdateRateInv =
            Camera_LERPCeilF((*anim).swing.swingUpdateRate -
                                 (*gGameInfo).data[(2 as libc::c_int *
                                                        6 as libc::c_int *
                                                        16 as libc::c_int +
                                                        49 as libc::c_int) as
                                                       usize] as libc::c_int
                                     as libc::c_float * 0.01f32 *
                                     (*anim).swing.swingUpdateRate * sp94,
                             (*camera).yawUpdateRateInv, sp98, rate);
        (*camera).pitchUpdateRateInv =
            Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    7 as libc::c_int) as
                                                   usize] as f32_0,
                             (*camera).pitchUpdateRateInv, sp9C, rate)
    }
    (*camera).pitchUpdateRateInv =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                7 as libc::c_int) as usize] as
                             f32_0, (*camera).pitchUpdateRateInv, sp9C, rate);
    (*camera).xzOffsetUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                2 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).xzOffsetUpdateRate, spA0, rate);
    (*camera).yOffsetUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                3 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).yOffsetUpdateRate, sp9C, rate);
    (*camera).fovUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                4 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).yOffsetUpdateRate,
                         (*camera).speedRatio * 0.05f32, rate);
    if (*norm1).interfaceFlags as libc::c_int & 1 as libc::c_int != 0 {
        t =
            func_80044ADC(camera,
                          (atEyeGeo.yaw as libc::c_int -
                               0x7fff as libc::c_int) as s16,
                          0 as libc::c_int as s16);
        sp9C =
            1.0f32 / (*norm1).unk_10 * 0.5f32 *
                (1.0f32 - (*camera).speedRatio);
        (*anim).slopePitchAdj =
            Camera_LERPCeilS(t, (*anim).slopePitchAdj,
                             1.0f32 / (*norm1).unk_10 * 0.5f32 + sp9C,
                             0xf as libc::c_int as s16)
    } else {
        (*anim).slopePitchAdj = 0 as libc::c_int as s16;
        if (*camera).playerGroundY == (*camera).playerPosRot.pos.y {
            (*anim).yOffset = (*camera).playerPosRot.pos.y
        }
    }
    spA0 =
        if (*anim).swing.unk_18 as libc::c_int != 0 as libc::c_int &&
               (*norm1).yOffset > -40.0f32 {
            sp9C = Math_SinS((*anim).swing.unk_14);
            (-40.0f32 * sp9C) + (*norm1).yOffset * (1.0f32 - sp9C)
        } else { (*norm1).yOffset };
    if (*norm1).interfaceFlags as libc::c_int & 0x80 as libc::c_int != 0 {
        func_800458D4(camera, &mut atEyeNextGeo, spA0, &mut (*anim).yOffset,
                      ((*norm1).interfaceFlags as libc::c_int &
                           1 as libc::c_int) as s16);
    } else if (*norm1).interfaceFlags as libc::c_int & 0x20 as libc::c_int !=
                  0 {
        func_80045B08(camera, &mut atEyeNextGeo, spA0, (*anim).slopePitchAdj);
    } else {
        Camera_CalcAtDefault(camera, &mut atEyeNextGeo, spA0,
                             ((*norm1).interfaceFlags as libc::c_int &
                                  1 as libc::c_int) as s16);
    }
    OLib_Vec3fDiffToVecSphGeo(&mut eyeAdjustment, at, eyeNext);
    eyeAdjustment.r =
        Camera_ClampDist(camera, eyeAdjustment.r, (*norm1).distMin,
                         (*norm1).distMax, (*anim).unk_28);
    (*camera).dist = eyeAdjustment.r;
    if (*anim).startSwingTimer as libc::c_int <= 0 as libc::c_int {
        eyeAdjustment.pitch = atEyeNextGeo.pitch;
        eyeAdjustment.yaw =
            Camera_LERPCeilS((*anim).swingYawTarget, atEyeNextGeo.yaw,
                             1.0f32 / (*camera).yawUpdateRateInv,
                             0xa as libc::c_int as s16)
    } else if (*anim).swing.unk_18 as libc::c_int != 0 as libc::c_int {
        eyeAdjustment.yaw =
            Camera_LERPCeilS((*anim).swing.unk_16, atEyeNextGeo.yaw,
                             1.0f32 / (*camera).yawUpdateRateInv,
                             0xa as libc::c_int as s16);
        eyeAdjustment.pitch =
            Camera_LERPCeilS((*anim).swing.unk_14, atEyeNextGeo.pitch,
                             1.0f32 / (*camera).yawUpdateRateInv,
                             0xa as libc::c_int as s16)
    } else {
        // rotate yaw to follow player.
        eyeAdjustment.yaw =
            Camera_CalcDefaultYaw(camera, atEyeNextGeo.yaw,
                                  (*camera).playerPosRot.rot.y,
                                  (*norm1).unk_14, sp94);
        eyeAdjustment.pitch =
            Camera_CalcDefaultPitch(camera, atEyeNextGeo.pitch,
                                    (*norm1).pitchTarget,
                                    (*anim).slopePitchAdj)
    }
    // set eyeAdjustment pitch from 79.65 degrees to -85 degrees
    if eyeAdjustment.pitch as libc::c_int > 0x38a4 as libc::c_int {
        eyeAdjustment.pitch = 0x38a4 as libc::c_int as s16
    }
    if (eyeAdjustment.pitch as libc::c_int) < -(0x3c8c as libc::c_int) {
        eyeAdjustment.pitch = -(0x3c8c as libc::c_int) as s16
    }
    Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut eyeAdjustment);
    if (*camera).status as libc::c_int == 7 as libc::c_int &&
           (*norm1).interfaceFlags as libc::c_int & 0x10 as libc::c_int == 0 {
        (*anim).swingYawTarget =
            ((*camera).playerPosRot.rot.y as libc::c_int -
                 0x7fff as libc::c_int) as s16;
        if (*anim).startSwingTimer as libc::c_int > 0 as libc::c_int {
            func_80046E20(camera, &mut eyeAdjustment, (*norm1).distMin,
                          (*norm1).unk_0C, &mut sp98, &mut (*anim).swing);
        } else {
            sp88 = *eyeNext;
            (*camera).yawUpdateRateInv = (*norm1).unk_0C * 2.0f32;
            (*anim).swing.swingUpdateRate = (*camera).yawUpdateRateInv;
            if Camera_BGCheck(camera, at, &mut sp88) != 0 {
                (*anim).swingYawTarget = atEyeNextGeo.yaw;
                (*anim).startSwingTimer = -(1 as libc::c_int) as s16
            } else { *eye = *eyeNext }
            (*anim).swing.unk_18 = 0 as libc::c_int as s16
        }
        if (*anim).swing.unk_18 as libc::c_int != 0 as libc::c_int {
            (*camera).inputDir.y =
                Camera_LERPCeilS(((*camera).inputDir.y as libc::c_int +
                                      (((*anim).swing.unk_16 as libc::c_int -
                                            0x7fff as libc::c_int) as s16 as
                                           libc::c_int -
                                           (*camera).inputDir.y as
                                               libc::c_int) as s16 as
                                          libc::c_int) as s16,
                                 (*camera).inputDir.y,
                                 1.0f32 - 0.99f32 * sp98,
                                 0xa as libc::c_int as s16)
        }
        if (*norm1).interfaceFlags as libc::c_int & 4 as libc::c_int != 0 {
            (*camera).inputDir.x = -(atEyeGeo.pitch as libc::c_int) as s16;
            (*camera).inputDir.y =
                (atEyeGeo.yaw as libc::c_int - 0x7fff as libc::c_int) as s16;
            (*camera).inputDir.z = 0 as libc::c_int as s16
        } else {
            OLib_Vec3fDiffToVecSphGeo(&mut eyeAdjustment, eye, at);
            (*camera).inputDir.x = eyeAdjustment.pitch;
            (*camera).inputDir.y = eyeAdjustment.yaw;
            (*camera).inputDir.z = 0 as libc::c_int as s16
        }
        // crit wiggle
        if gSaveContext.health as libc::c_int <= 16 as libc::c_int &&
               (*(*camera).globalCtx).state.frames.wrapping_rem(256 as
                                                                    libc::c_int
                                                                    as
                                                                    libc::c_uint)
                   == 0 as libc::c_int as libc::c_uint {
            wiggleAdj = (Rand_ZeroOne() * 10000.0f32) as s16;
            (*camera).inputDir.y =
                (wiggleAdj as libc::c_int +
                     (*camera).inputDir.y as libc::c_int) as s16
        }
    } else {
        (*anim).swing.swingUpdateRate = (*norm1).unk_0C;
        (*anim).swing.unk_18 = 0 as libc::c_int as s16;
        sUpdateCameraDirection = 0 as libc::c_int;
        *eye = *eyeNext
    }
    spA0 =
        if gSaveContext.health as libc::c_int <= 16 as libc::c_int {
            0.8f32
        } else { 1.0f32 };
    (*camera).fov =
        Camera_LERPCeilF((*norm1).fovTarget * spA0, (*camera).fov,
                         (*camera).fovUpdateRate, 1.0f32);
    (*camera).roll =
        Camera_LERPCeilS(0 as libc::c_int as s16, (*camera).roll, 0.5f32,
                         0xa as libc::c_int as s16);
    (*camera).atLERPStepScale =
        Camera_ClampLERPScale(camera, (*norm1).atLERPScaleMax);
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Normal2(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut bgChk: CamColChk =
        CamColChk{pos: Vec3f{x: 0., y: 0., z: 0.,},
                  norm: Vec3f{x: 0., y: 0., z: 0.,},
                  poly: 0 as *mut CollisionPoly,
                  sphNorm: VecSph{r: 0., pitch: 0, yaw: 0,},
                  bgId: 0,};
    let mut phi_a0: s16 = 0;
    let mut phi_a1: s16 = 0;
    let mut spA4: f32_0 = 0.;
    let mut spA0: f32_0 = 0.;
    let mut adjSph: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut sp90: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut sp88: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut atToEyeDir: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut atToEyeNextDir: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut norm2: *mut Normal2 =
        (*camera).paramData.as_mut_ptr() as *mut Normal2;
    let mut anim: *mut Normal2Anim = &mut (*norm2).anim;
    let mut pad: s32 = 0;
    let mut bgData: *mut Vec3s = 0 as *mut Vec3s;
    let mut playerHeight: f32_0 = 0.;
    let mut yNormal: f32_0 = 0.;
    playerHeight = Player_GetHeight((*camera).player);
    yNormal =
        1.0f32 +
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 46 as libc::c_int) as
                                  usize] as libc::c_int as libc::c_float *
                0.01f32 -
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 46 as libc::c_int) as
                                  usize] as libc::c_int as libc::c_float *
                0.01f32 * (68.0f32 / playerHeight);
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let fresh10 = values;
        values = values.offset(1);
        (*norm2).unk_00 =
            (*fresh10).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh11 = values;
        values = values.offset(1);
        (*norm2).unk_04 =
            (*fresh11).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh12 = values;
        values = values.offset(1);
        (*norm2).unk_08 =
            (*fresh12).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh13 = values;
        values = values.offset(1);
        (*norm2).unk_1C =
            ((*fresh13).val as libc::c_int as libc::c_float * 182.04167f32 +
                 0.5f32) as s16;
        let fresh14 = values;
        values = values.offset(1);
        (*norm2).unk_0C = (*fresh14).val as f32_0;
        let fresh15 = values;
        values = values.offset(1);
        (*norm2).unk_10 =
            (*fresh15).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh16 = values;
        values = values.offset(1);
        (*norm2).unk_14 = (*fresh16).val as f32_0;
        let fresh17 = values;
        values = values.offset(1);
        (*norm2).unk_18 =
            (*fresh17).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh18 = values;
        values = values.offset(1);
        (*norm2).interfaceFlags = (*fresh18).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    sCameraInterfaceFlags = (*norm2).interfaceFlags as s32;
    match (*camera).animState as libc::c_int {
        0 | 10 | 20 | 25 => {
            bgData = Camera_GetCamBGData(camera);
            Camera_Vec3sToVec3f(&mut (*anim).unk_00,
                                &mut *bgData.offset(0 as libc::c_int as
                                                        isize));
            (*anim).unk_20 = (*bgData.offset(1 as libc::c_int as isize)).x;
            (*anim).unk_22 = (*bgData.offset(1 as libc::c_int as isize)).y;
            (*anim).unk_24 = (*playerPosRot).pos.y;
            (*anim).unk_1C =
                if (*bgData.offset(2 as libc::c_int as isize)).x as
                       libc::c_int == -(1 as libc::c_int) {
                    (*norm2).unk_14
                } else if (*bgData.offset(2 as libc::c_int as isize)).x as
                              libc::c_int >= 0x169 as libc::c_int {
                    ((*bgData.offset(2 as libc::c_int as isize)).x as
                         libc::c_int as libc::c_float) * 0.01f32
                } else {
                    (*bgData.offset(2 as libc::c_int as isize)).x as
                        libc::c_int as libc::c_float
                };
            (*anim).unk_28 =
                if (*bgData.offset(2 as libc::c_int as isize)).y as
                       libc::c_int == -(1 as libc::c_int) {
                    0 as libc::c_int
                } else {
                    (*bgData.offset(2 as libc::c_int as isize)).y as
                        libc::c_int
                } as s16;
            (*anim).unk_18 = 0.0f32;
            if (*norm2).interfaceFlags as libc::c_int & 4 as libc::c_int != 0
               {
                sp88.pitch = (*anim).unk_20;
                sp88.yaw =
                    ((*anim).unk_22 as libc::c_int + 0x3fff as libc::c_int) as
                        s16;
                sp88.r = 100.0f32;
                OLib_VecSphGeoToVec3f(&mut (*anim).unk_0C, &mut sp88);
            }
            (*camera).animState = 1 as libc::c_int as s16;
            (*camera).yawUpdateRateInv = 50.0f32
        }
        _ => {
            if (*camera).playerGroundY == (*playerPosRot).pos.y {
                (*anim).unk_24 = (*playerPosRot).pos.y
            }
        }
    }
    OLib_Vec3fDiffToVecSphGeo(&mut atToEyeDir, at, eye);
    OLib_Vec3fDiffToVecSphGeo(&mut atToEyeNextDir, at, eyeNext);
    (*camera).speedRatio *= 0.5f32;
    spA4 =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 25 as libc::c_int) as
                              usize] as libc::c_int as libc::c_float * 0.01f32
            * (*camera).speedRatio;
    spA0 =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 26 as libc::c_int) as
                              usize] as libc::c_int as libc::c_float * 0.01f32
            * (*camera).speedRatio;
    (*camera).yawUpdateRateInv =
        Camera_LERPCeilF((*norm2).unk_0C,
                         (*camera).yawUpdateRateInv * (*camera).speedRatio,
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                25 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32,
                         0.1f32);
    (*camera).pitchUpdateRateInv =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                7 as libc::c_int) as usize] as
                             f32_0, (*camera).pitchUpdateRateInv, spA0,
                         0.1f32);
    (*camera).xzOffsetUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                2 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).xzOffsetUpdateRate, spA4, 0.1f32);
    (*camera).yOffsetUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                3 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).yOffsetUpdateRate, spA0, 0.1f32);
    (*camera).fovUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                4 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).yOffsetUpdateRate,
                         (*camera).speedRatio * 0.05f32, 0.1f32);
    if (*norm2).interfaceFlags as libc::c_int & 0x80 as libc::c_int == 0 {
        Camera_CalcAtDefault(camera, &mut atToEyeNextDir, (*norm2).unk_00,
                             ((*norm2).interfaceFlags as libc::c_int &
                                  1 as libc::c_int) as s16);
    } else {
        func_800458D4(camera, &mut atToEyeNextDir, (*norm2).unk_00,
                      &mut (*anim).unk_24,
                      ((*norm2).interfaceFlags as libc::c_int &
                           1 as libc::c_int) as s16);
    }
    if (*norm2).interfaceFlags as libc::c_int & 4 as libc::c_int != 0 {
        (*anim).unk_00.x = (*playerPosRot).pos.x + (*anim).unk_0C.x;
        (*anim).unk_00.z = (*playerPosRot).pos.z + (*anim).unk_0C.z
    }
    (*anim).unk_00.y = (*playerPosRot).pos.y;
    OLib_Vec3fDiffToVecSphGeo(&mut sp88, &mut (*anim).unk_00, at);
    OLib_Vec3fDiffToVecSphGeo(&mut sp90, at, eyeNext);
    phi_a1 =
        if (*anim).unk_28 as libc::c_int & 2 as libc::c_int != 0 {
            (*anim).unk_22 as libc::c_int
        } else { (*norm2).unk_1C as libc::c_int } as s16;
    phi_a0 = (sp90.yaw as libc::c_int - sp88.yaw as libc::c_int) as s16;
    if (phi_a1 as libc::c_int) < 0x4000 as libc::c_int &&
           (if phi_a0 as libc::c_int >= 0 as libc::c_int {
                phi_a0 as libc::c_int
            } else { -(phi_a0 as libc::c_int) }) > phi_a1 as libc::c_int ||
           phi_a1 as libc::c_int >= 0x4000 as libc::c_int &&
               (if phi_a0 as libc::c_int >= 0 as libc::c_int {
                    phi_a0 as libc::c_int
                } else { -(phi_a0 as libc::c_int) }) < phi_a1 as libc::c_int {
        phi_a0 =
            if (phi_a0 as libc::c_int) < 0 as libc::c_int {
                -(phi_a1 as libc::c_int)
            } else { phi_a1 as libc::c_int } as s16;
        phi_a0 = (phi_a0 as libc::c_int + sp88.yaw as libc::c_int) as s16;
        adjSph.yaw =
            Camera_LERPCeilS(phi_a0, atToEyeDir.yaw,
                             1.0f32 / (*camera).yawUpdateRateInv *
                                 (*camera).speedRatio,
                             0xa as libc::c_int as s16);
        if (*anim).unk_28 as libc::c_int & 1 as libc::c_int != 0 {
            adjSph.pitch =
                Camera_CalcDefaultPitch(camera, atToEyeNextDir.pitch,
                                        (*anim).unk_20,
                                        0 as libc::c_int as s16)
        } else { adjSph.pitch = atToEyeDir.pitch }
    } else { adjSph = sp90 }
    adjSph.r =
        Camera_ClampDist(camera, sp90.r, (*norm2).unk_04, (*norm2).unk_08,
                         0 as libc::c_int as s16);
    (*camera).dist = adjSph.r;
    if (*anim).unk_28 as libc::c_int & 1 as libc::c_int == 0 {
        if adjSph.pitch as libc::c_int >= 0xe39 as libc::c_int {
            adjSph.pitch =
                (adjSph.pitch as libc::c_int +
                     ((0xe38 as libc::c_int - adjSph.pitch as libc::c_int) as
                          s16 as libc::c_int >> 2 as libc::c_int)) as s16
        }
        if (adjSph.pitch as libc::c_int) < 0 as libc::c_int {
            adjSph.pitch =
                (adjSph.pitch as libc::c_int +
                     ((-(0x38e as libc::c_int) - adjSph.pitch as libc::c_int)
                          as s16 as libc::c_int >> 2 as libc::c_int)) as s16
        }
    }
    Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut adjSph);
    if (*camera).status as libc::c_int == 7 as libc::c_int {
        bgChk.pos = *eyeNext;
        if (*(*camera).globalCtx).envCtx.skyboxDisabled == 0 ||
               (*norm2).interfaceFlags as libc::c_int & 0x10 as libc::c_int !=
                   0 {
            Camera_BGCheckInfo(camera, at, &mut bgChk);
            *eye = bgChk.pos
        } else {
            func_80043F94(camera, at, &mut bgChk);
            *eye = bgChk.pos;
            OLib_Vec3fDiffToVecSphGeo(&mut adjSph, eye, at);
            (*camera).inputDir.x = adjSph.pitch;
            (*camera).inputDir.y = adjSph.yaw;
            (*camera).inputDir.z = 0 as libc::c_int as s16
        }
    }
    (*camera).fov =
        Camera_LERPCeilF((*anim).unk_1C, (*camera).fov,
                         (*camera).fovUpdateRate, 1.0f32);
    (*camera).roll =
        Camera_LERPCeilS(0 as libc::c_int as s16, (*camera).roll, 0.5f32,
                         0xa as libc::c_int as s16);
    (*camera).atLERPStepScale =
        Camera_ClampLERPScale(camera, (*norm2).unk_18);
    return 1 as libc::c_int;
}
// riding epona
#[no_mangle]
pub unsafe extern "C" fn Camera_Normal3(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut sp98: f32_0 = 0.;
    let mut sp94: f32_0 = 0.;
    let mut sp90: f32_0 = 0.;
    let mut sp8C: f32_0 = 0.;
    let mut sp84: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut sp7C: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut sp74: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut temp_f0: f32_0 = 0.;
    let mut temp_f6: f32_0 = 0.;
    let mut phi_a0: s16 = 0;
    let mut t2: s16 = 0;
    let mut norm3: *mut Normal3 =
        (*camera).paramData.as_mut_ptr() as *mut Normal3;
    let mut anim: *mut Normal3Anim = &mut (*norm3).anim;
    let mut playerHeight: f32_0 = 0.;
    playerHeight = Player_GetHeight((*camera).player);
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let fresh19 = values;
        values = values.offset(1);
        (*norm3).yOffset =
            (*fresh19).val as libc::c_int as libc::c_float *
                (playerHeight * 0.01f32);
        let fresh20 = values;
        values = values.offset(1);
        (*norm3).distMin =
            (*fresh20).val as libc::c_int as libc::c_float *
                (playerHeight * 0.01f32);
        let fresh21 = values;
        values = values.offset(1);
        (*norm3).distMax =
            (*fresh21).val as libc::c_int as libc::c_float *
                (playerHeight * 0.01f32);
        let fresh22 = values;
        values = values.offset(1);
        (*norm3).pitchTarget =
            ((*fresh22).val as libc::c_int as libc::c_float * 182.04167f32 +
                 0.5f32) as s16;
        let fresh23 = values;
        values = values.offset(1);
        (*norm3).yawUpdateSpeed = (*fresh23).val as f32_0;
        let fresh24 = values;
        values = values.offset(1);
        (*norm3).unk_10 = (*fresh24).val as f32_0;
        let fresh25 = values;
        values = values.offset(1);
        (*norm3).fovTarget = (*fresh25).val as f32_0;
        let fresh26 = values;
        values = values.offset(1);
        (*norm3).maxAtLERPScale =
            (*fresh26).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh27 = values;
        values = values.offset(1);
        (*norm3).interfaceFlags = (*fresh27).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    OLib_Vec3fDiffToVecSphGeo(&mut sp7C, at, eye);
    OLib_Vec3fDiffToVecSphGeo(&mut sp74, at, eyeNext);
    sUpdateCameraDirection = 1 as libc::c_int;
    sCameraInterfaceFlags = (*norm3).interfaceFlags as s32;
    match (*camera).animState as libc::c_int {
        0 | 10 | 20 | 25 => {
            (*anim).swing.atEyePoly = 0 as *mut CollisionPoly;
            (*anim).curPitch = 0 as libc::c_int as s16;
            (*anim).unk_1C = 0.0f32;
            (*anim).unk_20 = (*camera).playerGroundY;
            (*anim).swing.unk_18 = 0 as libc::c_int as s16;
            (*anim).swing.unk_14 = (*anim).swing.unk_18;
            (*anim).swing.unk_16 = (*anim).swing.unk_14;
            (*anim).swing.swingUpdateRate = (*norm3).yawUpdateSpeed;
            (*anim).yawUpdAmt =
                ((((*playerPosRot).rot.y as libc::c_int -
                       0x7fff as libc::c_int) as s16 as libc::c_int -
                      sp7C.yaw as libc::c_int) as s16 as libc::c_int as
                     libc::c_float *
                     (1.0f32 /
                          (*gGameInfo).data[(2 as libc::c_int *
                                                 6 as libc::c_int *
                                                 16 as libc::c_int +
                                                 23 as libc::c_int) as usize]
                              as libc::c_int as libc::c_float)) as s16;
            (*anim).distTimer = 10 as libc::c_int as s16;
            (*anim).yawTimer =
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 23 as libc::c_int)
                                      as usize];
            (*camera).animState = 1 as libc::c_int as s16;
            (*anim).swing.swingUpdateRateTimer = 0 as libc::c_int as s16
        }
        _ => { }
    }
    if (*anim).distTimer as libc::c_int != 0 as libc::c_int {
        (*anim).distTimer -= 1
    }
    sp98 =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 25 as libc::c_int) as
                              usize] as libc::c_int as libc::c_float * 0.01f32
            * (*camera).speedRatio;
    sp94 =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 26 as libc::c_int) as
                              usize] as libc::c_int as libc::c_float * 0.01f32
            * (*camera).speedRatio;
    if (*anim).swing.swingUpdateRateTimer as libc::c_int != 0 as libc::c_int {
        (*camera).yawUpdateRateInv =
            Camera_LERPCeilF((*norm3).yawUpdateSpeed +
                                 ((*anim).swing.swingUpdateRateTimer as
                                      libc::c_int * 2 as libc::c_int) as
                                     libc::c_float,
                             (*camera).yawUpdateRateInv, sp98, 0.1f32);
        (*camera).pitchUpdateRateInv =
            Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    7 as libc::c_int) as
                                                   usize] as f32_0 +
                                 ((*anim).swing.swingUpdateRateTimer as
                                      libc::c_int * 2 as libc::c_int) as
                                     libc::c_float,
                             (*camera).pitchUpdateRateInv, sp94, 0.1f32);
        (*anim).swing.swingUpdateRateTimer -= 1
    } else {
        (*camera).yawUpdateRateInv =
            Camera_LERPCeilF((*norm3).yawUpdateSpeed,
                             (*camera).yawUpdateRateInv, sp98, 0.1f32);
        (*camera).pitchUpdateRateInv =
            Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    7 as libc::c_int) as
                                                   usize] as f32_0,
                             (*camera).pitchUpdateRateInv, sp94, 0.1f32)
    }
    (*camera).xzOffsetUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                2 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).xzOffsetUpdateRate, sp98, 0.1f32);
    (*camera).yOffsetUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                3 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).yOffsetUpdateRate, sp94, 0.1f32);
    (*camera).fovUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                4 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).fovUpdateRate, sp94, 0.1f32);
    t2 =
        func_80044ADC(camera,
                      (sp7C.yaw as libc::c_int - 0x7fff as libc::c_int) as
                          s16, 1 as libc::c_int as s16);
    sp94 = 1.0f32 / (*norm3).unk_10 * 0.5f32;
    temp_f0 =
        1.0f32 / (*norm3).unk_10 * 0.5f32 * (1.0f32 - (*camera).speedRatio);
    (*anim).curPitch =
        Camera_LERPCeilS(t2, (*anim).curPitch, sp94 + temp_f0,
                         0xf as libc::c_int as s16);
    Camera_CalcAtForHorse(camera, &mut sp74, (*norm3).yOffset,
                          &mut (*anim).unk_20, 1 as libc::c_int as s16);
    sp90 = ((*norm3).distMax + (*norm3).distMin) * 0.5f32;
    OLib_Vec3fDiffToVecSphGeo(&mut sp84, at, eyeNext);
    sp84.r =
        Camera_ClampDist(camera, sp84.r, (*norm3).distMin, (*norm3).distMax,
                         (*anim).distTimer);
    (*camera).dist = sp84.r;
    if (*camera).xzSpeed > 0.001f32 { sp84.r += (sp90 - sp84.r) * 0.002f32 }
    phi_a0 =
        ((*norm3).pitchTarget as libc::c_int -
             (*anim).curPitch as libc::c_int) as s16;
    sp84.pitch =
        Camera_LERPCeilS(phi_a0, sp74.pitch,
                         1.0f32 / (*camera).pitchUpdateRateInv,
                         0xa as libc::c_int as s16);
    if ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 5 as libc::c_int) as usize]
            as libc::c_int) < sp84.pitch as libc::c_int {
        sp84.pitch =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 5 as libc::c_int) as
                                  usize]
    }
    if (sp84.pitch as libc::c_int) <
           (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 34 as libc::c_int) as
                                 usize] as libc::c_int {
        sp84.pitch =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 34 as libc::c_int) as
                                  usize]
    }
    phi_a0 =
        ((*playerPosRot).rot.y as libc::c_int -
             (sp74.yaw as libc::c_int - 0x7fff as libc::c_int) as s16 as
                 libc::c_int) as s16;
    if (if phi_a0 as libc::c_int >= 0 as libc::c_int {
            phi_a0 as libc::c_int
        } else { -(phi_a0 as libc::c_int) }) > 0x2af8 as libc::c_int {
        if phi_a0 as libc::c_int > 0 as libc::c_int {
            phi_a0 = 0x2af8 as libc::c_int as s16
        } else { phi_a0 = -(0x2af8 as libc::c_int) as s16 }
    }
    sp90 = 1.0f32;
    sp98 = 0.5f64 as f32_0;
    sp94 = (*camera).speedRatio;
    sp90 -= sp98;
    sp98 = sp98 + sp94 * sp90;
    sp98 =
        sp98 * phi_a0 as libc::c_int as libc::c_float /
            (*camera).yawUpdateRateInv;
    sp84.yaw =
        if fabsf(sp98) > 150.0f32 * (1.0f32 - (*camera).speedRatio) {
            (sp74.yaw as libc::c_int as libc::c_float + sp98) as s16 as
                libc::c_int
        } else { sp74.yaw as libc::c_int } as s16;
    if (*anim).yawTimer as libc::c_int > 0 as libc::c_int {
        sp84.yaw =
            (sp84.yaw as libc::c_int + (*anim).yawUpdAmt as libc::c_int) as
                s16;
        (*anim).yawTimer -= 1
    }
    Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut sp84);
    if (*camera).status as libc::c_int == 7 as libc::c_int {
        func_80046E20(camera, &mut sp84, (*norm3).distMin,
                      (*norm3).yawUpdateSpeed, &mut sp8C, &mut (*anim).swing);
    } else { *eye = *eyeNext }
    (*camera).fov =
        Camera_LERPCeilF((*norm3).fovTarget, (*camera).fov,
                         (*camera).fovUpdateRate, 1.0f32);
    (*camera).roll =
        Camera_LERPCeilS(0 as libc::c_int as s16, (*camera).roll, 0.5f32,
                         0xa as libc::c_int as s16);
    (*camera).atLERPStepScale =
        Camera_ClampLERPScale(camera, (*norm3).maxAtLERPScale);
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Normal4(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Normal0(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Parallel1(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut spB8: f32_0 = 0.;
    let mut spB4: f32_0 = 0.;
    let mut tangle: s16 = 0;
    let mut spA8: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut atToEyeDir: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut atToEyeNextDir: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut sp6C: CamColChk =
        CamColChk{pos: Vec3f{x: 0., y: 0., z: 0.,},
                  norm: Vec3f{x: 0., y: 0., z: 0.,},
                  poly: 0 as *mut CollisionPoly,
                  sphNorm: VecSph{r: 0., pitch: 0, yaw: 0,},
                  bgId: 0,};
    let mut sp6A: s16 = 0;
    let mut phi_a0: s16 = 0;
    let mut para1: *mut Parallel1 =
        (*camera).paramData.as_mut_ptr() as *mut Parallel1;
    let mut anim: *mut Parallel1Anim = &mut (*para1).anim;
    let mut pad2: f32_0 = 0.;
    let mut playerHeight: f32_0 = 0.;
    let mut pad3: s32 = 0;
    playerHeight = Player_GetHeight((*camera).player);
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let mut yNormal: f32_0 =
            1.0f32 +
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 -
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 * (68.0f32 / playerHeight);
        let fresh28 = values;
        values = values.offset(1);
        (*para1).unk_00 =
            (*fresh28).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh29 = values;
        values = values.offset(1);
        (*para1).distTarget =
            (*fresh29).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh30 = values;
        values = values.offset(1);
        (*para1).pitchTarget =
            ((*fresh30).val as libc::c_int as libc::c_float * 182.04167f32 +
                 0.5f32) as s16;
        let fresh31 = values;
        values = values.offset(1);
        (*para1).yawTarget =
            ((*fresh31).val as libc::c_int as libc::c_float * 182.04167f32 +
                 0.5f32) as s16;
        let fresh32 = values;
        values = values.offset(1);
        (*para1).unk_08 = (*fresh32).val as f32_0;
        let fresh33 = values;
        values = values.offset(1);
        (*para1).unk_0C = (*fresh33).val as f32_0;
        let fresh34 = values;
        values = values.offset(1);
        (*para1).fovTarget = (*fresh34).val as f32_0;
        let fresh35 = values;
        values = values.offset(1);
        (*para1).unk_14 =
            (*fresh35).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh36 = values;
        values = values.offset(1);
        (*para1).interfaceFlags = (*fresh36).val;
        let fresh37 = values;
        values = values.offset(1);
        (*para1).unk_18 =
            (*fresh37).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh38 = values;
        values = values.offset(1);
        (*para1).unk_1C =
            (*fresh38).val as libc::c_int as libc::c_float * 0.01f32
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    OLib_Vec3fDiffToVecSphGeo(&mut atToEyeDir, at, eye);
    OLib_Vec3fDiffToVecSphGeo(&mut atToEyeNextDir, at, eyeNext);
    match (*camera).animState as libc::c_int {
        0 | 10 | 20 | 25 => {
            (*anim).unk_16 = 0 as libc::c_int as s16;
            (*anim).unk_10 = 0 as libc::c_int as s16;
            if (*para1).interfaceFlags as libc::c_int & 4 as libc::c_int != 0
               {
                (*anim).animTimer = 20 as libc::c_int as s16
            } else {
                (*anim).animTimer =
                    (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                           16 as libc::c_int +
                                           23 as libc::c_int) as usize]
            }
            (*anim).unk_00.x = 0.0f32;
            (*anim).yTarget =
                (*playerPosRot).pos.y - (*camera).playerPosDelta.y;
            (*camera).animState += 1
        }
        _ => { }
    }
    if (*anim).animTimer as libc::c_int != 0 as libc::c_int {
        if (*para1).interfaceFlags as libc::c_int & 2 as libc::c_int != 0 {
            // Rotate para1->yawTarget degrees from behind the player.
            (*anim).yawTarget =
                (((*playerPosRot).rot.y as libc::c_int -
                      0x7fff as libc::c_int) as s16 as libc::c_int +
                     (*para1).yawTarget as libc::c_int) as s16
        } else if (*para1).interfaceFlags as libc::c_int & 4 as libc::c_int !=
                      0 {
            // rotate to para1->yawTarget
            (*anim).yawTarget = (*para1).yawTarget
        } else {
            // leave the rotation alone.
            (*anim).yawTarget = atToEyeNextDir.yaw
        }
    } else {
        if (*para1).interfaceFlags as libc::c_int & 0x20 as libc::c_int != 0 {
            (*anim).yawTarget =
                (((*playerPosRot).rot.y as libc::c_int -
                      0x7fff as libc::c_int) as s16 as libc::c_int +
                     (*para1).yawTarget as libc::c_int) as s16
        }
        sCameraInterfaceFlags = (*para1).interfaceFlags as s32
    }
    (*anim).pitchTarget = (*para1).pitchTarget;
    if (*camera).animState as libc::c_int == 0x15 as libc::c_int {
        (*anim).unk_16 = 1 as libc::c_int as s16;
        (*camera).animState = 1 as libc::c_int as s16
    } else if (*camera).animState as libc::c_int == 0xb as libc::c_int {
        (*camera).animState = 1 as libc::c_int as s16
    }
    spB8 =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 25 as libc::c_int) as
                              usize] as libc::c_int as libc::c_float * 0.01f32
            * (*camera).speedRatio;
    spB4 =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 26 as libc::c_int) as
                              usize] as libc::c_int as libc::c_float * 0.01f32
            * (*camera).speedRatio;
    (*camera).rUpdateRateInv =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                6 as libc::c_int) as usize] as
                             f32_0, (*camera).rUpdateRateInv, spB8, 0.1f32);
    (*camera).yawUpdateRateInv =
        Camera_LERPCeilF((*para1).unk_08, (*camera).yawUpdateRateInv, spB8,
                         0.1f32);
    (*camera).pitchUpdateRateInv =
        Camera_LERPCeilF(2.0f32, (*camera).pitchUpdateRateInv, spB4, 0.1f32);
    (*camera).xzOffsetUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                2 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).xzOffsetUpdateRate, spB8, 0.1f32);
    (*camera).yOffsetUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                3 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).yOffsetUpdateRate, spB4, 0.1f32);
    (*camera).fovUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                4 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).fovUpdateRate,
                         (*camera).speedRatio * 0.05f32, 0.1f32);
    if (*para1).interfaceFlags as libc::c_int & 1 as libc::c_int != 0 {
        tangle =
            func_80044ADC(camera,
                          (atToEyeDir.yaw as libc::c_int -
                               0x7fff as libc::c_int) as s16,
                          1 as libc::c_int as s16);
        spB8 = 1.0f32 / (*para1).unk_0C * 0.3f32;
        pad2 =
            1.0f32 / (*para1).unk_0C * 0.7f32 *
                (1.0f32 - (*camera).speedRatio);
        (*anim).unk_10 =
            Camera_LERPCeilS(tangle, (*anim).unk_10, spB8 + pad2,
                             0xf as libc::c_int as s16)
    } else { (*anim).unk_10 = 0 as libc::c_int as s16 }
    if (*camera).playerGroundY == (*camera).playerPosRot.pos.y ||
           (*(*camera).player).actor.gravity > -0.1f32 ||
           (*(*camera).player).stateFlags1 &
               0x200000 as libc::c_int as libc::c_uint != 0 {
        (*anim).yTarget = (*playerPosRot).pos.y;
        sp6A = 0 as libc::c_int as s16
    } else { sp6A = 1 as libc::c_int as s16 }
    if (*para1).interfaceFlags as libc::c_int & 0x80 as libc::c_int == 0 &&
           sp6A == 0 {
        Camera_CalcAtForParallel(camera, &mut atToEyeNextDir, (*para1).unk_00,
                                 &mut (*anim).yTarget,
                                 ((*para1).interfaceFlags as libc::c_int &
                                      1 as libc::c_int) as s16);
    } else {
        func_800458D4(camera, &mut atToEyeNextDir, (*para1).unk_18,
                      &mut (*anim).yTarget,
                      ((*para1).interfaceFlags as libc::c_int &
                           1 as libc::c_int) as s16);
    }
    if (*anim).animTimer as libc::c_int != 0 as libc::c_int {
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int | 0x20 as libc::c_int) as s16;
        tangle =
            (((*anim).animTimer as libc::c_int + 1 as libc::c_int) *
                 (*anim).animTimer as libc::c_int >> 1 as libc::c_int) as s16;
        spA8.yaw =
            (atToEyeDir.yaw as libc::c_int +
                 ((*anim).yawTarget as libc::c_int -
                      atToEyeDir.yaw as libc::c_int) as s16 as libc::c_int /
                     tangle as libc::c_int * (*anim).animTimer as libc::c_int)
                as s16;
        spA8.pitch = atToEyeDir.pitch;
        spA8.r = atToEyeDir.r;
        (*anim).animTimer -= 1
    } else {
        (*anim).unk_16 = 0 as libc::c_int as s16;
        (*camera).dist =
            Camera_LERPCeilF((*para1).distTarget, (*camera).dist,
                             1.0f32 / (*camera).rUpdateRateInv, 2.0f32);
        OLib_Vec3fDiffToVecSphGeo(&mut spA8, at, eyeNext);
        spA8.r = (*camera).dist;
        if (*para1).interfaceFlags as libc::c_int & 0x40 as libc::c_int != 0 {
            spA8.yaw =
                Camera_LERPCeilS((*anim).yawTarget, atToEyeNextDir.yaw,
                                 0.6f32, 0xa as libc::c_int as s16)
        } else {
            spA8.yaw =
                Camera_LERPCeilS((*anim).yawTarget, atToEyeNextDir.yaw,
                                 0.8f32, 0xa as libc::c_int as s16)
        }
        if (*para1).interfaceFlags as libc::c_int & 1 as libc::c_int != 0 {
            phi_a0 =
                ((*anim).pitchTarget as libc::c_int -
                     (*anim).unk_10 as libc::c_int) as s16
        } else { phi_a0 = (*anim).pitchTarget }
        spA8.pitch =
            Camera_LERPCeilS(phi_a0, atToEyeNextDir.pitch,
                             1.0f32 / (*camera).pitchUpdateRateInv,
                             4 as libc::c_int as s16);
        if spA8.pitch as libc::c_int >
               (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                      16 as libc::c_int + 5 as libc::c_int) as
                                     usize] as libc::c_int {
            spA8.pitch =
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 5 as libc::c_int)
                                      as usize]
        }
        if (spA8.pitch as libc::c_int) <
               (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                      16 as libc::c_int + 34 as libc::c_int)
                                     as usize] as libc::c_int {
            spA8.pitch =
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 34 as libc::c_int)
                                      as usize]
        }
    }
    Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut spA8);
    if (*camera).status as libc::c_int == 7 as libc::c_int {
        sp6C.pos = *eyeNext;
        if (*(*camera).globalCtx).envCtx.skyboxDisabled == 0 ||
               (*para1).interfaceFlags as libc::c_int & 0x10 as libc::c_int !=
                   0 {
            Camera_BGCheckInfo(camera, at, &mut sp6C);
            *eye = sp6C.pos
        } else {
            func_80043F94(camera, at, &mut sp6C);
            *eye = sp6C.pos;
            OLib_Vec3fDiffToVecSphGeo(&mut spA8, eye, at);
            (*camera).inputDir.x = spA8.pitch;
            (*camera).inputDir.y = spA8.yaw;
            (*camera).inputDir.z = 0 as libc::c_int as s16
        }
    }
    (*camera).fov =
        Camera_LERPCeilF((*para1).fovTarget, (*camera).fov,
                         (*camera).fovUpdateRate, 1.0f32);
    (*camera).roll =
        Camera_LERPCeilS(0 as libc::c_int as s16, (*camera).roll,
                         0.5f64 as f32_0, 0xa as libc::c_int as s16);
    (*camera).atLERPStepScale =
        Camera_ClampLERPScale(camera,
                              if sp6A as libc::c_int != 0 {
                                  (*para1).unk_1C
                              } else { (*para1).unk_14 });
    panic!("Reached end of non-void function without returning");
    // ! @bug No return
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Parallel2(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Parallel3(mut camera: *mut Camera) -> s32 {
    let mut values: *mut CameraModeValue =
        (*sCameraSettings[(*camera).setting as
                              usize].cameraModes.offset((*camera).mode as
                                                            isize)).values;
    let fresh39 = values;
    values = values.offset(1);
    let mut val: s16 = (*fresh39).val;
    sCameraInterfaceFlags = val as s32;
    if val as libc::c_int & 1 as libc::c_int != 0 {
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int | 0x400 as libc::c_int) as s16
    }
    if val as libc::c_int & 2 as libc::c_int != 0 {
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int | 0x10 as libc::c_int) as s16
    }
    panic!("Reached end of non-void function without returning");
    // ! @bug doesn't return
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Parallel4(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Parallel0(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
/* *
 * Generic jump, jumping off ledges
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Jump1(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut pad2: s32 = 0;
    let mut spA4: f32_0 = 0.;
    let mut newEye: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut eyeAtOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut eyeNextAtOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut eyeDiffSph: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut eyeDiffTarget: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut playerhead: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut tangle: s16 = 0;
    let mut jump1: *mut Jump1 =
        (*camera).paramData.as_mut_ptr() as *mut Jump1;
    let mut anim: *mut Jump1Anim = &mut (*jump1).anim;
    let mut pad: s32 = 0;
    let mut playerHeight: f32_0 = 0.;
    playerHeight = Player_GetHeight((*camera).player);
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let mut yNormal: f32_0 =
            1.0f32 +
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 -
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 * (68.0f32 / playerHeight);
        let fresh40 = values;
        values = values.offset(1);
        (*jump1).atYOffset =
            (*fresh40).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh41 = values;
        values = values.offset(1);
        (*jump1).distMin =
            (*fresh41).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh42 = values;
        values = values.offset(1);
        (*jump1).distMax =
            (*fresh42).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh43 = values;
        values = values.offset(1);
        (*jump1).yawUpateRateTarget = (*fresh43).val as f32_0;
        let fresh44 = values;
        values = values.offset(1);
        (*jump1).maxYawUpdate =
            (*fresh44).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh45 = values;
        values = values.offset(1);
        (*jump1).unk_14 = (*fresh45).val as f32_0;
        let fresh46 = values;
        values = values.offset(1);
        (*jump1).atLERPScaleMax =
            (*fresh46).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh47 = values;
        values = values.offset(1);
        (*jump1).interfaceFlags = (*fresh47).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    // playerhead never gets used.
    Actor_GetFocus(&mut playerhead, &mut (*(*camera).player).actor);
    OLib_Vec3fDiffToVecSphGeo(&mut eyeAtOffset, at, eye);
    OLib_Vec3fDiffToVecSphGeo(&mut eyeNextAtOffset, at, eyeNext);
    sCameraInterfaceFlags = (*jump1).interfaceFlags as s32;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int {
        (*anim).swing.unk_18 = 0 as libc::c_int as s16;
        (*anim).swing.unk_16 = (*anim).swing.unk_18;
        (*anim).swing.atEyePoly = 0 as *mut CollisionPoly;
        (*anim).unk_20.pitch = 0 as libc::c_int as s16;
        (*anim).unk_20.yaw = 0xc8 as libc::c_int as s16;
        (*anim).swing.swingUpdateRateTimer = 0 as libc::c_int as s16;
        (*anim).swing.swingUpdateRate = (*jump1).yawUpateRateTarget;
        (*anim).unk_1C = (*playerPosRot).pos.y - (*camera).playerPosDelta.y;
        (*anim).unk_20.r = eyeAtOffset.r;
        (*camera).posOffset.y -= (*camera).playerPosDelta.y;
        (*camera).xzOffsetUpdateRate = 1.0f32 / 10000.0f32;
        (*camera).animState += 1
    }
    if (*anim).swing.swingUpdateRateTimer as libc::c_int != 0 as libc::c_int {
        (*camera).yawUpdateRateInv =
            Camera_LERPCeilF((*jump1).yawUpateRateTarget +
                                 (*anim).swing.swingUpdateRateTimer as
                                     libc::c_int as libc::c_float,
                             (*camera).yawUpdateRateInv,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    26 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32, 0.1f32);
        (*camera).pitchUpdateRateInv =
            Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    7 as libc::c_int) as
                                                   usize] as f32_0 +
                                 (*anim).swing.swingUpdateRateTimer as
                                     libc::c_int as libc::c_float,
                             (*camera).pitchUpdateRateInv,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    26 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32, 0.1f32);
        (*anim).swing.swingUpdateRateTimer -= 1
    } else {
        (*camera).yawUpdateRateInv =
            Camera_LERPCeilF((*jump1).yawUpateRateTarget,
                             (*camera).yawUpdateRateInv,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    26 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32, 0.1f32);
        (*camera).pitchUpdateRateInv =
            Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    7 as libc::c_int) as
                                                   usize] as f32_0,
                             (*camera).pitchUpdateRateInv,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    26 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32, 0.1f32)
    }
    (*camera).xzOffsetUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                2 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).xzOffsetUpdateRate,
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                25 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32,
                         0.1f32);
    (*camera).yOffsetUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                3 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).yOffsetUpdateRate,
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                26 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32,
                         0.1f32);
    (*camera).fovUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                4 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).yOffsetUpdateRate, 0.05f32, 0.1f32);
    func_800458D4(camera, &mut eyeNextAtOffset, (*jump1).atYOffset,
                  &mut (*anim).unk_1C, 0 as libc::c_int as s16);
    eyeDiffSph = eyeAtOffset;
    OLib_Vec3fDiffToVecSphGeo(&mut eyeDiffTarget, at, eye);
    eyeDiffSph.r =
        Camera_LERPCeilF(eyeDiffTarget.r, eyeAtOffset.r,
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                29 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32,
                         1.0f32);
    eyeDiffSph.pitch =
        Camera_LERPCeilS(eyeDiffTarget.pitch, eyeAtOffset.pitch,
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                29 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32,
                         0xa as libc::c_int as s16);
    if (*anim).swing.unk_18 != 0 {
        eyeDiffSph.yaw =
            Camera_LERPCeilS((*anim).swing.unk_16, eyeNextAtOffset.yaw,
                             1.0f32 / (*camera).yawUpdateRateInv,
                             0xa as libc::c_int as s16);
        eyeDiffSph.pitch =
            Camera_LERPCeilS((*anim).swing.unk_14, eyeNextAtOffset.pitch,
                             1.0f32 / (*camera).yawUpdateRateInv,
                             0xa as libc::c_int as s16)
    } else {
        eyeDiffSph.yaw =
            Camera_CalcDefaultYaw(camera, eyeNextAtOffset.yaw,
                                  (*camera).playerPosRot.rot.y,
                                  (*jump1).maxYawUpdate, 0.0f32)
    }
    // Clamp the eye->at distance to jump1->distMin < eyeDiffSph.r < jump1->distMax
    if eyeDiffSph.r < (*jump1).distMin {
        eyeDiffSph.r = (*jump1).distMin
    } else if eyeDiffSph.r > (*jump1).distMax {
        eyeDiffSph.r = (*jump1).distMax
    }
    // Clamp the phi rotation at R_CAM_MAX_PHI AND R_CAM_MIN_PHI2
    if eyeDiffSph.pitch as libc::c_int >
           (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 5 as libc::c_int) as
                                 usize] as libc::c_int {
        eyeDiffSph.pitch =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 5 as libc::c_int) as
                                  usize]
    } else if (eyeDiffSph.pitch as libc::c_int) <
                  (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                         16 as libc::c_int +
                                         35 as libc::c_int) as usize] as
                      libc::c_int {
        eyeDiffSph.pitch =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 35 as libc::c_int) as
                                  usize]
    }
    Camera_Vec3fVecSphGeoAdd(&mut newEye, at, &mut eyeDiffSph);
    (*eyeNext).x = newEye.x;
    (*eyeNext).z = newEye.z;
    (*eyeNext).y +=
        (newEye.y - (*eyeNext).y) *
            ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                    16 as libc::c_int + 31 as libc::c_int) as
                                   usize] as libc::c_int as libc::c_float *
                 0.01f32);
    if (*camera).status as libc::c_int == 7 as libc::c_int &&
           (*jump1).interfaceFlags as libc::c_int & 0x10 as libc::c_int == 0 {
        func_80046E20(camera, &mut eyeDiffSph, (*jump1).distMin,
                      (*jump1).yawUpateRateTarget, &mut spA4,
                      &mut (*anim).swing);
        if (*jump1).interfaceFlags as libc::c_int & 4 as libc::c_int != 0 {
            (*camera).inputDir.x = -(eyeAtOffset.pitch as libc::c_int) as s16;
            (*camera).inputDir.y =
                (eyeAtOffset.yaw as libc::c_int - 0x7fff as libc::c_int) as
                    s16;
            (*camera).inputDir.z = 0 as libc::c_int as s16
        } else {
            OLib_Vec3fDiffToVecSphGeo(&mut eyeDiffSph, eye, at);
            (*camera).inputDir.x = eyeDiffSph.pitch;
            (*camera).inputDir.y = eyeDiffSph.yaw;
            (*camera).inputDir.z = 0 as libc::c_int as s16
        }
        if (*anim).swing.unk_18 != 0 {
            (*camera).inputDir.y =
                Camera_LERPCeilS(((*camera).inputDir.y as libc::c_int +
                                      (((*anim).swing.unk_16 as libc::c_int -
                                            0x7fff as libc::c_int) as s16 as
                                           libc::c_int -
                                           (*camera).inputDir.y as
                                               libc::c_int) as s16 as
                                          libc::c_int) as s16,
                                 (*camera).inputDir.y,
                                 1.0f32 - 0.99f32 * spA4,
                                 0xa as libc::c_int as s16)
        }
    } else {
        (*anim).swing.swingUpdateRate = (*jump1).yawUpateRateTarget;
        (*anim).swing.unk_18 = 0 as libc::c_int as s16;
        sUpdateCameraDirection = 0 as libc::c_int;
        *eye = *eyeNext
    }
    (*camera).dist = OLib_Vec3fDist(at, eye);
    (*camera).roll =
        Camera_LERPCeilS(0 as libc::c_int as s16, (*camera).roll, 0.5f32,
                         0xa as libc::c_int as s16);
    (*camera).atLERPStepScale =
        Camera_ClampLERPScale(camera, (*jump1).atLERPScaleMax);
    return 1 as libc::c_int;
}
// Climbing ladders/vines
#[no_mangle]
pub unsafe extern "C" fn Camera_Jump2(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut bgChkPos: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut floorNorm: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut adjAtToEyeDir: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut bgChkPara: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut atToEyeNextDir: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut atToEyeDir: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut temp_f14: f32_0 = 0.;
    let mut temp_f16: f32_0 = 0.;
    let mut sp90: f32_0 = 0.;
    let mut sp8C: f32_0 = 0.;
    let mut bgId: s32 = 0;
    let mut camBgChk: CamColChk =
        CamColChk{pos: Vec3f{x: 0., y: 0., z: 0.,},
                  norm: Vec3f{x: 0., y: 0., z: 0.,},
                  poly: 0 as *mut CollisionPoly,
                  sphNorm: VecSph{r: 0., pitch: 0, yaw: 0,},
                  bgId: 0,};
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut yawDiff: s16 = 0;
    let mut playerYawRot180: s16 = 0;
    let mut jump2: *mut Jump2 =
        (*camera).paramData.as_mut_ptr() as *mut Jump2;
    let mut anim: *mut Jump2Anim = &mut (*jump2).anim;
    let mut values: *mut CameraModeValue = 0 as *mut CameraModeValue;
    let mut playerHeight: f32_0 = 0.;
    let mut yNormal: f32_0 = 0.;
    playerHeight = Player_GetHeight((*camera).player);
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        values =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        yNormal =
            1.0f32 +
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 -
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 * (68.0f32 / playerHeight);
        let fresh48 = values;
        values = values.offset(1);
        (*jump2).atYOffset =
            ((if (*camera).playerPosDelta.y > 0.0f32 {
                  -10.0f32
              } else { 10.0f32 }) +
                 (*fresh48).val as libc::c_int as libc::c_float) * 0.01f32 *
                playerHeight * yNormal;
        let fresh49 = values;
        values = values.offset(1);
        (*jump2).minDist =
            (*fresh49).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh50 = values;
        values = values.offset(1);
        (*jump2).maxDist =
            (*fresh50).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh51 = values;
        values = values.offset(1);
        (*jump2).minMaxDistFactor =
            (*fresh51).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh52 = values;
        values = values.offset(1);
        (*jump2).yawUpdRateTarget = (*fresh52).val as f32_0;
        let fresh53 = values;
        values = values.offset(1);
        (*jump2).xzUpdRateTarget =
            (*fresh53).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh54 = values;
        values = values.offset(1);
        (*jump2).fovTarget = (*fresh54).val as f32_0;
        let fresh55 = values;
        values = values.offset(1);
        (*jump2).atLERPStepScale =
            (*fresh55).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh56 = values;
        values = values.offset(1);
        (*jump2).interfaceFlags = (*fresh56).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    OLib_Vec3fDiffToVecSphGeo(&mut atToEyeDir, at, eye);
    OLib_Vec3fDiffToVecSphGeo(&mut atToEyeNextDir, at, eyeNext);
    sCameraInterfaceFlags = (*jump2).interfaceFlags as s32;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int {
        bgChkPos = (*playerPosRot).pos;
        (*anim).floorY = Camera_GetFloorY(camera, &mut bgChkPos);
        (*anim).yawTarget = atToEyeNextDir.yaw;
        (*anim).initYawDiff = 0 as libc::c_int as s16;
        if (*anim).floorY == -32000.0f32 {
            osSyncPrintf(b"\x1b[43;30mcamera: climb: no floor \n\x1b[m\x00" as
                             *const u8 as *const libc::c_char);
            (*anim).onFloor = -(1 as libc::c_int) as s16;
            (*anim).floorY = (*playerPosRot).pos.y - 1000.0f32
        } else if (*playerPosRot).pos.y - (*anim).floorY < playerHeight {
            // player's model is within the height of the floor.
            (*anim).onFloor = 1 as libc::c_int as s16
        } else { (*anim).onFloor = -(1 as libc::c_int) as s16 }
        yawDiff =
            (((*playerPosRot).rot.y as libc::c_int - 0x7fff as libc::c_int) as
                 s16 as libc::c_int - atToEyeNextDir.yaw as libc::c_int) as
                s16;
        (*anim).initYawDiff =
            (yawDiff as libc::c_int /
                 (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                        16 as libc::c_int + 23 as libc::c_int)
                                       as usize] as libc::c_int /
                 4 as libc::c_int * 3 as libc::c_int) as s16;
        if (*jump2).interfaceFlags as libc::c_int & 2 as libc::c_int != 0 {
            (*anim).yawAdj = 0xa as libc::c_int as s16
        } else { (*anim).yawAdj = 0x2710 as libc::c_int as s16 }
        (*playerPosRot).pos.x -= (*camera).playerPosDelta.x;
        (*playerPosRot).pos.y -= (*camera).playerPosDelta.y;
        (*playerPosRot).pos.z -= (*camera).playerPosDelta.z;
        (*anim).animTimer =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 23 as libc::c_int) as
                                  usize];
        (*camera).animState += 1;
        (*camera).atLERPStepScale = (*jump2).atLERPStepScale
    }
    sp90 =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 25 as libc::c_int) as
                              usize] as libc::c_int as libc::c_float * 0.01f32
            * (*camera).speedRatio;
    sp8C =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 26 as libc::c_int) as
                              usize] as libc::c_int as libc::c_float * 0.01f32
            * (*camera).speedRatio;
    (*camera).yawUpdateRateInv =
        Camera_LERPCeilF((*jump2).yawUpdRateTarget,
                         (*camera).yawUpdateRateInv, sp90, 0.1f32);
    (*camera).xzOffsetUpdateRate =
        Camera_LERPCeilF((*jump2).xzUpdRateTarget,
                         (*camera).xzOffsetUpdateRate, sp90, 0.1f32);
    (*camera).yOffsetUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                3 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).yOffsetUpdateRate, sp8C, 0.1f32);
    (*camera).fovUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                4 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).yOffsetUpdateRate,
                         (*camera).speedRatio * 0.05f32, 0.1f32);
    (*camera).rUpdateRateInv =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 27 as libc::c_int) as
                              usize] as f32_0;
    Camera_CalcAtDefault(camera, &mut atToEyeNextDir, (*jump2).atYOffset,
                         0 as libc::c_int as s16);
    OLib_Vec3fDiffToVecSphGeo(&mut adjAtToEyeDir, at, eye);
    temp_f16 = (*jump2).minDist;
    sp90 = (*jump2).maxDist + (*jump2).maxDist * (*jump2).minMaxDistFactor;
    temp_f14 = temp_f16 - (*jump2).minDist * (*jump2).minMaxDistFactor;
    if adjAtToEyeDir.r > sp90 {
        adjAtToEyeDir.r = sp90
    } else if adjAtToEyeDir.r < temp_f14 { adjAtToEyeDir.r = temp_f14 }
    yawDiff =
        (((*playerPosRot).rot.y as libc::c_int - 0x7fff as libc::c_int) as s16
             as libc::c_int - adjAtToEyeDir.yaw as libc::c_int) as s16;
    if (*anim).animTimer as libc::c_int != 0 as libc::c_int {
        (*anim).yawTarget =
            ((*playerPosRot).rot.y as libc::c_int - 0x7fff as libc::c_int) as
                s16;
        (*anim).animTimer -= 1;
        adjAtToEyeDir.yaw =
            Camera_LERPCeilS((*anim).yawTarget, atToEyeNextDir.yaw, 0.5f32,
                             0xa as libc::c_int as s16)
    } else if ((*anim).yawAdj as libc::c_int) <
                  (if yawDiff as libc::c_int >= 0 as libc::c_int {
                       yawDiff as libc::c_int
                   } else { -(yawDiff as libc::c_int) }) {
        playerYawRot180 =
            ((*playerPosRot).rot.y as libc::c_int - 0x7fff as libc::c_int) as
                s16;
        adjAtToEyeDir.yaw =
            Camera_LERPFloorS(if (yawDiff as libc::c_int) < 0 as libc::c_int {
                                  (playerYawRot180 as libc::c_int +
                                       (*anim).yawAdj as libc::c_int) as s16
                                      as libc::c_int
                              } else {
                                  (playerYawRot180 as libc::c_int -
                                       (*anim).yawAdj as libc::c_int) as s16
                                      as libc::c_int
                              } as s16, atToEyeNextDir.yaw, 0.1f32,
                              0xa as libc::c_int as s16)
    } else {
        adjAtToEyeDir.yaw =
            Camera_LERPCeilS(adjAtToEyeDir.yaw, atToEyeNextDir.yaw, 0.25f32,
                             0xa as libc::c_int as s16)
    }
    // Check the floor at the top of the climb
    bgChkPos.x =
        (*playerPosRot).pos.x + Math_SinS((*playerPosRot).rot.y) * 25.0f32;
    bgChkPos.y = (*playerPosRot).pos.y + playerHeight * 2.2f32;
    bgChkPos.z =
        (*playerPosRot).pos.z + Math_CosS((*playerPosRot).rot.y) * 25.0f32;
    sp90 =
        Camera_GetFloorYNorm(camera, &mut floorNorm, &mut bgChkPos,
                             &mut bgId);
    if sp90 != -32000.0f32 && (*playerPosRot).pos.y < sp90 {
        // top of the climb is within 2.2x of the player's height.
        (*camera).pitchUpdateRateInv =
            Camera_LERPCeilF(20.0f32, (*camera).pitchUpdateRateInv,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    26 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32, 0.1f32);
        (*camera).rUpdateRateInv =
            Camera_LERPCeilF(20.0f32, (*camera).rUpdateRateInv,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    26 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32, 0.1f32);
        adjAtToEyeDir.pitch =
            Camera_LERPCeilS(0x1f4 as libc::c_int as s16,
                             atToEyeNextDir.pitch,
                             1.0f32 / (*camera).pitchUpdateRateInv,
                             0xa as libc::c_int as s16)
    } else if (*playerPosRot).pos.y - (*anim).floorY < playerHeight {
        // player is within his height of the ground.
        (*camera).pitchUpdateRateInv =
            Camera_LERPCeilF(20.0f32, (*camera).pitchUpdateRateInv,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    26 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32, 0.1f32);
        (*camera).rUpdateRateInv =
            Camera_LERPCeilF(20.0f32, (*camera).rUpdateRateInv,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    26 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32, 0.1f32);
        adjAtToEyeDir.pitch =
            Camera_LERPCeilS(0x1f4 as libc::c_int as s16,
                             atToEyeNextDir.pitch,
                             1.0f32 / (*camera).pitchUpdateRateInv,
                             0xa as libc::c_int as s16)
    } else {
        (*camera).pitchUpdateRateInv = 100.0f32;
        (*camera).rUpdateRateInv = 100.0f32
    }
    // max pitch to +/- ~ 60 degrees
    if adjAtToEyeDir.pitch as libc::c_int > 0x2af8 as libc::c_int {
        adjAtToEyeDir.pitch = 0x2af8 as libc::c_int as s16
    }
    if (adjAtToEyeDir.pitch as libc::c_int) < -(0x2af8 as libc::c_int) {
        adjAtToEyeDir.pitch = -(0x2af8 as libc::c_int) as s16
    }
    Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut adjAtToEyeDir);
    camBgChk.pos = *eyeNext;
    if Camera_BGCheckInfo(camera, at, &mut camBgChk) != 0 {
        // Collision detected between at->eyeNext, Check if collision between
        // at->eyeNext, but parallel to at (pitch = 0).
        bgChkPos = camBgChk.pos;
        bgChkPara.r = adjAtToEyeDir.r;
        bgChkPara.pitch = 0 as libc::c_int as s16;
        bgChkPara.yaw = adjAtToEyeDir.yaw;
        Camera_Vec3fVecSphGeoAdd(&mut camBgChk.pos, at, &mut bgChkPara);
        if Camera_BGCheckInfo(camera, at, &mut camBgChk) != 0 {
            // Collision found between parallel at->eyeNext, set eye position to
            // first collsion point.
            *eye = bgChkPos
        } else {
            // no collision found with the parallel at->eye, animate to be parallel
            adjAtToEyeDir.pitch =
                Camera_LERPCeilS(0 as libc::c_int as s16, adjAtToEyeDir.pitch,
                                 0.2f32, 0xa as libc::c_int as s16);
            Camera_Vec3fVecSphGeoAdd(eye, at, &mut adjAtToEyeDir);
            // useless?
            Camera_BGCheck(camera, at, eye);
        }
    } else {
        // no collision detected.
        *eye = *eyeNext
    }
    (*camera).dist = adjAtToEyeDir.r;
    (*camera).fov =
        Camera_LERPCeilF((*jump2).fovTarget, (*camera).fov,
                         (*camera).fovUpdateRate, 1.0f32);
    (*camera).roll =
        Camera_LERPCeilS(0 as libc::c_int as s16, (*camera).roll, 0.5f32,
                         0xa as libc::c_int as s16);
    return 1 as libc::c_int;
}
// swimming
#[no_mangle]
pub unsafe extern "C" fn Camera_Jump3(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye; // unused
    let mut at: *mut Vec3f = &mut (*camera).at; // unused
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut prevMode: s32 = 0;
    let mut spC4: f32_0 = 0.;
    let mut spC0: f32_0 = 0.;
    let mut spBC: f32_0 = 0.;
    let mut spB0: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut eyeDiffSph: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut jump3: *mut Jump3 =
        (*camera).paramData.as_mut_ptr() as *mut Jump3;
    let mut eyeAtOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut eyeNextAtOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut pad: s32 = 0;
    let mut pad2: s32 = 0;
    let mut values: *mut CameraModeValue = 0 as *mut CameraModeValue;
    let mut t2: f32_0 = 0.;
    let mut phi_f0: f32_0 = 0.;
    let mut phi_f2: f32_0 = 0.;
    let mut playerHeight: f32_0 = 0.;
    let mut playerhead: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut yNormal: f32_0 = 0.;
    let mut temp_f18: f32_0 = 0.;
    let mut modeSwitch: s32 = 0;
    let mut temp_f2_2: f32_0 = 0.;
    let mut anim: *mut Jump3Anim = &mut (*jump3).anim;
    playerHeight = Player_GetHeight((*camera).player);
    Actor_GetFocus(&mut playerhead, &mut (*(*camera).player).actor);
    modeSwitch = 0 as libc::c_int;
    if (*camera).waterYPos - (*eye).y <
           (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 44 as libc::c_int) as
                                 usize] as libc::c_int as libc::c_float ||
           (*camera).animState as libc::c_int == 0 as libc::c_int {
        if (*anim).mode as libc::c_int != CAM_MODE_NORMAL as libc::c_int {
            (*anim).mode = CAM_MODE_NORMAL as libc::c_int as s16;
            modeSwitch = 1 as libc::c_int
        }
    } else if (*camera).waterYPos - (*eye).y >
                  (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                         16 as libc::c_int +
                                         45 as libc::c_int) as usize] as
                      libc::c_int as libc::c_float &&
                  (*anim).mode as libc::c_int !=
                      CAM_MODE_BOOMERANG as libc::c_int {
        (*anim).mode = CAM_MODE_BOOMERANG as libc::c_int as s16;
        modeSwitch = 1 as libc::c_int
    }
    OLib_Vec3fDiffToVecSphGeo(&mut eyeAtOffset, at, eye);
    OLib_Vec3fDiffToVecSphGeo(&mut eyeNextAtOffset, at, eyeNext);
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           modeSwitch != 0 ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        values =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*anim).mode as
                                                                isize)).values;
        yNormal =
            1.0f32 +
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 -
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 * (68.0f32 / playerHeight);
        t2 = playerHeight * 0.01f32 * yNormal;
        let fresh57 = values;
        values = values.offset(1);
        (*jump3).yOffset =
            (*fresh57).val as libc::c_int as libc::c_float * t2;
        let fresh58 = values;
        values = values.offset(1);
        (*jump3).distMin =
            (*fresh58).val as libc::c_int as libc::c_float * t2;
        let fresh59 = values;
        values = values.offset(1);
        (*jump3).distMax =
            (*fresh59).val as libc::c_int as libc::c_float * t2;
        let fresh60 = values;
        values = values.offset(1);
        (*jump3).pitchTarget =
            ((*fresh60).val as libc::c_int as libc::c_float * 182.04167f32 +
                 0.5f32) as s16;
        let fresh61 = values;
        values = values.offset(1);
        (*jump3).swingUpdateRate = (*fresh61).val as f32_0;
        let fresh62 = values;
        values = values.offset(1);
        (*jump3).unk_10 = (*fresh62).val as f32_0;
        let fresh63 = values;
        values = values.offset(1);
        (*jump3).unk_14 =
            (*fresh63).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh64 = values;
        values = values.offset(1);
        (*jump3).fovTarget = (*fresh64).val as f32_0;
        let fresh65 = values;
        values = values.offset(1);
        (*jump3).unk_1C =
            (*fresh65).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh66 = values;
        values = values.offset(1);
        (*jump3).interfaceFlags = (*fresh66).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        prevMode = (*camera).mode as s32;
        (*camera).mode = (*anim).mode;
        Camera_CopyPREGToModeValues(camera);
        (*camera).mode = prevMode as s16
    }
    sCameraInterfaceFlags = (*jump3).interfaceFlags as s32;
    match (*camera).animState as libc::c_int {
        0 | 10 | 20 | 25 => {
            (*anim).swing.atEyePoly = 0 as *mut CollisionPoly;
            (*anim).unk_1C = (*camera).playerGroundY;
            (*anim).swing.unk_18 = 0 as libc::c_int as s16;
            (*anim).swing.unk_14 = (*anim).swing.unk_18;
            (*anim).swing.unk_16 = (*anim).swing.unk_14;
            (*anim).animTimer = 0xa as libc::c_int as s16;
            (*anim).swing.swingUpdateRate = (*jump3).swingUpdateRate;
            (*camera).animState += 1;
            (*anim).swing.swingUpdateRateTimer = 0 as libc::c_int as s16
        }
        _ => {
            if (*anim).animTimer as libc::c_int != 0 as libc::c_int {
                (*anim).animTimer -= 1
            }
        }
    }
    spB0 = *eye;
    // suppresses set but unused warning
    spC4 =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 25 as libc::c_int) as
                              usize] as libc::c_int as libc::c_float * 0.01f32
            * (*camera).speedRatio;
    spC0 =
        (*camera).speedRatio *
            ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                    16 as libc::c_int + 26 as libc::c_int) as
                                   usize] as libc::c_int as libc::c_float *
                 0.01f32);
    spBC =
        if (*anim).swing.unk_18 as libc::c_int != 0 as libc::c_int {
            ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                    16 as libc::c_int + 25 as libc::c_int) as
                                   usize] as libc::c_int as libc::c_float) *
                0.01f32
        } else { spC4 };
    if (*anim).swing.swingUpdateRateTimer as libc::c_int != 0 as libc::c_int {
        (*camera).yawUpdateRateInv =
            Camera_LERPCeilF((*anim).swing.swingUpdateRate +
                                 ((*anim).swing.swingUpdateRateTimer as
                                      libc::c_int * 2 as libc::c_int) as
                                     libc::c_float,
                             (*camera).yawUpdateRateInv, spC4, 0.1f32);
        (*camera).pitchUpdateRateInv =
            Camera_LERPCeilF(((*anim).swing.swingUpdateRateTimer as
                                  libc::c_int * 2 as libc::c_int) as
                                 libc::c_float + 40.0f32,
                             (*camera).pitchUpdateRateInv, spC0, 0.1f32);
        (*anim).swing.swingUpdateRateTimer -= 1
    } else {
        (*camera).yawUpdateRateInv =
            Camera_LERPCeilF((*anim).swing.swingUpdateRate,
                             (*camera).yawUpdateRateInv, spBC, 0.1f32);
        (*camera).pitchUpdateRateInv =
            Camera_LERPCeilF(40.0f32, (*camera).pitchUpdateRateInv, spC0,
                             0.1f32)
    }
    (*camera).xzOffsetUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                2 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).xzOffsetUpdateRate, spC4, 0.1f32);
    (*camera).yOffsetUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                3 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).yOffsetUpdateRate, spC0, 0.1f32);
    (*camera).fovUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                4 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).yOffsetUpdateRate,
                         (*camera).speedRatio * 0.05f32, 0.1f32);
    Camera_CalcAtDefault(camera, &mut eyeNextAtOffset, (*jump3).yOffset,
                         (*jump3).interfaceFlags);
    OLib_Vec3fDiffToVecSphGeo(&mut eyeDiffSph, at, eyeNext);
    eyeDiffSph.r =
        Camera_ClampDist(camera, eyeDiffSph.r, (*jump3).distMin,
                         (*jump3).distMax, (*anim).animTimer);
    (*camera).dist = eyeDiffSph.r;
    if (*camera).playerGroundY <= (*playerPosRot).pos.y {
        phi_f0 = (*playerPosRot).pos.y - (*camera).playerGroundY
    } else { phi_f0 = -((*playerPosRot).pos.y - (*camera).playerGroundY) }
    if !(phi_f0 < 10.0f32) {
        if (*camera).waterYPos <= playerhead.pos.y {
            phi_f2 = playerhead.pos.y - (*camera).waterYPos
        } else { phi_f2 = -(playerhead.pos.y - (*camera).waterYPos) }
        if !(phi_f2 < 50.0f32) { (*camera).pitchUpdateRateInv = 100.0f32 }
    }
    if (*anim).swing.unk_18 as libc::c_int != 0 as libc::c_int {
        eyeDiffSph.yaw =
            Camera_LERPCeilS((*anim).swing.unk_16, eyeNextAtOffset.yaw,
                             1.0f32 / (*camera).yawUpdateRateInv,
                             0xa as libc::c_int as s16);
        eyeDiffSph.pitch =
            Camera_LERPCeilS((*anim).swing.unk_14, eyeNextAtOffset.pitch,
                             1.0f32 / (*camera).yawUpdateRateInv,
                             0xa as libc::c_int as s16)
    } else {
        eyeDiffSph.yaw =
            Camera_CalcDefaultYaw(camera, eyeNextAtOffset.yaw,
                                  (*playerPosRot).rot.y, (*jump3).unk_14,
                                  0.0f32);
        eyeDiffSph.pitch =
            Camera_CalcDefaultPitch(camera, eyeNextAtOffset.pitch,
                                    (*jump3).pitchTarget,
                                    0 as libc::c_int as s16)
    }
    if eyeDiffSph.pitch as libc::c_int >
           (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 5 as libc::c_int) as
                                 usize] as libc::c_int {
        eyeDiffSph.pitch =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 5 as libc::c_int) as
                                  usize]
    }
    if (eyeDiffSph.pitch as libc::c_int) <
           (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 34 as libc::c_int) as
                                 usize] as libc::c_int {
        eyeDiffSph.pitch =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 34 as libc::c_int) as
                                  usize]
    }
    Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut eyeDiffSph);
    if (*camera).status as libc::c_int == 7 as libc::c_int &&
           (*jump3).interfaceFlags as libc::c_int & 0x10 as libc::c_int == 0 {
        func_80046E20(camera, &mut eyeDiffSph, (*jump3).distMin,
                      (*jump3).swingUpdateRate, &mut spBC,
                      &mut (*anim).swing);
        if (*jump3).interfaceFlags as libc::c_int & 4 as libc::c_int != 0 {
            (*camera).inputDir.x = -(eyeAtOffset.pitch as libc::c_int) as s16;
            (*camera).inputDir.y =
                (eyeAtOffset.yaw as libc::c_int - 0x7fff as libc::c_int) as
                    s16;
            (*camera).inputDir.z = 0 as libc::c_int as s16
        } else {
            OLib_Vec3fDiffToVecSphGeo(&mut eyeDiffSph, eye, at);
            (*camera).inputDir.x = eyeDiffSph.pitch;
            (*camera).inputDir.y = eyeDiffSph.yaw;
            (*camera).inputDir.z = 0 as libc::c_int as s16
        }
        if (*anim).swing.unk_18 as libc::c_int != 0 as libc::c_int {
            (*camera).inputDir.y =
                Camera_LERPCeilS(((*camera).inputDir.y as libc::c_int +
                                      (((*anim).swing.unk_16 as libc::c_int -
                                            0x7fff as libc::c_int) as s16 as
                                           libc::c_int -
                                           (*camera).inputDir.y as
                                               libc::c_int) as s16 as
                                          libc::c_int) as s16,
                                 (*camera).inputDir.y,
                                 1.0f32 - 0.99f32 * spBC,
                                 0xa as libc::c_int as s16)
        }
    } else {
        (*anim).swing.swingUpdateRate = (*jump3).swingUpdateRate;
        (*anim).swing.unk_18 = 0 as libc::c_int as s16;
        sUpdateCameraDirection = 0 as libc::c_int;
        *eye = *eyeNext
    }
    (*camera).fov =
        Camera_LERPCeilF((*jump3).fovTarget, (*camera).fov,
                         (*camera).fovUpdateRate, 1.0f32);
    (*camera).roll =
        Camera_LERPCeilS(0 as libc::c_int as s16, (*camera).roll, 0.5f32,
                         0xa as libc::c_int as s16);
    (*camera).atLERPStepScale =
        Camera_ClampLERPScale(camera, (*jump3).unk_1C);
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Jump4(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Jump0(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Battle1(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut sp128: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut playerHead: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut targetPos: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut var3: f32_0 = 0.;
    let mut var2: f32_0 = 0.;
    let mut temp_f0_2: f32_0 = 0.;
    let mut temp_f12_2: f32_0 = 0.;
    let mut spFC: f32_0 = 0.;
    let mut spF8: f32_0 = 0.;
    let mut swingAngle: f32_0 = 0.;
    let mut temp_f2_2: f32_0 = 0.;
    let mut temp_f14: f32_0 = 0.;
    let mut skipEyeAtCalc: s32 = 0;
    let mut distRatio: f32_0 = 0.;
    let mut spBC: CamColChk =
        CamColChk{pos: Vec3f{x: 0., y: 0., z: 0.,},
                  norm: Vec3f{x: 0., y: 0., z: 0.,},
                  poly: 0 as *mut CollisionPoly,
                  sphNorm: VecSph{r: 0., pitch: 0, yaw: 0,},
                  bgId: 0,};
    let mut spB4: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut atToTargetDir: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut playerToTargetDir: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut atToEyeDir: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut atToEyeNextDir: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut tmpAng1: s16 = 0;
    let mut tmpAng2: s16 = 0;
    let mut player: *mut Player = 0 as *mut Player;
    let mut sp86: s16 = 0;
    let mut isOffGround: s16 = 0;
    let mut distance: f32_0 = 0.;
    let mut sp7C: f32_0 = 0.;
    let mut sp78: f32_0 = 0.;
    let mut fov: f32_0 = 0.;
    let mut batt1: *mut Battle1 =
        (*camera).paramData.as_mut_ptr() as *mut Battle1;
    let mut anim: *mut Battle1Anim = &mut (*batt1).anim;
    let mut pad: s32 = 0;
    let mut playerHeight: f32_0 = 0.;
    skipEyeAtCalc = 0 as libc::c_int;
    player = (*camera).player;
    playerHeight = Player_GetHeight((*camera).player);
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let mut yNormal: f32_0 =
            1.0f32 +
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 -
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 * (68.0f32 / playerHeight);
        let fresh67 = values;
        values = values.offset(1);
        (*batt1).yOffset =
            (*fresh67).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh68 = values;
        values = values.offset(1);
        (*batt1).distance = (*fresh68).val as f32_0;
        let fresh69 = values;
        values = values.offset(1);
        (*batt1).swingYawInitial = (*fresh69).val as f32_0;
        let fresh70 = values;
        values = values.offset(1);
        (*batt1).swingYawFinal = (*fresh70).val as f32_0;
        let fresh71 = values;
        values = values.offset(1);
        (*batt1).swingPitchInitial = (*fresh71).val as f32_0;
        let fresh72 = values;
        values = values.offset(1);
        (*batt1).swingPitchFinal = (*fresh72).val as f32_0;
        let fresh73 = values;
        values = values.offset(1);
        (*batt1).swingPitchAdj =
            (*fresh73).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh74 = values;
        values = values.offset(1);
        (*batt1).fov = (*fresh74).val as f32_0;
        let fresh75 = values;
        values = values.offset(1);
        (*batt1).atLERPScaleOnGround =
            (*fresh75).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh76 = values;
        values = values.offset(1);
        (*batt1).flags = (*fresh76).val;
        let fresh77 = values;
        values = values.offset(1);
        (*batt1).yOffsetOffGround =
            (*fresh77).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh78 = values;
        values = values.offset(1);
        (*batt1).atLERPScaleOffGround =
            (*fresh78).val as libc::c_int as libc::c_float * 0.01f32;
        (*anim).chargeTimer = 40 as libc::c_int as s16;
        (*anim).unk_10 =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 12 as libc::c_int) as
                                  usize] as libc::c_int as libc::c_float *
                0.01f32
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    distance = (*batt1).distance;
    sp7C = (*batt1).swingPitchInitial;
    sp78 = (*batt1).swingPitchFinal;
    fov = (*batt1).fov;
    if (*(*camera).player).stateFlags1 & 0x1000 as libc::c_int as libc::c_uint
           != 0 {
        // charging sword.
        (*anim).unk_10 =
            Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    12 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32 * 0.5f32,
                             (*anim).unk_10,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    25 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32, 0.1f32);
        (*camera).xzOffsetUpdateRate =
            Camera_LERPCeilF(0.2f32, (*camera).xzOffsetUpdateRate,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    25 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32, 0.1f32);
        (*camera).yOffsetUpdateRate =
            Camera_LERPCeilF(0.2f32, (*camera).yOffsetUpdateRate,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    25 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32, 0.1f32);
        if (*anim).chargeTimer as libc::c_int >= -(19 as libc::c_int) {
            (*anim).chargeTimer -= 1
        } else {
            distance = 250.0f32;
            sp7C = 50.0f32;
            sp78 = 40.0f32;
            fov = 60.0f32
        }
    } else if ((*anim).chargeTimer as libc::c_int) < 0 as libc::c_int {
        distance = 250.0f32;
        sp7C = 50.0f32;
        sp78 = 40.0f32;
        fov = 60.0f32;
        (*anim).chargeTimer += 1
    } else {
        (*anim).chargeTimer = 40 as libc::c_int as s16;
        (*anim).unk_10 =
            Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    12 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32, (*anim).unk_10,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    25 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32, 0.1f32);
        (*camera).xzOffsetUpdateRate =
            Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    40 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32,
                             (*camera).xzOffsetUpdateRate,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    25 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32 *
                                 (*camera).speedRatio, 0.1f32);
        (*camera).yOffsetUpdateRate =
            Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    40 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32,
                             (*camera).yOffsetUpdateRate,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    26 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32 *
                                 (*camera).speedRatio, 0.1f32)
    }
    (*camera).fovUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                4 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).fovUpdateRate,
                         (*camera).speedRatio * 0.05f32, 0.1f32);
    playerHeight += (*batt1).yOffset;
    OLib_Vec3fDiffToVecSphGeo(&mut atToEyeDir, at, eye);
    OLib_Vec3fDiffToVecSphGeo(&mut atToEyeNextDir, at, eyeNext);
    if (*camera).target.is_null() || (*(*camera).target).update.is_none() {
        if (*camera).target.is_null() {
            osSyncPrintf(b"\x1b[43;30mcamera: warning: battle: target is not valid, change parallel\n\x1b[m\x00"
                             as *const u8 as *const libc::c_char);
        }
        (*camera).target = 0 as *mut Actor;
        Camera_ChangeMode(camera, CAM_MODE_TARGET as libc::c_int as s16);
        return 1 as libc::c_int
    }
    sCameraInterfaceFlags = (*batt1).flags as s32;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int {
        (*anim).unk_14 = 0 as libc::c_int as s16;
        (*anim).roll = 0.0f32;
        (*anim).target = (*camera).target;
        (*camera).animState += 1;
        if (*(*anim).target).id as libc::c_int > 0 as libc::c_int {
            osSyncPrintf(b"camera: battle: target actor name \x1b[34m%d\x1b[m\n\x00"
                             as *const u8 as *const libc::c_char,
                         (*(*anim).target).id as libc::c_int);
        } else {
            osSyncPrintf(b"camera: battle: target actor name \x1b[41;37m%d\x1b[m\n\x00"
                             as *const u8 as *const libc::c_char,
                         (*(*anim).target).id as libc::c_int);
            (*camera).target = 0 as *mut Actor;
            Camera_ChangeMode(camera, CAM_MODE_TARGET as libc::c_int as s16);
            return 1 as libc::c_int
        }
        (*anim).animTimer =
            ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                    16 as libc::c_int + 23 as libc::c_int) as
                                   usize] as libc::c_int +
                 (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                        16 as libc::c_int + 24 as libc::c_int)
                                       as usize] as libc::c_int) as s16;
        (*anim).initialEyeToAtYaw = atToEyeDir.yaw;
        (*anim).initialEyeToAtPitch = atToEyeDir.pitch;
        (*anim).initialEyeToAtDist = atToEyeDir.r;
        (*anim).yPosOffset =
            (*playerPosRot).pos.y - (*camera).playerPosDelta.y
    }
    if (*camera).status as libc::c_int == 7 as libc::c_int {
        sUpdateCameraDirection = 1 as libc::c_int;
        (*camera).inputDir.x = -(atToEyeDir.pitch as libc::c_int) as s16;
        (*camera).inputDir.y =
            (atToEyeDir.yaw as libc::c_int - 0x7fff as libc::c_int) as s16;
        (*camera).inputDir.z = 0 as libc::c_int as s16
    }
    if (*camera).playerGroundY == (*camera).playerPosRot.pos.y ||
           (*(*camera).player).actor.gravity > -0.1f32 ||
           (*(*camera).player).stateFlags1 &
               0x200000 as libc::c_int as libc::c_uint != 0 {
        isOffGround = 0 as libc::c_int as s16;
        (*anim).yPosOffset = (*playerPosRot).pos.y
    } else { isOffGround = 1 as libc::c_int as s16 }
    if (*anim).animTimer as libc::c_int == 0 as libc::c_int {
        (*camera).atLERPStepScale =
            Camera_ClampLERPScale(camera,
                                  if isOffGround as libc::c_int != 0 {
                                      (*batt1).atLERPScaleOffGround
                                  } else { (*batt1).atLERPScaleOnGround })
    }
    Actor_GetFocus(&mut (*camera).targetPosRot, (*camera).target);
    if (*anim).target != (*camera).target {
        osSyncPrintf(b"camera: battle: change target %d -> \x1b[34m%d\x1b[m\n\x00"
                         as *const u8 as *const libc::c_char,
                     (*(*anim).target).id as libc::c_int,
                     (*(*camera).target).id as libc::c_int);
        (*camera).animState = 0 as libc::c_int as s16;
        return 1 as libc::c_int
    }
    Camera_CalcAtForLockOn(camera, &mut atToEyeNextDir,
                           &mut (*camera).targetPosRot.pos,
                           if isOffGround as libc::c_int != 0 {
                               (*batt1).yOffsetOffGround
                           } else { (*batt1).yOffset }, distance,
                           &mut (*anim).yPosOffset, &mut playerToTargetDir,
                           ((if isOffGround as libc::c_int != 0 {
                                 0x81 as libc::c_int
                             } else { 1 as libc::c_int }) |
                                (*batt1).flags as libc::c_int) as s16);
    tmpAng2 = playerToTargetDir.yaw;
    playerHead = (*playerPosRot).pos;
    playerHead.y += playerHeight;
    OLib_Vec3fDiffToVecSphGeo(&mut playerToTargetDir, &mut playerHead,
                              &mut (*camera).targetPosRot.pos);
    distRatio =
        if playerToTargetDir.r > distance {
            1 as libc::c_int as libc::c_float
        } else { (playerToTargetDir.r) / distance };
    targetPos = (*camera).targetPosRot.pos;
    OLib_Vec3fDiffToVecSphGeo(&mut atToTargetDir, at, &mut targetPos);
    atToTargetDir.r =
        distance -
            (if atToTargetDir.r <= distance {
                 atToTargetDir.r
             } else { distance }) * 0.5f32;
    swingAngle =
        (*batt1).swingYawInitial +
            ((*batt1).swingYawFinal - (*batt1).swingYawInitial) *
                (1.1f32 - distRatio);
    spF8 =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 13 as libc::c_int) as
                              usize] as libc::c_int as libc::c_float +
            swingAngle;
    (*camera).dist =
        Camera_LERPCeilF(distance, (*camera).dist,
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                11 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32,
                         2.0f32);
    spB4.r = (*camera).dist;
    spB4.yaw = atToEyeNextDir.yaw;
    tmpAng1 =
        (atToTargetDir.yaw as libc::c_int -
             (atToEyeNextDir.yaw as libc::c_int - 0x7fff as libc::c_int) as
                 s16 as libc::c_int) as s16;
    if (*anim).animTimer as libc::c_int != 0 as libc::c_int {
        if (*anim).animTimer as libc::c_int >=
               (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                      16 as libc::c_int + 24 as libc::c_int)
                                     as usize] as libc::c_int {
            sp86 =
                ((*anim).animTimer as libc::c_int -
                     (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                            16 as libc::c_int +
                                            24 as libc::c_int) as usize] as
                         libc::c_int) as s16;
            OLib_Vec3fDiffToVecSphGeo(&mut playerToTargetDir, at, eye);
            playerToTargetDir.yaw =
                (tmpAng2 as libc::c_int - 0x7fff as libc::c_int) as s16;
            var2 =
                1.0f32 /
                    (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                           16 as libc::c_int +
                                           23 as libc::c_int) as usize] as
                        libc::c_int as libc::c_float;
            var3 = ((*anim).initialEyeToAtDist - playerToTargetDir.r) * var2;
            tmpAng1 =
                (((*anim).initialEyeToAtYaw as libc::c_int -
                      playerToTargetDir.yaw as libc::c_int) as s16 as
                     libc::c_int as libc::c_float * var2) as s16;
            tmpAng2 =
                (((*anim).initialEyeToAtPitch as libc::c_int -
                      playerToTargetDir.pitch as libc::c_int) as s16 as
                     libc::c_int as libc::c_float * var2) as s16;
            spB4.r =
                Camera_LERPCeilF(playerToTargetDir.r +
                                     var3 *
                                         sp86 as libc::c_int as libc::c_float,
                                 atToEyeDir.r,
                                 (*gGameInfo).data[(2 as libc::c_int *
                                                        6 as libc::c_int *
                                                        16 as libc::c_int +
                                                        28 as libc::c_int) as
                                                       usize] as libc::c_int
                                     as libc::c_float * 0.01f32, 1.0f32);
            spB4.yaw =
                Camera_LERPCeilS((playerToTargetDir.yaw as libc::c_int +
                                      tmpAng1 as libc::c_int *
                                          sp86 as libc::c_int) as s16,
                                 atToEyeDir.yaw,
                                 (*gGameInfo).data[(2 as libc::c_int *
                                                        6 as libc::c_int *
                                                        16 as libc::c_int +
                                                        28 as libc::c_int) as
                                                       usize] as libc::c_int
                                     as libc::c_float * 0.01f32,
                                 0xa as libc::c_int as s16);
            spB4.pitch =
                Camera_LERPCeilS((playerToTargetDir.pitch as libc::c_int +
                                      tmpAng2 as libc::c_int *
                                          sp86 as libc::c_int) as s16,
                                 atToEyeDir.pitch,
                                 (*gGameInfo).data[(2 as libc::c_int *
                                                        6 as libc::c_int *
                                                        16 as libc::c_int +
                                                        28 as libc::c_int) as
                                                       usize] as libc::c_int
                                     as libc::c_float * 0.01f32,
                                 0xa as libc::c_int as s16)
        } else { skipEyeAtCalc = 1 as libc::c_int }
        (*anim).animTimer -= 1
    } else if (if tmpAng1 as libc::c_int >= 0 as libc::c_int {
                   tmpAng1 as libc::c_int
               } else { -(tmpAng1 as libc::c_int) }) >
                  (swingAngle * 182.04167f32 + 0.5f32) as s16 as libc::c_int {
        spFC = tmpAng1 as f32_0 * (360.0001525f32 / 65535.0f32);
        temp_f2_2 =
            swingAngle +
                (spF8 - swingAngle) *
                    (OLib_ClampMaxDist(atToTargetDir.r, spB4.r) / spB4.r);
        temp_f12_2 =
            (temp_f2_2 * temp_f2_2 - 2.0f32) / (temp_f2_2 - 360.0f32);
        var2 = temp_f12_2 * spFC + (2.0f32 - 360.0f32 * temp_f12_2);
        temp_f14 = spFC * spFC / var2;
        tmpAng2 =
            if tmpAng1 as libc::c_int >= 0 as libc::c_int {
                (temp_f14 * 182.04167f32 + 0.5f32) as s16 as libc::c_int
            } else {
                -((temp_f14 * 182.04167f32 + 0.5f32) as s16 as libc::c_int)
            } as s16;
        spB4.yaw =
            (((atToEyeNextDir.yaw as libc::c_int - 0x7fff as libc::c_int) as
                  s16 as libc::c_int + tmpAng2 as libc::c_int) as s16 as
                 libc::c_int - 0x7fff as libc::c_int) as s16
    } else {
        spFC = 0.05f32;
        spFC =
            (1 as libc::c_int as libc::c_float - (*camera).speedRatio) * spFC;
        tmpAng2 =
            if tmpAng1 as libc::c_int >= 0 as libc::c_int {
                (swingAngle * 182.04167f32 + 0.5f32) as s16 as libc::c_int
            } else {
                -((swingAngle * 182.04167f32 + 0.5f32) as s16 as libc::c_int)
            } as s16;
        spB4.yaw =
            (atToEyeNextDir.yaw as libc::c_int -
                 ((tmpAng2 as libc::c_int - tmpAng1 as libc::c_int) as
                      libc::c_float * spFC) as s16 as libc::c_int) as s16
    }
    if skipEyeAtCalc == 0 {
        var3 =
            atToTargetDir.pitch as libc::c_int as libc::c_float *
                (*batt1).swingPitchAdj;
        var2 = sp7C + (sp78 - sp7C) * distRatio;
        tmpAng1 =
            ((var2 * 182.04167f32 + 0.5f32) as s16 as libc::c_int -
                 (playerToTargetDir.pitch as libc::c_int as libc::c_float *
                      (0.5f32 + distRatio * (1.0f32 - 0.5f32))) as s16 as
                     libc::c_int) as s16;
        tmpAng1 =
            (tmpAng1 as libc::c_int + var3 as s16 as libc::c_int) as s16;
        if (tmpAng1 as libc::c_int) < -(0x2aa8 as libc::c_int) {
            tmpAng1 = -(0x2aa8 as libc::c_int) as s16
        } else if tmpAng1 as libc::c_int > 0x2aa8 as libc::c_int {
            tmpAng1 = 0x2aa8 as libc::c_int as s16
        }
        spB4.pitch =
            Camera_LERPCeilS(tmpAng1, atToEyeNextDir.pitch, (*anim).unk_10,
                             0xa as libc::c_int as s16);
        Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut spB4);
        spBC.pos = *eyeNext;
        if (*camera).status as libc::c_int == 7 as libc::c_int {
            if (*(*camera).globalCtx).envCtx.skyboxDisabled == 0 ||
                   (*batt1).flags as libc::c_int & 1 as libc::c_int != 0 {
                Camera_BGCheckInfo(camera, at, &mut spBC);
            } else if (*batt1).flags as libc::c_int & 2 as libc::c_int != 0 {
                func_80043F94(camera, at, &mut spBC);
            } else {
                OLib_Vec3fDistNormalize(&mut sp128, at, &mut spBC.pos);
                spBC.pos.x -= sp128.x;
                spBC.pos.y -= sp128.y;
                spBC.pos.z -= sp128.z
            }
            *eye = spBC.pos
        } else { *eye = *eyeNext }
    }
    (*anim).roll +=
        ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                16 as libc::c_int + 36 as libc::c_int) as
                               usize] as libc::c_int as libc::c_float *
             (*camera).speedRatio * (1.0f32 - distRatio) - (*anim).roll) *
            ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                    16 as libc::c_int + 37 as libc::c_int) as
                                   usize] as libc::c_int as libc::c_float *
                 0.01f32);
    (*camera).roll = ((*anim).roll * 182.04167f32 + 0.5f32) as s16;
    (*camera).fov =
        Camera_LERPCeilF((if (*player).swordState as libc::c_int !=
                                 0 as libc::c_int {
                              0.8f32
                          } else {
                              (if gSaveContext.health as libc::c_int <=
                                      0x10 as libc::c_int {
                                   0.8f32
                               } else { 1.0f32 })
                          }) * (fov - fov * 0.05f32 * distRatio),
                         (*camera).fov, (*camera).fovUpdateRate, 1.0f32);
    panic!("Reached end of non-void function without returning");
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Battle2(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Battle3(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
/* *
 * Charging spin attack
 * Camera zooms out slowly for 50 frames, then tilts up to a specified
 * setting value.
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Battle4(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut eyeNextOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut eyeAtOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut eyeNextAtOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut batt4: *mut Battle4 =
        (*camera).paramData.as_mut_ptr() as *mut Battle4;
    let mut anim: *mut Battle4Anim = &mut (*batt4).anim;
    let mut pad: s32 = 0;
    let mut playerHeight: f32_0 = 0.;
    playerHeight = Player_GetHeight((*camera).player);
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let mut yNormal: f32_0 =
            1.0f32 +
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 -
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 * (68.0f32 / playerHeight);
        let fresh79 = values;
        values = values.offset(1);
        (*batt4).yOffset =
            (*fresh79).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh80 = values;
        values = values.offset(1);
        (*batt4).rTarget =
            (*fresh80).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh81 = values;
        values = values.offset(1);
        (*batt4).pitchTarget =
            ((*fresh81).val as libc::c_int as libc::c_float * 182.04167f32 +
                 0.5f32) as s16;
        let fresh82 = values;
        values = values.offset(1);
        (*batt4).lerpUpdateRate =
            (*fresh82).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh83 = values;
        values = values.offset(1);
        (*batt4).fovTarget = (*fresh83).val as f32_0;
        let fresh84 = values;
        values = values.offset(1);
        (*batt4).atLERPTarget =
            (*fresh84).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh85 = values;
        values = values.offset(1);
        (*batt4).interfaceFlags = (*fresh85).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    OLib_Vec3fDiffToVecSphGeo(&mut eyeAtOffset, at, eye);
    OLib_Vec3fDiffToVecSphGeo(&mut eyeNextAtOffset, at, eyeNext);
    sCameraInterfaceFlags = (*batt4).interfaceFlags as s32;
    match (*camera).animState as libc::c_int {
        0 | 10 | 20 => {
            (*anim).animTimer = 50 as libc::c_int as s16;
            (*camera).animState += 1
        }
        _ => { }
    }
    (*camera).yawUpdateRateInv =
        Camera_LERPCeilF((*batt4).lerpUpdateRate, (*camera).yawUpdateRateInv,
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                25 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32 *
                             (*camera).speedRatio, 0.1f32);
    (*camera).rUpdateRateInv = 1000.0f32;
    (*camera).pitchUpdateRateInv = 1000.0f32;
    (*camera).xzOffsetUpdateRate =
        Camera_LERPCeilF(0.025f32, (*camera).xzOffsetUpdateRate,
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                25 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32,
                         0.1f32);
    (*camera).yOffsetUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                3 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).yOffsetUpdateRate,
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                26 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32 *
                             (*camera).speedRatio, 0.1f32);
    (*camera).fovUpdateRate = 0.0001f32;
    Camera_CalcAtDefault(camera, &mut eyeNextAtOffset, (*batt4).yOffset,
                         1 as libc::c_int as s16);
    if (*anim).animTimer as libc::c_int != 0 as libc::c_int {
        eyeNextOffset.yaw = eyeAtOffset.yaw;
        eyeNextOffset.pitch = eyeAtOffset.pitch;
        eyeNextOffset.r = eyeAtOffset.r;
        (*anim).animTimer -= 1
    } else {
        eyeNextOffset.yaw = eyeAtOffset.yaw;
        eyeNextOffset.pitch =
            Camera_LERPCeilS((*batt4).pitchTarget, eyeAtOffset.pitch,
                             (*batt4).lerpUpdateRate,
                             2 as libc::c_int as s16);
        eyeNextOffset.r =
            Camera_LERPCeilF((*batt4).rTarget, eyeAtOffset.r,
                             (*batt4).lerpUpdateRate, 0.001f32)
    }
    Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut eyeNextOffset);
    *eye = *eyeNext;
    (*camera).dist = eyeNextOffset.r;
    (*camera).fov =
        Camera_LERPCeilF((*batt4).fovTarget, (*camera).fov,
                         (*batt4).lerpUpdateRate, 1.0f32);
    (*camera).roll = 0 as libc::c_int as s16;
    (*camera).atLERPStepScale =
        Camera_ClampLERPScale(camera, (*batt4).atLERPTarget);
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Battle0(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
// Targeting non-enemy
#[no_mangle]
pub unsafe extern "C" fn Camera_KeepOn1(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut sp120: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut sp114: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut sp108: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut sp104: f32_0 = 0.;
    let mut temp_f12_2: f32_0 = 0.;
    let mut temp_f14: f32_0 = 0.;
    let mut t1: f32_0 = 0.;
    let mut spF4: f32_0 = 0.;
    let mut spF0: f32_0 = 0.;
    let mut spEC: f32_0 = 0.;
    let mut spE8: f32_0 = 0.;
    let mut t2: f32_0 = 0.;
    let mut spE2: s16 = 0;
    let mut spE0: s16 = 0;
    let mut spD8: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut spD0: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut spC8: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut spC0: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut spB8: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut sp8C: CamColChk =
        CamColChk{pos: Vec3f{x: 0., y: 0., z: 0.,},
                  norm: Vec3f{x: 0., y: 0., z: 0.,},
                  poly: 0 as *mut CollisionPoly,
                  sphNorm: VecSph{r: 0., pitch: 0, yaw: 0,},
                  bgId: 0,};
    let mut sp88: s32 = 0;
    let mut sp84: f32_0 = 0.;
    let mut sp82: s16 = 0;
    let mut sp80: s16 = 0;
    let mut keep1: *mut KeepOn1 =
        (*camera).paramData.as_mut_ptr() as *mut KeepOn1;
    let mut anim: *mut Keep1Anim = &mut (*keep1).anim;
    let mut t3: s16 = 0;
    let mut playerHeight: f32_0 = 0.;
    sp88 = 0 as libc::c_int;
    playerHeight = Player_GetHeight((*camera).player);
    if (*camera).target.is_null() || (*(*camera).target).update.is_none() {
        if (*camera).target.is_null() {
            osSyncPrintf(b"\x1b[43;30mcamera: warning: keepon: target is not valid, change parallel\n\x1b[m\x00"
                             as *const u8 as *const libc::c_char);
        }
        (*camera).target = 0 as *mut Actor;
        Camera_ChangeMode(camera, CAM_MODE_TARGET as libc::c_int as s16);
        return 1 as libc::c_int
    }
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let mut yNormal: f32_0 =
            1.0f32 +
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 -
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 * (68.0f32 / playerHeight);
        let fresh86 = values;
        values = values.offset(1);
        (*keep1).unk_00 =
            (*fresh86).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh87 = values;
        values = values.offset(1);
        (*keep1).unk_04 = (*fresh87).val as f32_0;
        let fresh88 = values;
        values = values.offset(1);
        (*keep1).unk_08 = (*fresh88).val as f32_0;
        let fresh89 = values;
        values = values.offset(1);
        (*keep1).unk_0C = (*fresh89).val as f32_0;
        let fresh90 = values;
        values = values.offset(1);
        (*keep1).unk_10 = (*fresh90).val as f32_0;
        let fresh91 = values;
        values = values.offset(1);
        (*keep1).unk_14 = (*fresh91).val as f32_0;
        let fresh92 = values;
        values = values.offset(1);
        (*keep1).unk_18 = (*fresh92).val as f32_0;
        let fresh93 = values;
        values = values.offset(1);
        (*keep1).unk_1C =
            (*fresh93).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh94 = values;
        values = values.offset(1);
        (*keep1).unk_20 = (*fresh94).val as f32_0;
        let fresh95 = values;
        values = values.offset(1);
        (*keep1).unk_24 =
            (*fresh95).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh96 = values;
        values = values.offset(1);
        (*keep1).interfaceFlags = (*fresh96).val;
        let fresh97 = values;
        values = values.offset(1);
        (*keep1).unk_28 =
            (*fresh97).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh98 = values;
        values = values.offset(1);
        (*keep1).unk_2C =
            (*fresh98).val as libc::c_int as libc::c_float * 0.01f32
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    playerHeight += (*keep1).unk_00;
    OLib_Vec3fDiffToVecSphGeo(&mut spC0, at, eye);
    OLib_Vec3fDiffToVecSphGeo(&mut spB8, at, eyeNext);
    sCameraInterfaceFlags = (*keep1).interfaceFlags as s32;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int {
        (*camera).animState += 1;
        (*anim).unk_10 = 0 as libc::c_int as s16;
        (*anim).unk_04 = 0.0f32;
        (*anim).unk_0C = (*camera).target;
        (*anim).unk_16 =
            ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                    16 as libc::c_int + 23 as libc::c_int) as
                                   usize] as libc::c_int +
                 (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                        16 as libc::c_int + 24 as libc::c_int)
                                       as usize] as libc::c_int) as s16;
        (*anim).unk_12 = spC0.yaw;
        (*anim).unk_14 = spC0.pitch;
        (*anim).unk_00 = spC0.r;
        (*anim).unk_08 = (*playerPosRot).pos.y - (*camera).playerPosDelta.y
    }
    if (*camera).status as libc::c_int == 7 as libc::c_int {
        sUpdateCameraDirection = 1 as libc::c_int;
        (*camera).inputDir.x = -(spC0.pitch as libc::c_int) as s16;
        (*camera).inputDir.y =
            (spC0.yaw as libc::c_int - 0x7fff as libc::c_int) as s16;
        (*camera).inputDir.z = 0 as libc::c_int as s16
    }
    sp104 = (*keep1).unk_04;
    sp84 = 1 as libc::c_int as f32_0;
    let mut current_block_82: u64;
    match (*camera).paramFlags as libc::c_int & 0x18 as libc::c_int {
        8 => {
            if (*(*camera).player).actor.category as libc::c_int ==
                   2 as libc::c_int &&
                   (*(*camera).player).interactRangeActor == (*camera).target
               {
                let mut sp54: PosRot =
                    PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
                           rot: Vec3s{x: 0, y: 0, z: 0,},};
                Actor_GetFocus(&mut sp54, &mut (*(*camera).player).actor);
                spC8.r = 60.0f32;
                spC8.yaw = (*camera).playerPosRot.rot.y;
                spC8.pitch = 0x2ee0 as libc::c_int as s16;
                Camera_Vec3fVecSphGeoAdd(&mut (*camera).targetPosRot.pos,
                                         &mut sp54.pos, &mut spC8);
            } else {
                Actor_GetFocus(&mut (*camera).targetPosRot, (*camera).target);
            }
            Actor_GetFocus(&mut (*camera).targetPosRot, (*camera).target);
            if (*anim).unk_0C != (*camera).target {
                (*anim).unk_0C = (*camera).target;
                (*camera).atLERPStepScale = 0.0f32
            }
            (*camera).xzOffsetUpdateRate =
                Camera_LERPCeilF(1.0f32, (*camera).xzOffsetUpdateRate,
                                 (*gGameInfo).data[(2 as libc::c_int *
                                                        6 as libc::c_int *
                                                        16 as libc::c_int +
                                                        25 as libc::c_int) as
                                                       usize] as libc::c_int
                                     as libc::c_float * 0.01f32 *
                                     (*camera).speedRatio, 0.1f32);
            (*camera).yOffsetUpdateRate =
                Camera_LERPCeilF(1.0f32, (*camera).yOffsetUpdateRate,
                                 (*gGameInfo).data[(2 as libc::c_int *
                                                        6 as libc::c_int *
                                                        16 as libc::c_int +
                                                        26 as libc::c_int) as
                                                       usize] as libc::c_int
                                     as libc::c_float * 0.01f32 *
                                     (*camera).speedRatio, 0.1f32);
            (*camera).fovUpdateRate =
                Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                        6 as libc::c_int *
                                                        16 as libc::c_int +
                                                        4 as libc::c_int) as
                                                       usize] as libc::c_int
                                     as libc::c_float * 0.01f32,
                                 (*camera).fovUpdateRate,
                                 (*camera).speedRatio * 0.05f32, 0.1f32);
            current_block_82 = 5159095217981812813;
        }
        16 => {
            (*anim).unk_0C = 0 as *mut Actor;
            current_block_82 = 5159095217981812813;
        }
        _ => {
            *at = (*playerPosRot).pos;
            (*at).y += playerHeight;
            (*anim).unk_0C = 0 as *mut Actor;
            current_block_82 = 6014157347423944569;
        }
    }
    match current_block_82 {
        5159095217981812813 => {
            if (*camera).playerGroundY == (*camera).playerPosRot.pos.y ||
                   (*(*camera).player).actor.gravity > -0.1f32 ||
                   (*(*camera).player).stateFlags1 &
                       0x200000 as libc::c_int as libc::c_uint != 0 {
                (*anim).unk_08 = (*playerPosRot).pos.y;
                sp80 = 0 as libc::c_int as s16
            } else { sp80 = 1 as libc::c_int as s16 }
            Camera_CalcAtForLockOn(camera, &mut spB8,
                                   &mut (*camera).targetPosRot.pos,
                                   if sp80 as libc::c_int != 0 {
                                       (*keep1).unk_28
                                   } else { (*keep1).unk_00 }, sp104,
                                   &mut (*anim).unk_08, &mut spC8,
                                   ((if sp80 as libc::c_int != 0 {
                                         0x80 as libc::c_int
                                     } else { 0 as libc::c_int }) |
                                        (*keep1).interfaceFlags as
                                            libc::c_int) as s16);
            sp114 = (*playerPosRot).pos;
            sp114.y += playerHeight;
            OLib_Vec3fDiffToVecSphGeo(&mut spC8, &mut sp114,
                                      &mut (*camera).targetPosRot.pos);
            sp84 = if spC8.r > sp104 { 1.0f32 } else { (spC8.r) / sp104 }
        }
        _ => { }
    }
    OLib_Vec3fDiffToVecSphGeo(&mut spD8, at, eyeNext);
    if spD8.r < (*keep1).unk_04 {
        sp104 = (*keep1).unk_04;
        spE8 =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 6 as libc::c_int) as
                                  usize] as f32_0
    } else if (*keep1).unk_08 < spD8.r {
        sp104 = (*keep1).unk_08;
        spE8 =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 6 as libc::c_int) as
                                  usize] as f32_0
    } else { sp104 = spD8.r; spE8 = 1.0f32 }
    (*camera).rUpdateRateInv =
        Camera_LERPCeilF(spE8, (*camera).rUpdateRateInv,
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                25 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32,
                         0.1f32);
    (*camera).dist =
        Camera_LERPCeilF(sp104, (*camera).dist,
                         1.0f32 / (*camera).rUpdateRateInv, 0.2f32);
    spE8 = (*camera).dist;
    spD8.r = spE8;
    sp108 = (*camera).targetPosRot.pos;
    OLib_Vec3fDiffToVecSphGeo(&mut spD0, at, &mut sp108);
    spD0.r = spE8 - (if spD0.r <= spE8 { spD0.r } else { spE8 }) * 0.5f32;
    spEC =
        (*keep1).unk_0C +
            ((*keep1).unk_10 - (*keep1).unk_0C) * (1.1f32 - sp84);
    spF0 =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 13 as libc::c_int) as
                              usize] as libc::c_int as libc::c_float + spEC;
    (*camera).dist =
        Camera_LERPCeilF(spE8, (*camera).dist,
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                11 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32,
                         2.0f32);
    spD8.r = (*camera).dist;
    spD8.yaw = spB8.yaw;
    spE2 =
        (spD0.yaw as libc::c_int -
             (spB8.yaw as libc::c_int - 0x7fff as libc::c_int) as s16 as
                 libc::c_int) as s16;
    if (*anim).unk_16 as libc::c_int != 0 as libc::c_int {
        if (*anim).unk_16 as libc::c_int >=
               (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                      16 as libc::c_int + 24 as libc::c_int)
                                     as usize] as libc::c_int {
            sp82 =
                ((*anim).unk_16 as libc::c_int -
                     (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                            16 as libc::c_int +
                                            24 as libc::c_int) as usize] as
                         libc::c_int) as s16;
            spE2 = spC8.yaw;
            OLib_Vec3fDiffToVecSphGeo(&mut spC8, at, eye);
            spC8.yaw = (spE2 as libc::c_int - 0x7fff as libc::c_int) as s16;
            t2 =
                1.0f32 /
                    (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                           16 as libc::c_int +
                                           23 as libc::c_int) as usize] as
                        libc::c_int as libc::c_float;
            spE8 = ((*anim).unk_00 - spC8.r) * t2;
            spE2 =
                (((*anim).unk_12 as libc::c_int - spC8.yaw as libc::c_int) as
                     s16 as libc::c_int as libc::c_float * t2) as s16;
            spE0 =
                (((*anim).unk_14 as libc::c_int - spC8.pitch as libc::c_int)
                     as s16 as libc::c_int as libc::c_float * t2) as s16;
            spD8.r =
                Camera_LERPCeilF(spC8.r +
                                     spE8 *
                                         sp82 as libc::c_int as libc::c_float,
                                 spC0.r,
                                 (*gGameInfo).data[(2 as libc::c_int *
                                                        6 as libc::c_int *
                                                        16 as libc::c_int +
                                                        28 as libc::c_int) as
                                                       usize] as libc::c_int
                                     as libc::c_float * 0.01f32, 1.0f32);
            spD8.yaw =
                Camera_LERPCeilS((spC8.yaw as libc::c_int +
                                      spE2 as libc::c_int *
                                          sp82 as libc::c_int) as s16,
                                 spC0.yaw,
                                 (*gGameInfo).data[(2 as libc::c_int *
                                                        6 as libc::c_int *
                                                        16 as libc::c_int +
                                                        28 as libc::c_int) as
                                                       usize] as libc::c_int
                                     as libc::c_float * 0.01f32,
                                 0xa as libc::c_int as s16);
            spD8.pitch =
                Camera_LERPCeilS((spC8.pitch as libc::c_int +
                                      spE0 as libc::c_int *
                                          sp82 as libc::c_int) as s16,
                                 spC0.pitch,
                                 (*gGameInfo).data[(2 as libc::c_int *
                                                        6 as libc::c_int *
                                                        16 as libc::c_int +
                                                        28 as libc::c_int) as
                                                       usize] as libc::c_int
                                     as libc::c_float * 0.01f32,
                                 0xa as libc::c_int as s16)
        } else { sp88 = 1 as libc::c_int }
        (*anim).unk_16 -= 1
    } else if (if spE2 as libc::c_int >= 0 as libc::c_int {
                   spE2 as libc::c_int
               } else { -(spE2 as libc::c_int) }) >
                  (spEC * 182.04167f32 + 0.5f32) as s16 as libc::c_int {
        spF4 = spE2 as f32_0 * (360.0001525f32 / 65535.0f32);
        t2 =
            spEC +
                (spF0 - spEC) * (OLib_ClampMaxDist(spD0.r, spD8.r) / spD8.r);
        temp_f12_2 = (t2 * t2 - 2.0f32) / (t2 - 360.0f32);
        t1 = temp_f12_2 * spF4 + (2.0f32 - 360.0f32 * temp_f12_2);
        temp_f14 = spF4 * spF4 / t1;
        spE0 =
            if spE2 as libc::c_int >= 0 as libc::c_int {
                (temp_f14 * 182.04167f32 + 0.5f32) as s16 as libc::c_int
            } else {
                -((temp_f14 * 182.04167f32 + 0.5f32) as s16 as libc::c_int)
            } as s16;
        spD8.yaw =
            (((spB8.yaw as libc::c_int - 0x7fff as libc::c_int) as s16 as
                  libc::c_int + spE0 as libc::c_int) as s16 as libc::c_int -
                 0x7fff as libc::c_int) as s16
    } else {
        spF4 = 0.02f32;
        spF4 = (1.0f32 - (*camera).speedRatio) * spF4;
        spE0 =
            if spE2 as libc::c_int >= 0 as libc::c_int {
                (spEC * 182.04167f32 + 0.5f32) as s16 as libc::c_int
            } else { -((spEC * 182.04167f32 + 0.5f32) as s16 as libc::c_int) }
                as s16;
        spD8.yaw =
            (spB8.yaw as libc::c_int -
                 ((spE0 as libc::c_int - spE2 as libc::c_int) as libc::c_float
                      * spF4) as s16 as libc::c_int) as s16
    }
    if sp88 == 0 as libc::c_int {
        spE2 =
            (((*keep1).unk_14 + ((*keep1).unk_18 - (*keep1).unk_14) * sp84) *
                 182.04167f32 + 0.5f32) as s16;
        spE2 =
            (spE2 as libc::c_int -
                 (spC8.pitch as libc::c_int as libc::c_float *
                      (0.5f32 + sp84 * 0.5f32)) as s16 as libc::c_int) as s16;
        spE8 = spD0.pitch as libc::c_int as libc::c_float * (*keep1).unk_1C;
        spE2 = (spE2 as libc::c_int + spE8 as s16 as libc::c_int) as s16;
        if (spE2 as libc::c_int) < -(0x3200 as libc::c_int) {
            spE2 = -(0x3200 as libc::c_int) as s16
        } else if spE2 as libc::c_int > 0x3200 as libc::c_int {
            spE2 = 0x3200 as libc::c_int as s16
        }
        spD8.pitch =
            Camera_LERPCeilS(spE2, spB8.pitch,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    12 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32,
                             0xa as libc::c_int as s16);
        Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut spD8);
        sp8C.pos = *eyeNext;
        if (*camera).status as libc::c_int == 7 as libc::c_int {
            if (*(*camera).globalCtx).envCtx.skyboxDisabled == 0 ||
                   (*keep1).interfaceFlags as libc::c_int & 1 as libc::c_int
                       != 0 {
                Camera_BGCheckInfo(camera, at, &mut sp8C);
            } else if (*keep1).interfaceFlags as libc::c_int &
                          2 as libc::c_int != 0 {
                func_80043F94(camera, at, &mut sp8C);
            } else {
                OLib_Vec3fDistNormalize(&mut sp120, at, &mut sp8C.pos);
                sp8C.pos.x -= sp120.x;
                sp8C.pos.y -= sp120.y;
                sp8C.pos.z -= sp120.z
            }
            *eye = sp8C.pos
        } else { *eye = *eyeNext }
        OLib_Vec3fDistNormalize(&mut sp120, eye, at);
        Camera_Vec3fTranslateByUnitVector(eye, eye, &mut sp120,
                                          (*gGameInfo).data[(2 as libc::c_int
                                                                 *
                                                                 6 as
                                                                     libc::c_int
                                                                 *
                                                                 16 as
                                                                     libc::c_int
                                                                 +
                                                                 1 as
                                                                     libc::c_int)
                                                                as usize] as
                                              f32_0);
    }
    (*camera).fov =
        Camera_LERPCeilF((*keep1).unk_20, (*camera).fov,
                         (*camera).fovUpdateRate, 1.0f32);
    (*camera).roll =
        Camera_LERPCeilS(0 as libc::c_int as s16, (*camera).roll, 0.5f32,
                         0xa as libc::c_int as s16);
    (*camera).atLERPStepScale =
        Camera_ClampLERPScale(camera,
                              if sp80 as libc::c_int != 0 {
                                  (*keep1).unk_2C
                              } else { (*keep1).unk_24 });
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_KeepOn2(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
/* *
 * Talking to an NPC
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_KeepOn3(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut playerHeadPos: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut lineChkPointB: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut temp_f0: f32_0 = 0.;
    let mut spBC: f32_0 = 0.;
    let mut prevTargetPlayerDist: f32_0 = 0.;
    let mut swingAngle: f32_0 = 0.;
    let mut colChkActors: [*mut Actor; 2] = [0 as *mut Actor; 2];
    let mut targetToPlayerDir: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut atToEyeAdj: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut atToEyeDir: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut atToEyeNextDir: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut i: s32 = 0;
    let mut angleCnt: s32 = 0;
    let mut sp82: s16 = 0;
    let mut sp80: s16 = 0;
    let mut playerPosRot: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut camPlayerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut keep3: *mut KeepOn3 =
        (*camera).paramData.as_mut_ptr() as *mut KeepOn3;
    let mut anim: *mut Keep3Anim = &mut (*keep3).anim;
    let mut pad: s32 = 0;
    let mut playerHeight: f32_0 = 0.;
    playerHeight = Player_GetHeight((*camera).player);
    if (*camera).target.is_null() || (*(*camera).target).update.is_none() {
        if (*camera).target.is_null() {
            osSyncPrintf(b"\x1b[43;30mcamera: warning: talk: target is not valid, change parallel\n\x1b[m\x00"
                             as *const u8 as *const libc::c_char);
        }
        (*camera).target = 0 as *mut Actor;
        Camera_ChangeMode(camera, CAM_MODE_TARGET as libc::c_int as s16);
        return 1 as libc::c_int
    }
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int {
        if (*(*camera).globalCtx).view.unk_124 == 0 as libc::c_int {
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int | 0x20 as libc::c_int) as
                    s16;
            (*(*camera).globalCtx).view.unk_124 =
                (*camera).thisIdx as libc::c_int | 0x50 as libc::c_int;
            return 1 as libc::c_int
        }
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int & !(0x20 as libc::c_int)) as s16
    }
    (*camera).unk_14C =
        ((*camera).unk_14C as libc::c_int & !(0x10 as libc::c_int)) as s16;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let mut yNormal: f32_0 =
            1.0f32 +
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 -
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 * (68.0f32 / playerHeight);
        let fresh99 = values;
        values = values.offset(1);
        (*keep3).yOffset =
            (*fresh99).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh100 = values;
        values = values.offset(1);
        (*keep3).minDist = (*fresh100).val as f32_0;
        let fresh101 = values;
        values = values.offset(1);
        (*keep3).maxDist = (*fresh101).val as f32_0;
        let fresh102 = values;
        values = values.offset(1);
        (*keep3).swingYawInital = (*fresh102).val as f32_0;
        let fresh103 = values;
        values = values.offset(1);
        (*keep3).swingYawFinal = (*fresh103).val as f32_0;
        let fresh104 = values;
        values = values.offset(1);
        (*keep3).swingPitchInitial = (*fresh104).val as f32_0;
        let fresh105 = values;
        values = values.offset(1);
        (*keep3).swingPitchFinal = (*fresh105).val as f32_0;
        let fresh106 = values;
        values = values.offset(1);
        (*keep3).swingPitchAdj =
            (*fresh106).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh107 = values;
        values = values.offset(1);
        (*keep3).fovTarget = (*fresh107).val as f32_0;
        let fresh108 = values;
        values = values.offset(1);
        (*keep3).atLERPScaleMax =
            (*fresh108).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh109 = values;
        values = values.offset(1);
        (*keep3).initTimer = (*fresh109).val;
        let fresh110 = values;
        values = values.offset(1);
        (*keep3).flags = (*fresh110).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    playerHeight += (*keep3).yOffset;
    OLib_Vec3fDiffToVecSphGeo(&mut atToEyeDir, at, eye);
    OLib_Vec3fDiffToVecSphGeo(&mut atToEyeNextDir, at, eyeNext);
    Actor_GetFocus(&mut (*camera).targetPosRot, (*camera).target);
    Actor_GetFocus(&mut playerPosRot, &mut (*(*camera).player).actor);
    playerHeadPos = (*camPlayerPosRot).pos;
    playerHeadPos.y += playerHeight;
    OLib_Vec3fDiffToVecSphGeo(&mut targetToPlayerDir, &mut playerHeadPos,
                              &mut (*camera).targetPosRot.pos);
    sCameraInterfaceFlags = (*keep3).flags as s32;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int {
        colChkActors[0 as libc::c_int as usize] = (*camera).target;
        colChkActors[1 as libc::c_int as usize] =
            &mut (*(*camera).player).actor;
        (*camera).animState += 1;
        (*anim).target = (*camera).target;
        temp_f0 =
            if (*keep3).maxDist < targetToPlayerDir.r {
                1.0f32
            } else { (targetToPlayerDir.r) / (*keep3).maxDist };
        (*anim).animTimer = (*keep3).initTimer;
        spBC =
            (1.0f32 - temp_f0) * targetToPlayerDir.r /
                (*anim).animTimer as libc::c_int as libc::c_float;
        swingAngle =
            (*keep3).swingPitchInitial +
                ((*keep3).swingPitchFinal - (*keep3).swingPitchInitial) *
                    temp_f0;
        atToEyeAdj.pitch =
            ((swingAngle * 182.04167f32 + 0.5f32) as s16 as libc::c_int +
                 -(targetToPlayerDir.pitch as libc::c_int as libc::c_float *
                       (*keep3).swingPitchAdj) as s16 as libc::c_int) as s16;
        swingAngle =
            (*keep3).swingYawInital +
                ((*keep3).swingYawFinal - (*keep3).swingYawInital) * temp_f0;
        if (*keep3).flags as libc::c_int & 0x10 as libc::c_int != 0 {
            if ((targetToPlayerDir.yaw as libc::c_int -
                     atToEyeNextDir.yaw as libc::c_int) as s16 as libc::c_int)
                   < 0 as libc::c_int {
                atToEyeAdj.yaw =
                    (targetToPlayerDir.yaw as libc::c_int +
                         (swingAngle * 182.04167f32 + 0.5f32) as s16 as
                             libc::c_int) as s16
            } else {
                atToEyeAdj.yaw =
                    (targetToPlayerDir.yaw as libc::c_int -
                         (swingAngle * 182.04167f32 + 0.5f32) as s16 as
                             libc::c_int) as s16
            }
        } else if (*keep3).flags as libc::c_int & 0x20 as libc::c_int != 0 {
            if ((targetToPlayerDir.yaw as libc::c_int -
                     atToEyeNextDir.yaw as libc::c_int) as s16 as libc::c_int)
                   < 0 as libc::c_int {
                atToEyeAdj.yaw =
                    ((targetToPlayerDir.yaw as libc::c_int -
                          0x7fff as libc::c_int) as s16 as libc::c_int -
                         (swingAngle * 182.04167f32 + 0.5f32) as s16 as
                             libc::c_int) as s16
            } else {
                atToEyeAdj.yaw =
                    ((targetToPlayerDir.yaw as libc::c_int -
                          0x7fff as libc::c_int) as s16 as libc::c_int +
                         (swingAngle * 182.04167f32 + 0.5f32) as s16 as
                             libc::c_int) as s16
            }
        } else if (if (targetToPlayerDir.yaw as libc::c_int -
                           atToEyeNextDir.yaw as libc::c_int) as s16 as
                          libc::c_int >= 0 as libc::c_int {
                       (targetToPlayerDir.yaw as libc::c_int -
                            atToEyeNextDir.yaw as libc::c_int) as s16 as
                           libc::c_int
                   } else {
                       -((targetToPlayerDir.yaw as libc::c_int -
                              atToEyeNextDir.yaw as libc::c_int) as s16 as
                             libc::c_int)
                   }) < 0x3fff as libc::c_int {
            if ((targetToPlayerDir.yaw as libc::c_int -
                     atToEyeNextDir.yaw as libc::c_int) as s16 as libc::c_int)
                   < 0 as libc::c_int {
                atToEyeAdj.yaw =
                    (targetToPlayerDir.yaw as libc::c_int +
                         (swingAngle * 182.04167f32 + 0.5f32) as s16 as
                             libc::c_int) as s16
            } else {
                atToEyeAdj.yaw =
                    (targetToPlayerDir.yaw as libc::c_int -
                         (swingAngle * 182.04167f32 + 0.5f32) as s16 as
                             libc::c_int) as s16
            }
        } else if ((targetToPlayerDir.yaw as libc::c_int -
                        atToEyeNextDir.yaw as libc::c_int) as s16 as
                       libc::c_int) < 0 as libc::c_int {
            atToEyeAdj.yaw =
                ((targetToPlayerDir.yaw as libc::c_int -
                      0x7fff as libc::c_int) as s16 as libc::c_int -
                     (swingAngle * 182.04167f32 + 0.5f32) as s16 as
                         libc::c_int) as s16
        } else {
            atToEyeAdj.yaw =
                ((targetToPlayerDir.yaw as libc::c_int -
                      0x7fff as libc::c_int) as s16 as libc::c_int +
                     (swingAngle * 182.04167f32 + 0.5f32) as s16 as
                         libc::c_int) as s16
        }
        prevTargetPlayerDist = targetToPlayerDir.r;
        temp_f0 = 0.6f32;
        targetToPlayerDir.r =
            spBC * 0.6f32 + prevTargetPlayerDist * (1.0f32 - temp_f0);
        sp80 = atToEyeAdj.yaw;
        sp82 = atToEyeAdj.pitch;
        playerHeadPos = (*camPlayerPosRot).pos;
        playerHeadPos.y += playerHeight;
        Camera_Vec3fVecSphGeoAdd(&mut (*anim).atTarget, &mut playerHeadPos,
                                 &mut targetToPlayerDir);
        angleCnt =
            (::std::mem::size_of::<[s16; 14]>() as
                 libc::c_ulong).wrapping_div(::std::mem::size_of::<s16>() as
                                                 libc::c_ulong) as s32;
        i = 0 as libc::c_int;
        targetToPlayerDir.r = prevTargetPlayerDist;
        atToEyeAdj.r =
            (*keep3).minDist +
                targetToPlayerDir.r *
                    (1 as libc::c_int as libc::c_float - 0.5f32) -
                atToEyeNextDir.r + atToEyeNextDir.r;
        Camera_Vec3fVecSphGeoAdd(&mut lineChkPointB, &mut (*anim).atTarget,
                                 &mut atToEyeAdj);
        if (*keep3).flags as libc::c_int & 0x80 as libc::c_int == 0 {
            while i < angleCnt {
                if CollisionCheck_LineOCCheck((*camera).globalCtx,
                                              &mut (*(*camera).globalCtx).colChkCtx,
                                              &mut (*anim).atTarget,
                                              &mut lineChkPointB,
                                              colChkActors.as_mut_ptr(),
                                              2 as libc::c_int) == 0 &&
                       Camera_BGCheck(camera, &mut (*anim).atTarget,
                                      &mut lineChkPointB) == 0 {
                    break ;
                }
                atToEyeAdj.yaw =
                    (sp80 as libc::c_int +
                         D_8011D3B0[i as usize] as libc::c_int) as s16;
                atToEyeAdj.pitch =
                    (sp82 as libc::c_int +
                         D_8011D3CC[i as usize] as libc::c_int) as s16;
                Camera_Vec3fVecSphGeoAdd(&mut lineChkPointB,
                                         &mut (*anim).atTarget,
                                         &mut atToEyeAdj);
                i += 1
            }
        }
        osSyncPrintf(b"camera: talk: BG&collision check %d time(s)\n\x00" as
                         *const u8 as *const libc::c_char, i);
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int & !(0xc as libc::c_int)) as s16;
        pad =
            ((*anim).animTimer as libc::c_int + 1 as libc::c_int) *
                (*anim).animTimer as libc::c_int >> 1 as libc::c_int;
        (*anim).eyeToAtTarget.y =
            (atToEyeAdj.yaw as libc::c_int -
                 atToEyeNextDir.yaw as libc::c_int) as s16 as f32_0 /
                pad as libc::c_float;
        (*anim).eyeToAtTarget.z =
            (atToEyeAdj.pitch as libc::c_int -
                 atToEyeNextDir.pitch as libc::c_int) as s16 as f32_0 /
                pad as libc::c_float;
        (*anim).eyeToAtTarget.x =
            (atToEyeAdj.r - atToEyeNextDir.r) / pad as libc::c_float;
        return 1 as libc::c_int
    }
    if (*anim).animTimer as libc::c_int != 0 as libc::c_int {
        (*at).x +=
            ((*anim).atTarget.x - (*at).x) /
                (*anim).animTimer as libc::c_int as libc::c_float;
        (*at).y +=
            ((*anim).atTarget.y - (*at).y) /
                (*anim).animTimer as libc::c_int as libc::c_float;
        (*at).z +=
            ((*anim).atTarget.z - (*at).z) /
                (*anim).animTimer as libc::c_int as libc::c_float;
        // needed to match
        (prevTargetPlayerDist) == 0.;
        atToEyeAdj.r =
            (*anim).eyeToAtTarget.x *
                (*anim).animTimer as libc::c_int as libc::c_float +
                atToEyeNextDir.r + 1.0f32;
        atToEyeAdj.yaw =
            (atToEyeNextDir.yaw as libc::c_int +
                 ((*anim).eyeToAtTarget.y *
                      (*anim).animTimer as libc::c_int as libc::c_float) as
                     s16 as libc::c_int) as s16;
        atToEyeAdj.pitch =
            (atToEyeNextDir.pitch as libc::c_int +
                 ((*anim).eyeToAtTarget.z *
                      (*anim).animTimer as libc::c_int as libc::c_float) as
                     s16 as libc::c_int) as s16;
        Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut atToEyeAdj);
        *eye = *eyeNext;
        (*camera).fov =
            Camera_LERPCeilF((*keep3).fovTarget, (*camera).fov,
                             0.5f64 as f32_0, 1.0f32);
        (*camera).roll =
            Camera_LERPCeilS(0 as libc::c_int as s16, (*camera).roll,
                             0.5f64 as f32_0, 0xa as libc::c_int as s16);
        (*camera).atLERPStepScale =
            Camera_ClampLERPScale(camera, (*keep3).atLERPScaleMax);
        Camera_BGCheck(camera, at, eye);
        (*anim).animTimer -= 1
    } else {
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int | 0x410 as libc::c_int) as s16
    }
    if (*camera).unk_14C as libc::c_int & 8 as libc::c_int != 0 {
        sCameraInterfaceFlags = 0 as libc::c_int;
        func_80043B60(camera);
        (*camera).atLERPStepScale = 0.0f32;
        if (*camera).xzSpeed > 0.001f32 ||
               !((*D_8015BD7C).state.input[0 as libc::c_int as
                                               usize].press.button as
                     libc::c_int | !(0x8000 as libc::c_int)) ==
                   0 as libc::c_int ||
               !((*D_8015BD7C).state.input[0 as libc::c_int as
                                               usize].press.button as
                     libc::c_int | !(0x4000 as libc::c_int)) ==
                   0 as libc::c_int ||
               !((*D_8015BD7C).state.input[0 as libc::c_int as
                                               usize].press.button as
                     libc::c_int | !(0x2 as libc::c_int)) == 0 as libc::c_int
               ||
               !((*D_8015BD7C).state.input[0 as libc::c_int as
                                               usize].press.button as
                     libc::c_int | !(0x4 as libc::c_int)) == 0 as libc::c_int
               ||
               !((*D_8015BD7C).state.input[0 as libc::c_int as
                                               usize].press.button as
                     libc::c_int | !(0x8 as libc::c_int)) == 0 as libc::c_int
               ||
               !((*D_8015BD7C).state.input[0 as libc::c_int as
                                               usize].press.button as
                     libc::c_int | !(0x1 as libc::c_int)) == 0 as libc::c_int
               ||
               !((*D_8015BD7C).state.input[0 as libc::c_int as
                                               usize].press.button as
                     libc::c_int | !(0x10 as libc::c_int)) == 0 as libc::c_int
               ||
               !((*D_8015BD7C).state.input[0 as libc::c_int as
                                               usize].press.button as
                     libc::c_int | !(0x2000 as libc::c_int)) ==
                   0 as libc::c_int {
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int | 4 as libc::c_int) as s16;
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int & !(8 as libc::c_int)) as
                    s16
        }
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_KeepOn4(mut camera: *mut Camera) -> s32 {
    static mut D_8015BD50: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    static mut D_8015BD60: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    static mut D_8015BD70: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut spCC: [*mut Actor; 2] = [0 as *mut Actor; 2];
    let mut t: f32_0 = -0.5f32;
    let mut temp_f0_2: f32_0 = 0.;
    let mut spC0: *mut CollisionPoly = 0 as *mut CollisionPoly;
    let mut spB8: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut spB0: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut spA8: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut temp_s0: *mut s16 = &mut (*camera).data2;
    let mut spA2: s16 = 0;
    let mut spA0: s16 = 0;
    let mut sp9E: s16 = 0;
    let mut sp9C: s16 = 0;
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut keep4: *mut KeepOn4 =
        (*camera).paramData.as_mut_ptr() as *mut KeepOn4;
    let mut unk20: *mut KeepOn4_Unk20 = &mut (*keep4).unk_20;
    let mut pad: s32 = 0;
    let mut playerHeight: f32_0 = 0.;
    let mut player: *mut Player =
        (*(*camera).globalCtx).actorCtx.actorLists[ACTORCAT_PLAYER as
                                                       libc::c_int as
                                                       usize].head as
            *mut Player;
    let mut angleCnt: s16 = 0;
    let mut i: s32 = 0;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int {
        if (*(*camera).globalCtx).view.unk_124 == 0 as libc::c_int {
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int | 0x20 as libc::c_int) as
                    s16;
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int &
                     !(0x4 as libc::c_int | 0x2 as libc::c_int)) as s16;
            (*(*camera).globalCtx).view.unk_124 =
                (*camera).thisIdx as libc::c_int | 0x50 as libc::c_int;
            return 1 as libc::c_int
        }
        (*unk20).unk_14 = *temp_s0;
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int & !(0x20 as libc::c_int)) as s16
    }
    if (*unk20).unk_14 as libc::c_int != *temp_s0 as libc::c_int {
        osSyncPrintf(b"\x1b[43;30mcamera: item: item type changed %d -> %d\n\x1b[m\x00"
                         as *const u8 as *const libc::c_char,
                     (*unk20).unk_14 as libc::c_int, *temp_s0 as libc::c_int);
        (*camera).animState = 0x14 as libc::c_int as s16;
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int | 0x20 as libc::c_int) as s16;
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int &
                 !(0x4 as libc::c_int | 0x2 as libc::c_int)) as s16;
        (*(*camera).globalCtx).view.unk_124 =
            (*camera).thisIdx as libc::c_int | 0x50 as libc::c_int;
        return 1 as libc::c_int
    }
    playerHeight = Player_GetHeight((*camera).player);
    (*camera).unk_14C =
        ((*camera).unk_14C as libc::c_int & !(0x10 as libc::c_int)) as s16;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let mut yNormal: f32_0 = 1.0f32 + t - 68.0f32 / playerHeight * t;
        let fresh111 = values;
        values = values.offset(1);
        (*keep4).unk_00 =
            (*fresh111).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh112 = values;
        values = values.offset(1);
        (*keep4).unk_04 =
            (*fresh112).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh113 = values;
        values = values.offset(1);
        (*keep4).unk_08 = (*fresh113).val as f32_0;
        let fresh114 = values;
        values = values.offset(1);
        (*keep4).unk_0C = (*fresh114).val as f32_0;
        let fresh115 = values;
        values = values.offset(1);
        (*keep4).unk_10 = (*fresh115).val as f32_0;
        let fresh116 = values;
        values = values.offset(1);
        (*keep4).unk_18 = (*fresh116).val as f32_0;
        let fresh117 = values;
        values = values.offset(1);
        (*keep4).unk_1C = (*fresh117).val;
        let fresh118 = values;
        values = values.offset(1);
        (*keep4).unk_14 =
            (*fresh118).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh119 = values;
        values = values.offset(1);
        (*keep4).unk_1E = (*fresh119).val;
        osSyncPrintf(b"camera: item: type %d\n\x00" as *const u8 as
                         *const libc::c_char, *temp_s0 as libc::c_int);
        match *temp_s0 as libc::c_int {
            1 => {
                (*keep4).unk_00 = playerHeight * -0.6f32 * yNormal;
                (*keep4).unk_04 = playerHeight * 2.0f32 * yNormal;
                (*keep4).unk_08 = 10.0f32
            }
            2 | 3 => { (*keep4).unk_08 = -20.0f32; (*keep4).unk_18 = 80.0f32 }
            4 => {
                (*keep4).unk_00 = playerHeight * -0.2f32 * yNormal;
                (*keep4).unk_08 = 25.0f32
            }
            8 => {
                (*keep4).unk_00 = playerHeight * -0.2f32 * yNormal;
                (*keep4).unk_04 = playerHeight * 0.8f32 * yNormal;
                (*keep4).unk_08 = 50.0f32;
                (*keep4).unk_18 = 70.0f32
            }
            9 => {
                (*keep4).unk_00 = playerHeight * 0.1f32 * yNormal;
                (*keep4).unk_04 = playerHeight * 0.5f32 * yNormal;
                (*keep4).unk_08 = -20.0f32;
                (*keep4).unk_0C = 0.0f32;
                (*keep4).unk_1C = 0x2540 as libc::c_int as s16
            }
            5 => {
                (*keep4).unk_00 = playerHeight * -0.4f32 * yNormal;
                (*keep4).unk_08 = -10.0f32;
                (*keep4).unk_0C = 45.0f32;
                (*keep4).unk_1C = 0x2002 as libc::c_int as s16
            }
            10 => {
                (*keep4).unk_00 = playerHeight * -0.5f32 * yNormal;
                (*keep4).unk_04 = playerHeight * 1.5f32 * yNormal;
                (*keep4).unk_08 = -15.0f32;
                (*keep4).unk_0C = 175.0f32;
                (*keep4).unk_18 = 70.0f32;
                (*keep4).unk_1C = 0x2202 as libc::c_int as s16;
                (*keep4).unk_1E = 0x3c as libc::c_int as s16
            }
            12 => {
                (*keep4).unk_00 = playerHeight * -0.6f32 * yNormal;
                (*keep4).unk_04 = playerHeight * 1.6f32 * yNormal;
                (*keep4).unk_08 = -2.0f32;
                (*keep4).unk_0C = 120.0f32;
                (*keep4).unk_10 =
                    if (*player).stateFlags1 &
                           0x8000000 as libc::c_int as libc::c_uint != 0 {
                        0.0f32
                    } else { 20.0f32 };
                (*keep4).unk_1C = 0x3212 as libc::c_int as s16;
                (*keep4).unk_1E = 0x1e as libc::c_int as s16;
                (*keep4).unk_18 = 50.0f32
            }
            90 => {
                (*keep4).unk_00 = playerHeight * -0.3f32 * yNormal;
                (*keep4).unk_18 = 45.0f32;
                (*keep4).unk_1C = 0x2f02 as libc::c_int as s16
            }
            91 => {
                (*keep4).unk_00 = playerHeight * -0.1f32 * yNormal;
                (*keep4).unk_04 = playerHeight * 1.5f32 * yNormal;
                (*keep4).unk_08 = -3.0f32;
                (*keep4).unk_0C = 10.0f32;
                (*keep4).unk_18 = 55.0f32;
                (*keep4).unk_1C = 0x2f08 as libc::c_int as s16
            }
            81 => {
                (*keep4).unk_00 = playerHeight * -0.3f32 * yNormal;
                (*keep4).unk_04 = playerHeight * 1.5f32 * yNormal;
                (*keep4).unk_08 = 2.0f32;
                (*keep4).unk_0C = 20.0f32;
                (*keep4).unk_10 = 20.0f32;
                (*keep4).unk_1C = 0x2280 as libc::c_int as s16;
                (*keep4).unk_1E = 0x1e as libc::c_int as s16;
                (*keep4).unk_18 = 45.0f32
            }
            11 => {
                (*keep4).unk_00 = playerHeight * -0.19f32 * yNormal;
                (*keep4).unk_04 = playerHeight * 0.7f32 * yNormal;
                (*keep4).unk_0C = 130.0f32;
                (*keep4).unk_10 = 10.0f32;
                (*keep4).unk_1C = 0x2522 as libc::c_int as s16
            }
            _ => { }
        }
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    sUpdateCameraDirection = 1 as libc::c_int;
    sCameraInterfaceFlags = (*keep4).unk_1C as s32;
    OLib_Vec3fDiffToVecSphGeo(&mut spB0, at, eye);
    OLib_Vec3fDiffToVecSphGeo(&mut spA8, at, eyeNext);
    D_8015BD50 = (*playerPosRot).pos;
    D_8015BD50.y += playerHeight;
    temp_f0_2 =
        BgCheck_CameraRaycastFloor2(&mut (*(*camera).globalCtx).colCtx,
                                    &mut spC0, &mut i, &mut D_8015BD50);
    if temp_f0_2 > (*keep4).unk_00 + D_8015BD50.y {
        D_8015BD50.y = temp_f0_2 + 10.0f32
    } else { D_8015BD50.y += (*keep4).unk_00 }
    sp9C = 0 as libc::c_int as s16;
    match (*camera).animState as libc::c_int {
        0 | 20 => {
            spCC[sp9C as usize] = &mut (*(*camera).player).actor;
            sp9C += 1;
            func_80043ABC(camera);
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int &
                     !(0x4 as libc::c_int | 0x2 as libc::c_int)) as s16;
            (*unk20).unk_10 = (*keep4).unk_1E;
            (*unk20).unk_08 =
                (*playerPosRot).pos.y - (*camera).playerPosDelta.y;
            if (*keep4).unk_1C as libc::c_int & 2 as libc::c_int != 0 {
                spA2 = ((*keep4).unk_08 * 182.04167f32 + 0.5f32) as s16;
                spA0 =
                    if (((*playerPosRot).rot.y as libc::c_int -
                             0x7fff as libc::c_int) as s16 as libc::c_int -
                            spA8.yaw as libc::c_int) as s16 as libc::c_int >
                           0 as libc::c_int {
                        (((*playerPosRot).rot.y as libc::c_int -
                              0x7fff as libc::c_int) as s16 as libc::c_int) +
                            ((*keep4).unk_0C * 182.04167f32 + 0.5f32) as s16
                                as libc::c_int
                    } else {
                        (((*playerPosRot).rot.y as libc::c_int -
                              0x7fff as libc::c_int) as s16 as libc::c_int) -
                            ((*keep4).unk_0C * 182.04167f32 + 0.5f32) as s16
                                as libc::c_int
                    } as s16
            } else if (*keep4).unk_1C as libc::c_int & 4 as libc::c_int != 0 {
                spA2 = ((*keep4).unk_08 * 182.04167f32 + 0.5f32) as s16;
                spA0 = ((*keep4).unk_0C * 182.04167f32 + 0.5f32) as s16
            } else if (*keep4).unk_1C as libc::c_int & 8 as libc::c_int != 0
                          && !(*camera).target.is_null() {
                let mut sp60: PosRot =
                    PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
                           rot: Vec3s{x: 0, y: 0, z: 0,},};
                Actor_GetWorldPosShapeRot(&mut sp60, (*camera).target);
                spA2 =
                    (((*keep4).unk_08 * 182.04167f32 + 0.5f32) as s16 as
                         libc::c_int - sp60.rot.x as libc::c_int) as s16;
                spA0 =
                    if ((sp60.rot.y as libc::c_int - 0x7fff as libc::c_int) as
                            s16 as libc::c_int - spA8.yaw as libc::c_int) as
                           s16 as libc::c_int > 0 as libc::c_int {
                        ((sp60.rot.y as libc::c_int - 0x7fff as libc::c_int)
                             as s16 as libc::c_int) +
                            ((*keep4).unk_0C * 182.04167f32 + 0.5f32) as s16
                                as libc::c_int
                    } else {
                        ((sp60.rot.y as libc::c_int - 0x7fff as libc::c_int)
                             as s16 as libc::c_int) -
                            ((*keep4).unk_0C * 182.04167f32 + 0.5f32) as s16
                                as libc::c_int
                    } as s16;
                spCC[1 as libc::c_int as usize] = (*camera).target;
                sp9C += 1
            } else if (*keep4).unk_1C as libc::c_int & 0x80 as libc::c_int !=
                          0 && !(*camera).target.is_null() {
                let mut sp4C: PosRot =
                    PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
                           rot: Vec3s{x: 0, y: 0, z: 0,},};
                Actor_GetWorld(&mut sp4C, (*camera).target);
                spA2 = ((*keep4).unk_08 * 182.04167f32 + 0.5f32) as s16;
                sp9E =
                    Camera_XZAngle(&mut sp4C.pos, &mut (*playerPosRot).pos);
                spA0 =
                    if (sp9E as libc::c_int - spA8.yaw as libc::c_int) as s16
                           as libc::c_int > 0 as libc::c_int {
                        (sp9E as libc::c_int) +
                            ((*keep4).unk_0C * 182.04167f32 + 0.5f32) as s16
                                as libc::c_int
                    } else {
                        (sp9E as libc::c_int) -
                            ((*keep4).unk_0C * 182.04167f32 + 0.5f32) as s16
                                as libc::c_int
                    } as s16;
                spCC[1 as libc::c_int as usize] = (*camera).target;
                sp9C += 1
            } else if (*keep4).unk_1C as libc::c_int & 0x40 as libc::c_int !=
                          0 {
                spA2 = ((*keep4).unk_08 * 182.04167f32 + 0.5f32) as s16;
                spA0 = spA8.yaw
            } else { spA2 = spA8.pitch; spA0 = spA8.yaw }
            spB8.pitch = spA2;
            spB8.yaw = spA0;
            spB8.r = (*keep4).unk_04;
            Camera_Vec3fVecSphGeoAdd(&mut D_8015BD70, &mut D_8015BD50,
                                     &mut spB8);
            if (*keep4).unk_1C as libc::c_int & 1 as libc::c_int == 0 {
                angleCnt =
                    (::std::mem::size_of::<[s16; 14]>() as
                         libc::c_ulong).wrapping_div(::std::mem::size_of::<s16>()
                                                         as libc::c_ulong) as
                        s32 as s16;
                i = 0 as libc::c_int;
                while i < angleCnt as libc::c_int {
                    if CollisionCheck_LineOCCheck((*camera).globalCtx,
                                                  &mut (*(*camera).globalCtx).colChkCtx,
                                                  &mut D_8015BD50,
                                                  &mut D_8015BD70,
                                                  spCC.as_mut_ptr(),
                                                  sp9C as s32) == 0 &&
                           Camera_BGCheck(camera, &mut D_8015BD50,
                                          &mut D_8015BD70) == 0 {
                        break ;
                    }
                    spB8.yaw =
                        (D_8011D3B0[i as usize] as libc::c_int +
                             spA0 as libc::c_int) as s16;
                    spB8.pitch =
                        (D_8011D3CC[i as usize] as libc::c_int +
                             spA2 as libc::c_int) as s16;
                    Camera_Vec3fVecSphGeoAdd(&mut D_8015BD70, &mut D_8015BD50,
                                             &mut spB8);
                    i += 1
                }
                osSyncPrintf(b"camera: item: BG&collision check %d time(s)\n\x00"
                                 as *const u8 as *const libc::c_char, i);
            }
            (*unk20).unk_04 =
                (spB8.pitch as libc::c_int - spA8.pitch as libc::c_int) as s16
                    as libc::c_int as libc::c_float /
                    (*unk20).unk_10 as f32_0;
            (*unk20).unk_00 =
                (spB8.yaw as libc::c_int - spA8.yaw as libc::c_int) as s16 as
                    libc::c_int as libc::c_float / (*unk20).unk_10 as f32_0;
            (*unk20).unk_0C = spA8.yaw;
            (*unk20).unk_0E = spA8.pitch;
            (*camera).animState += 1;
            (*unk20).unk_12 = 1 as libc::c_int as s16
        }
        10 => {
            (*unk20).unk_08 =
                (*playerPosRot).pos.y - (*camera).playerPosDelta.y
        }
        _ => { }
    }
    (*camera).xzOffsetUpdateRate = 0.25f32;
    (*camera).yOffsetUpdateRate = 0.25f32;
    (*camera).atLERPStepScale = 0.75f32;
    Camera_LERPCeilVec3f(&mut D_8015BD50, at, 0.5f32, 0.5f32, 0.2f32);
    if (*keep4).unk_10 != 0.0f32 {
        spB8.r = (*keep4).unk_10;
        spB8.pitch = 0 as libc::c_int as s16;
        spB8.yaw = (*playerPosRot).rot.y;
        Camera_Vec3fVecSphGeoAdd(at, at, &mut spB8);
    }
    (*camera).atLERPStepScale = 0.0f32;
    (*camera).dist =
        Camera_LERPCeilF((*keep4).unk_04, (*camera).dist, 0.25f32, 2.0f32);
    spB8.r = (*camera).dist;
    if (*unk20).unk_10 as libc::c_int != 0 as libc::c_int {
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int | 0x20 as libc::c_int) as s16;
        (*unk20).unk_0C =
            ((*unk20).unk_0C as libc::c_int +
                 (*unk20).unk_00 as s16 as libc::c_int) as s16;
        (*unk20).unk_0E =
            ((*unk20).unk_0E as libc::c_int +
                 (*unk20).unk_04 as s16 as libc::c_int) as s16;
        (*unk20).unk_10 -= 1
    } else if (*keep4).unk_1C as libc::c_int & 0x10 as libc::c_int != 0 {
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int |
                 (0x400 as libc::c_int | 0x10 as libc::c_int)) as s16;
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int |
                 (0x4 as libc::c_int | 0x2 as libc::c_int)) as s16;
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int & !(8 as libc::c_int)) as s16;
        if (*camera).timer as libc::c_int > 0 as libc::c_int {
            (*camera).timer -= 1
        }
    } else {
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int |
                 (0x400 as libc::c_int | 0x10 as libc::c_int)) as s16;
        if (*camera).unk_14C as libc::c_int & 8 as libc::c_int != 0 ||
               (*keep4).unk_1C as libc::c_int & 0x80 as libc::c_int != 0 {
            sCameraInterfaceFlags = 0 as libc::c_int;
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int |
                     (0x4 as libc::c_int | 0x2 as libc::c_int)) as s16;
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int & !(8 as libc::c_int)) as
                    s16;
            if ((*camera).prevCamDataIdx as libc::c_int) < 0 as libc::c_int {
                Camera_ChangeSettingFlags(camera, (*camera).prevSetting,
                                          2 as libc::c_int as s16);
            } else {
                Camera_ChangeDataIdx(camera, (*camera).prevCamDataIdx as s32);
                (*camera).prevCamDataIdx = -(1 as libc::c_int) as s16
            }
        }
    }
    spB8.yaw =
        Camera_LERPCeilS((*unk20).unk_0C, spA8.yaw, (*keep4).unk_14,
                         4 as libc::c_int as s16);
    spB8.pitch =
        Camera_LERPCeilS((*unk20).unk_0E, spA8.pitch, (*keep4).unk_14,
                         4 as libc::c_int as s16);
    Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut spB8);
    *eye = *eyeNext;
    Camera_BGCheck(camera, at, eye);
    (*camera).fov =
        Camera_LERPCeilF((*keep4).unk_18, (*camera).fov,
                         (*camera).fovUpdateRate, 1.0f32);
    (*camera).roll =
        Camera_LERPCeilS(0 as libc::c_int as s16, (*camera).roll, 0.5f32,
                         0xa as libc::c_int as s16);
    panic!("Reached end of non-void function without returning");
}
/* *
 * Talking in a pre-rendered room
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_KeepOn0(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye; // unused
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeTargetPosOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut eyeAtOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut keep0: *mut KeepOn0 =
        (*camera).paramData.as_mut_ptr() as *mut KeepOn0;
    let mut anim: *mut KeepOn0Anim = &mut (*keep0).anim;
    let mut pad: s32 = 0;
    let mut sceneCamData: *mut Vec3s = 0 as *mut Vec3s;
    let mut sceneCamRot: Vec3s = Vec3s{x: 0, y: 0, z: 0,};
    let mut fov: s16 = 0;
    (*camera).unk_14C =
        ((*camera).unk_14C as libc::c_int & !(0x10 as libc::c_int)) as s16;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let fresh120 = values;
        values = values.offset(1);
        (*keep0).fovScale =
            (*fresh120).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh121 = values;
        values = values.offset(1);
        (*keep0).yawScale =
            (*fresh121).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh122 = values;
        values = values.offset(1);
        (*keep0).timerInit = (*fresh122).val;
        let fresh123 = values;
        values = values.offset(1);
        (*keep0).interfaceFlags = (*fresh123).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    sceneCamData = Camera_GetCamBGData(camera);
    Camera_Vec3sToVec3f(eyeNext,
                        &mut *sceneCamData.offset(0 as libc::c_int as isize));
    *eye = *eyeNext;
    sceneCamRot = *sceneCamData.offset(1 as libc::c_int as isize);
    // suppresses set but unused warning
    fov = (*sceneCamData.offset(2 as libc::c_int as isize)).x;
    if fov as libc::c_int == -(1 as libc::c_int) {
        fov = 6000 as libc::c_int as s16
    }
    if (*camera).target.is_null() || (*(*camera).target).update.is_none() {
        if (*camera).target.is_null() {
            osSyncPrintf(b"\x1b[43;30mcamera: warning: talk: target is not valid, change normal camera\n\x1b[m\x00"
                             as *const u8 as *const libc::c_char);
        }
        (*camera).target = 0 as *mut Actor;
        Camera_ChangeMode(camera, CAM_MODE_NORMAL as libc::c_int as s16);
        return 1 as libc::c_int
    }
    Actor_GetFocus(&mut (*camera).targetPosRot, (*camera).target);
    OLib_Vec3fDiffToVecSphGeo(&mut eyeAtOffset, eye, at);
    OLib_Vec3fDiffToVecSphGeo(&mut eyeTargetPosOffset, eye,
                              &mut (*camera).targetPosRot.pos);
    sCameraInterfaceFlags = (*keep0).interfaceFlags as s32;
    if (*camera).animState as libc::c_int == 0 as libc::c_int {
        (*camera).animState += 1;
        (*camera).fov = fov as libc::c_int as libc::c_float * 0.01f32;
        (*camera).roll = 0 as libc::c_int as s16;
        (*camera).atLERPStepScale = 0.0f32;
        (*anim).animTimer = (*keep0).timerInit;
        (*anim).fovTarget = (*camera).fov - (*camera).fov * (*keep0).fovScale
    }
    if (*anim).animTimer as libc::c_int != 0 as libc::c_int {
        eyeAtOffset.yaw =
            (eyeAtOffset.yaw as libc::c_float +
                 ((eyeTargetPosOffset.yaw as libc::c_int -
                       eyeAtOffset.yaw as libc::c_int) as s16 as libc::c_int /
                      (*anim).animTimer as libc::c_int) as libc::c_float *
                     (*keep0).yawScale) as s16;
        Camera_Vec3fVecSphGeoAdd(at, eye, &mut eyeAtOffset);
        (*anim).animTimer -= 1
    } else {
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int |
                 (0x400 as libc::c_int | 0x10 as libc::c_int)) as s16
    }
    (*camera).fov =
        Camera_LERPCeilF((*anim).fovTarget, (*camera).fov, 0.5f32, 10.0f32);
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Fixed1(mut camera: *mut Camera) -> s32 {
    let mut fixd1: *mut Fixed1 =
        (*camera).paramData.as_mut_ptr() as *mut Fixed1;
    let mut anim: *mut Fixed1Anim = &mut (*fixd1).anim;
    let mut pad: s32 = 0;
    let mut eyeOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut eyeAtOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut pad2: s32 = 0;
    let mut adjustedPos: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut scenePosData: *mut Vec3s = 0 as *mut Vec3s;
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut playerHeight: f32_0 = 0.;
    playerHeight = Player_GetHeight((*camera).player);
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        scenePosData = Camera_GetCamBGData(camera);
        Camera_Vec3sToVec3f(&mut (*anim).eyePosRotTarget.pos,
                            &mut *scenePosData.offset(0 as libc::c_int as
                                                          isize));
        (*anim).eyePosRotTarget.rot =
            *scenePosData.offset(1 as libc::c_int as isize);
        (*anim).fov = (*scenePosData.offset(2 as libc::c_int as isize)).x;
        let fresh124 = values;
        values = values.offset(1);
        (*fixd1).unk_00 =
            (*fresh124).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight;
        let fresh125 = values;
        values = values.offset(1);
        (*fixd1).lerpStep =
            (*fresh125).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh126 = values;
        values = values.offset(1);
        (*fixd1).fov = (*fresh126).val as f32_0;
        let fresh127 = values;
        values = values.offset(1);
        (*fixd1).interfaceFlags = (*fresh127).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    if (*anim).fov as libc::c_int == -(1 as libc::c_int) {
        (*anim).fov = ((*fixd1).fov * 100.0f32) as s16
    } else if ((*anim).fov as libc::c_int) < 361 as libc::c_int {
        (*anim).fov = ((*anim).fov as libc::c_int * 100 as libc::c_int) as s16
    }
    sCameraInterfaceFlags = (*fixd1).interfaceFlags as s32;
    if (*camera).animState as libc::c_int == 0 as libc::c_int {
        (*camera).animState += 1;
        func_80043B60(camera);
        if (*anim).fov as libc::c_int != -(1 as libc::c_int) {
            (*fixd1).fov =
                (*anim).fov as libc::c_int as libc::c_float * 0.01f32
        }
    }
    OLib_Vec3fDiffToVecSphGeo(&mut eyeAtOffset, eye, at);
    Camera_LERPCeilVec3f(&mut (*anim).eyePosRotTarget.pos, eye, 0.1f32,
                         0.1f32, 0.2f32);
    adjustedPos = (*playerPosRot).pos;
    adjustedPos.y += playerHeight;
    (*camera).dist = OLib_Vec3fDist(&mut adjustedPos, eye);
    eyeOffset.r = (*camera).dist;
    eyeOffset.pitch =
        Camera_LERPCeilS(-((*anim).eyePosRotTarget.rot.x as libc::c_int) as
                             s16, eyeAtOffset.pitch, (*fixd1).lerpStep,
                         5 as libc::c_int as s16);
    eyeOffset.yaw =
        Camera_LERPCeilS((*anim).eyePosRotTarget.rot.y, eyeAtOffset.yaw,
                         (*fixd1).lerpStep, 5 as libc::c_int as s16);
    Camera_Vec3fVecSphGeoAdd(at, eye, &mut eyeOffset);
    (*camera).eyeNext = *eye;
    (*camera).fov =
        Camera_LERPCeilF((*fixd1).fov, (*camera).fov, (*fixd1).lerpStep,
                         0.01f32);
    (*camera).roll = 0 as libc::c_int as s16;
    (*camera).atLERPStepScale = 0.0f32;
    (*camera).posOffset.x = (*camera).at.x - (*playerPosRot).pos.x;
    (*camera).posOffset.y = (*camera).at.y - (*playerPosRot).pos.y;
    (*camera).posOffset.z = (*camera).at.z - (*playerPosRot).pos.z;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Fixed2(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut atTarget: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut posOffsetTarget: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut scenePosData: *mut Vec3s = 0 as *mut Vec3s;
    let mut fixd2: *mut Fixed2 =
        (*camera).paramData.as_mut_ptr() as *mut Fixed2;
    let mut initParams: *mut Fixed2InitParams = &mut (*fixd2).initParams;
    let mut pad: s32 = 0;
    let mut playerHeight: f32_0 = 0.;
    playerHeight = Player_GetHeight((*camera).player);
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let mut yNormal: f32_0 =
            1.0f32 +
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 -
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 * (68.0f32 / playerHeight);
        let fresh128 = values;
        values = values.offset(1);
        (*fixd2).yOffset =
            (*fresh128).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh129 = values;
        values = values.offset(1);
        (*fixd2).eyeStepScale =
            (*fresh129).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh130 = values;
        values = values.offset(1);
        (*fixd2).posStepScale =
            (*fresh130).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh131 = values;
        values = values.offset(1);
        (*fixd2).fov = (*fresh131).val as f32_0;
        let fresh132 = values;
        values = values.offset(1);
        (*fixd2).interfaceFlags = (*fresh132).val;
        (*initParams).fov = ((*fixd2).fov * 100.0f32) as s16;
        scenePosData = Camera_GetCamBGData(camera);
        if !scenePosData.is_null() {
            Camera_Vec3sToVec3f(&mut (*initParams).eye,
                                &mut *scenePosData.offset(0 as libc::c_int as
                                                              isize));
            if (*scenePosData.offset(2 as libc::c_int as isize)).x as
                   libc::c_int != -(1 as libc::c_int) {
                (*initParams).fov =
                    (*scenePosData.offset(2 as libc::c_int as isize)).x
            }
        } else { (*initParams).eye = *eye }
        if ((*initParams).fov as libc::c_int) < 361 as libc::c_int {
            (*initParams).fov =
                ((*initParams).fov as libc::c_int * 100 as libc::c_int) as s16
        }
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    sCameraInterfaceFlags = (*fixd2).interfaceFlags as s32;
    posOffsetTarget.x = 0.0f32;
    posOffsetTarget.y = (*fixd2).yOffset + playerHeight;
    posOffsetTarget.z = 0.0f32;
    Camera_LERPCeilVec3f(&mut posOffsetTarget, &mut (*camera).posOffset,
                         (*fixd2).posStepScale, (*fixd2).posStepScale,
                         0.1f32);
    atTarget.x = (*playerPosRot).pos.x + (*camera).posOffset.x;
    atTarget.y = (*playerPosRot).pos.y + (*camera).posOffset.y;
    atTarget.z = (*playerPosRot).pos.z + (*camera).posOffset.z;
    if (*camera).animState as libc::c_int == 0 as libc::c_int {
        (*camera).animState += 1;
        func_80043B60(camera);
        if (*fixd2).interfaceFlags as libc::c_int & 1 as libc::c_int == 0 {
            *eyeNext = (*initParams).eye;
            *eye = *eyeNext;
            (*camera).at = atTarget
        }
    }
    Camera_LERPCeilVec3f(&mut atTarget, &mut (*camera).at,
                         (*fixd2).posStepScale, (*fixd2).posStepScale,
                         10.0f32);
    Camera_LERPCeilVec3f(&mut (*initParams).eye, eyeNext,
                         (*fixd2).eyeStepScale, (*fixd2).eyeStepScale,
                         0.1f32);
    *eye = *eyeNext;
    (*camera).dist = OLib_Vec3fDist(at, eye);
    (*camera).roll = 0 as libc::c_int as s16;
    (*camera).xzSpeed = 0.0f32;
    (*camera).fov =
        (*initParams).fov as libc::c_int as libc::c_float * 0.01f32;
    (*camera).atLERPStepScale = Camera_ClampLERPScale(camera, 1.0f32);
    (*camera).posOffset.x = (*camera).at.x - (*playerPosRot).pos.x;
    (*camera).posOffset.y = (*camera).at.y - (*playerPosRot).pos.y;
    (*camera).posOffset.z = (*camera).at.z - (*playerPosRot).pos.z;
    return 1 as libc::c_int;
}
/* *
 * Camera's position is fixed, does not move, or rotate
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Fixed3(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut atSph: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut sceneCamData: *mut Vec3s = 0 as *mut Vec3s;
    let mut eyeAtOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut fixd3: *mut Fixed3 =
        (*camera).paramData.as_mut_ptr() as *mut Fixed3;
    let mut anim: *mut Fixed3Anim = &mut (*fixd3).anim;
    let mut pad: s32 = 0;
    sceneCamData = Camera_GetCamBGData(camera);
    OLib_Vec3fDiffToVecSphGeo(&mut eyeAtOffset, eye, at);
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let fresh133 = values;
        values = values.offset(1);
        (*fixd3).interfaceFlags = (*fresh133).val;
        Camera_Vec3sToVec3f(eyeNext,
                            &mut *sceneCamData.offset(0 as libc::c_int as
                                                          isize));
        *eye = *eyeNext;
        (*anim).rot = *sceneCamData.offset(1 as libc::c_int as isize);
        (*anim).fov = (*sceneCamData.offset(2 as libc::c_int as isize)).x;
        (*anim).jfifId = (*sceneCamData.offset(2 as libc::c_int as isize)).y;
        if (*anim).fov as libc::c_int == -(1 as libc::c_int) {
            (*anim).fov = 6000 as libc::c_int as s16
        }
        if (*anim).fov as libc::c_int <= 360 as libc::c_int {
            (*anim).fov =
                ((*anim).fov as libc::c_int * 100 as libc::c_int) as s16
        }
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    if (*camera).animState as libc::c_int == 0 as libc::c_int {
        (*anim).updDirTimer = 5 as libc::c_int as s16;
        (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 7 as libc::c_int) as usize]
            = (*anim).fov;
        (*camera).animState += 1
    }
    if (*sceneCamData.offset(2 as libc::c_int as isize)).y as libc::c_int !=
           (*anim).jfifId as libc::c_int {
        osSyncPrintf(b"camera: position change %d \n\x00" as *const u8 as
                         *const libc::c_char, (*anim).jfifId as libc::c_int);
        (*anim).jfifId = (*sceneCamData.offset(2 as libc::c_int as isize)).y;
        (*anim).updDirTimer = 5 as libc::c_int as s16
    }
    if (*anim).updDirTimer as libc::c_int > 0 as libc::c_int {
        (*anim).updDirTimer -= 1;
        sUpdateCameraDirection = 1 as libc::c_int
    } else { sUpdateCameraDirection = 0 as libc::c_int }
    atSph.r = 150.0f32;
    atSph.yaw = (*anim).rot.y;
    atSph.pitch = -((*anim).rot.x as libc::c_int) as s16;
    Camera_Vec3fVecSphGeoAdd(at, eye, &mut atSph);
    sCameraInterfaceFlags = (*fixd3).interfaceFlags as s32;
    (*anim).fov =
        (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 7 as libc::c_int) as
                              usize];
    (*camera).roll = 0 as libc::c_int as s16;
    (*camera).fov = (*anim).fov as libc::c_int as libc::c_float * 0.01f32;
    (*camera).atLERPStepScale = 0.0f32;
    return 1 as libc::c_int;
}
/* *
 * camera follow player, eye is in a fixed offset of the previous eye, and a value
 * specified in the scene.
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Fixed4(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut playerPosWithCamOffset: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut atTarget: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut posOffsetTarget: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut atEyeNextOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut atTargetEyeNextOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut camPosData: *mut Vec3s = 0 as *mut Vec3s;
    let mut posOffset: *mut Vec3f = &mut (*camera).posOffset;
    let mut fixed4: *mut Fixed4 =
        (*camera).paramData.as_mut_ptr() as *mut Fixed4;
    let mut anim: *mut Fixed4Anim = &mut (*fixed4).anim;
    let mut playerYOffset: f32_0 = 0.;
    playerYOffset = Player_GetHeight((*camera).player);
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let mut yNormal: f32_0 =
            1.0f32 +
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 -
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 * (68.0f32 / playerYOffset);
        let fresh134 = values;
        values = values.offset(1);
        (*fixed4).yOffset =
            (*fresh134).val as libc::c_int as libc::c_float * 0.01f32 *
                playerYOffset * yNormal;
        let fresh135 = values;
        values = values.offset(1);
        (*fixed4).speedToEyePos =
            (*fresh135).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh136 = values;
        values = values.offset(1);
        (*fixed4).followSpeed =
            (*fresh136).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh137 = values;
        values = values.offset(1);
        (*fixed4).fov = (*fresh137).val as f32_0;
        let fresh138 = values;
        values = values.offset(1);
        (*fixed4).interfaceFlags = (*fresh138).val;
        camPosData = Camera_GetCamBGData(camera);
        if !camPosData.is_null() {
            Camera_Vec3sToVec3f(&mut (*anim).eyeTarget,
                                &mut *camPosData.offset(0 as libc::c_int as
                                                            isize));
        } else { (*anim).eyeTarget = *eye }
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    sCameraInterfaceFlags = (*fixed4).interfaceFlags as s32;
    if (*camera).animState as libc::c_int == 0 as libc::c_int {
        (*camera).animState += 1;
        if (*fixed4).interfaceFlags as libc::c_int & 4 as libc::c_int == 0 {
            func_80043B60(camera);
        }
        (*anim).followSpeed = (*fixed4).followSpeed
    }
    (*eyeNext).x =
        (*eyeNext).x +
            ((*anim).eyeTarget.x - (*eyeNext).x) * (*fixed4).speedToEyePos;
    (*eyeNext).y =
        (*eyeNext).y +
            ((*anim).eyeTarget.y - (*eyeNext).y) * (*fixed4).speedToEyePos;
    (*eyeNext).z =
        (*eyeNext).z +
            ((*anim).eyeTarget.z - (*eyeNext).z) * (*fixed4).speedToEyePos;
    *eye = *eyeNext;
    posOffsetTarget.x = 0.0f32;
    posOffsetTarget.y = (*fixed4).yOffset + playerYOffset;
    posOffsetTarget.z = 0.0f32;
    Camera_LERPCeilVec3f(&mut posOffsetTarget, &mut (*camera).posOffset,
                         0.1f32, 0.1f32, 0.1f32);
    playerPosWithCamOffset.x = (*playerPosRot).pos.x + (*camera).posOffset.x;
    playerPosWithCamOffset.y = (*playerPosRot).pos.y + (*camera).posOffset.y;
    playerPosWithCamOffset.z = (*playerPosRot).pos.z + (*camera).posOffset.z;
    atTarget.x = (*at).x + (playerPosWithCamOffset.x - (*at).x) * 0.5f32;
    atTarget.y = (*at).y + (playerPosWithCamOffset.y - (*at).y) * 0.5f32;
    atTarget.z = (*at).z + (playerPosWithCamOffset.z - (*at).z) * 0.5f32;
    OLib_Vec3fDiffToVecSphGeo(&mut atEyeNextOffset, eyeNext, at);
    OLib_Vec3fDiffToVecSphGeo(&mut atTargetEyeNextOffset, eyeNext,
                              &mut atTarget);
    atEyeNextOffset.r +=
        (atTargetEyeNextOffset.r - atEyeNextOffset.r) * (*anim).followSpeed;
    atEyeNextOffset.pitch =
        Camera_LERPCeilS(atTargetEyeNextOffset.pitch, atEyeNextOffset.pitch,
                         (*anim).followSpeed * (*camera).speedRatio,
                         0xa as libc::c_int as s16);
    atEyeNextOffset.yaw =
        Camera_LERPCeilS(atTargetEyeNextOffset.yaw, atEyeNextOffset.yaw,
                         (*anim).followSpeed * (*camera).speedRatio,
                         0xa as libc::c_int as s16);
    Camera_Vec3fVecSphGeoAdd(at, eyeNext, &mut atEyeNextOffset);
    (*camera).dist = OLib_Vec3fDist(at, eye);
    (*camera).roll = 0 as libc::c_int as s16;
    (*camera).fov = (*fixed4).fov;
    (*camera).atLERPStepScale = Camera_ClampLERPScale(camera, 1.0f32);
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Fixed0(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Subj1(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Subj2(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
/* *
 * First person view
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Subj3(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut sp98: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut sp8C: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut sp84: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut sp7C: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut tsph: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut sp60: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut sp58: f32_0 = 0.;
    let mut temp_f0_3: f32_0 = 0.;
    let mut sp52: s16 = 0;
    let mut sp50: s16 = 0;
    let mut subj3: *mut Subj3 =
        (*camera).paramData.as_mut_ptr() as *mut Subj3;
    let mut anim: *mut Subj3Anim = &mut (*subj3).anim;
    let mut values: *mut CameraModeValue = 0 as *mut CameraModeValue;
    let mut pad2: *mut Vec3f = 0 as *mut Vec3f;
    let mut playerHeight: f32_0 = 0.;
    Actor_GetFocus(&mut sp60, &mut (*(*camera).player).actor);
    playerHeight = Player_GetHeight((*camera).player);
    if (*(*camera).globalCtx).view.unk_124 == 0 as libc::c_int {
        (*(*camera).globalCtx).view.unk_124 =
            (*camera).thisIdx as libc::c_int | 0x50 as libc::c_int;
        return 1 as libc::c_int
    }
    func_80043ABC(camera);
    Camera_CopyPREGToModeValues(camera);
    values =
        (*sCameraSettings[(*camera).setting as
                              usize].cameraModes.offset((*camera).mode as
                                                            isize)).values;
    let fresh139 = values;
    values = values.offset(1);
    (*subj3).eyeNextYOffset =
        (*fresh139).val as libc::c_int as libc::c_float * 0.01f32 *
            playerHeight;
    let fresh140 = values;
    values = values.offset(1);
    (*subj3).eyeDist = (*fresh140).val as f32_0;
    let fresh141 = values;
    values = values.offset(1);
    (*subj3).eyeNextDist = (*fresh141).val as f32_0;
    let fresh142 = values;
    values = values.offset(1);
    (*subj3).unk_0C = (*fresh142).val as f32_0;
    let fresh143 = values;
    values = values.offset(1);
    (*subj3).atOffset.x =
        (*fresh143).val as libc::c_int as libc::c_float * 0.1f32;
    let fresh144 = values;
    values = values.offset(1);
    (*subj3).atOffset.y =
        (*fresh144).val as libc::c_int as libc::c_float * 0.1f32;
    let fresh145 = values;
    values = values.offset(1);
    (*subj3).atOffset.z =
        (*fresh145).val as libc::c_int as libc::c_float * 0.1f32;
    let fresh146 = values;
    values = values.offset(1);
    (*subj3).fovTarget = (*fresh146).val as f32_0;
    let fresh147 = values;
    values = values.offset(1);
    (*subj3).interfaceFlags = (*fresh147).val;
    sp84.r = (*subj3).eyeNextDist;
    sp84.yaw = (sp60.rot.y as libc::c_int - 0x7fff as libc::c_int) as s16;
    sp84.pitch = sp60.rot.x;
    sp98 = sp60.pos;
    sp98.y += (*subj3).eyeNextYOffset;
    Camera_Vec3fVecSphGeoAdd(&mut sp8C, &mut sp98, &mut sp84);
    OLib_Vec3fDiffToVecSphGeo(&mut sp7C, at, eye);
    sCameraInterfaceFlags = (*subj3).interfaceFlags as s32;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int {
        (*anim).r = sp7C.r;
        (*anim).yaw = sp7C.yaw;
        (*anim).pitch = sp7C.pitch;
        (*anim).animTimer =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 23 as libc::c_int) as
                                  usize];
        (*camera).dist = (*subj3).eyeNextDist;
        (*camera).animState += 1;
        (*camera).rUpdateRateInv = 1.0f32;
        (*camera).dist = (*subj3).eyeNextDist
    }
    tsph.r = (*anim).r;
    tsph.yaw = (*anim).yaw;
    tsph.pitch = (*anim).pitch;
    if (*anim).animTimer as libc::c_int != 0 as libc::c_int {
        temp_f0_3 =
            1.0f32 / (*anim).animTimer as libc::c_int as libc::c_float;
        pad2 = at;
        (*at).x = (*at).x + (sp98.x - (*pad2).x) * temp_f0_3;
        (*at).y = (*at).y + (sp98.y - (*pad2).y) * temp_f0_3;
        (*at).z = (*at).z + (sp98.z - (*pad2).z) * temp_f0_3;
        temp_f0_3 =
            1.0f32 /
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 23 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float;
        sp58 = (tsph.r - sp84.r) * temp_f0_3;
        sp52 =
            ((tsph.yaw as libc::c_int - sp84.yaw as libc::c_int) as s16 as
                 libc::c_int as libc::c_float * temp_f0_3) as s16;
        sp50 =
            ((tsph.pitch as libc::c_int - sp84.pitch as libc::c_int) as s16 as
                 libc::c_int as libc::c_float * temp_f0_3) as s16;
        sp7C.r =
            Camera_LERPCeilF(sp84.r +
                                 sp58 *
                                     (*anim).animTimer as libc::c_int as
                                         libc::c_float, sp7C.r,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    28 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32, 1.0f32);
        sp7C.yaw =
            Camera_LERPCeilS((sp84.yaw as libc::c_int +
                                  sp52 as libc::c_int *
                                      (*anim).animTimer as libc::c_int) as
                                 s16, sp7C.yaw,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    28 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32,
                             0xa as libc::c_int as s16);
        sp7C.pitch =
            Camera_LERPCeilS((sp84.pitch as libc::c_int +
                                  sp50 as libc::c_int *
                                      (*anim).animTimer as libc::c_int) as
                                 s16, sp7C.pitch,
                             (*gGameInfo).data[(2 as libc::c_int *
                                                    6 as libc::c_int *
                                                    16 as libc::c_int +
                                                    28 as libc::c_int) as
                                                   usize] as libc::c_int as
                                 libc::c_float * 0.01f32,
                             0xa as libc::c_int as s16);
        Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut sp7C);
        *eye = *eyeNext;
        (*anim).animTimer -= 1;
        if (*(*camera).globalCtx).envCtx.skyboxDisabled == 0 {
            Camera_BGCheck(camera, at, eye);
        } else { func_80044340(camera, at, eye); }
    } else {
        sp58 = Math_SinS(-(sp60.rot.x as libc::c_int) as s16);
        temp_f0_3 = Math_CosS(-(sp60.rot.x as libc::c_int) as s16);
        sp98.x = (*subj3).atOffset.x;
        sp98.y = (*subj3).atOffset.y * temp_f0_3 - (*subj3).atOffset.z * sp58;
        sp98.z = (*subj3).atOffset.y * sp58 + (*subj3).atOffset.z * temp_f0_3;
        sp58 =
            Math_SinS((sp60.rot.y as libc::c_int - 0x7fff as libc::c_int) as
                          s16);
        temp_f0_3 =
            Math_CosS((sp60.rot.y as libc::c_int - 0x7fff as libc::c_int) as
                          s16);
        (*subj3).atOffset.x = sp98.z * sp58 + sp98.x * temp_f0_3;
        (*subj3).atOffset.y = sp98.y;
        (*subj3).atOffset.z = sp98.z * temp_f0_3 - sp98.x * sp58;
        (*at).x = (*subj3).atOffset.x + sp60.pos.x;
        (*at).y = (*subj3).atOffset.y + sp60.pos.y;
        (*at).z = (*subj3).atOffset.z + sp60.pos.z;
        sp7C.r = (*subj3).eyeNextDist;
        sp7C.yaw = (sp60.rot.y as libc::c_int - 0x7fff as libc::c_int) as s16;
        sp7C.pitch = sp60.rot.x;
        Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut sp7C);
        sp7C.r = (*subj3).eyeDist;
        Camera_Vec3fVecSphGeoAdd(eye, at, &mut sp7C);
    }
    (*camera).posOffset.x = (*camera).at.x - (*playerPosRot).pos.x;
    (*camera).posOffset.y = (*camera).at.y - (*playerPosRot).pos.y;
    (*camera).posOffset.z = (*camera).at.z - (*playerPosRot).pos.z;
    (*camera).fov =
        Camera_LERPCeilF((*subj3).fovTarget, (*camera).fov, 0.25f32, 1.0f32);
    (*camera).roll = 0 as libc::c_int as s16;
    (*camera).atLERPStepScale = 0.0f32;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Subj4(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut spAA: u16_0 = 0;
    let mut spA4: *mut Vec3s = 0 as *mut Vec3s;
    let mut sp98: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut sp8C: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut sp88: f32_0 = 0.;
    let mut pad2: s16 = 0;
    let mut temp_f16: f32_0 = 0.;
    let mut sp6C: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut sp64: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut sp5C: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut temp_a0: s16 = 0;
    let mut tx: f32_0 = 0.;
    let mut player: *mut Player = 0 as *mut Player;
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut subj4: *mut Subj4 =
        (*camera).paramData.as_mut_ptr() as *mut Subj4;
    let mut anim: *mut Subj4Anim = &mut (*subj4).anim;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let fresh148 = values;
        values = values.offset(1);
        (*subj4).interfaceFlags = (*fresh148).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    if (*(*camera).globalCtx).view.unk_124 == 0 as libc::c_int {
        (*(*camera).globalCtx).view.unk_124 =
            (*camera).thisIdx as libc::c_int | 0x50 as libc::c_int;
        (*anim).unk_24 = (*camera).xzSpeed;
        return 1 as libc::c_int
    }
    Actor_GetWorldPosShapeRot(&mut sp6C, &mut (*(*camera).player).actor);
    OLib_Vec3fDiffToVecSphGeo(&mut sp5C, at, eye);
    sCameraInterfaceFlags = (*subj4).interfaceFlags as s32;
    if (*camera).animState as libc::c_int == 0 as libc::c_int {
        spA4 = Camera_GetCamBgDataUnderPlayer(camera, &mut spAA);
        Camera_Vec3sToVec3f(&mut (*anim).unk_00.a,
                            &mut *spA4.offset(1 as libc::c_int as isize));
        Camera_Vec3sToVec3f(&mut sp98,
                            &mut *spA4.offset((spAA as libc::c_int -
                                                   2 as libc::c_int) as
                                                  isize));
        sp64.r = 10.0f32;
        // 0x238C ~ 50 degrees
        sp64.pitch = 0x238c as libc::c_int as s16;
        sp64.yaw = Camera_XZAngle(&mut sp98, &mut (*anim).unk_00.a);
        sp88 =
            OLib_Vec3fDist(&mut (*playerPosRot).pos, &mut (*anim).unk_00.a);
        if OLib_Vec3fDist(&mut (*playerPosRot).pos, &mut sp98) < sp88 {
            (*anim).unk_00.b.x = (*anim).unk_00.a.x - sp98.x;
            (*anim).unk_00.b.y = (*anim).unk_00.a.y - sp98.y;
            (*anim).unk_00.b.z = (*anim).unk_00.a.z - sp98.z;
            (*anim).unk_00.a = sp98
        } else {
            (*anim).unk_00.b.x = sp98.x - (*anim).unk_00.a.x;
            (*anim).unk_00.b.y = sp98.y - (*anim).unk_00.a.y;
            (*anim).unk_00.b.z = sp98.z - (*anim).unk_00.a.z;
            sp64.yaw =
                (sp64.yaw as libc::c_int - 0x7fff as libc::c_int) as s16
        }
        (*anim).unk_30 = sp64.yaw;
        (*anim).unk_32 = 0xa as libc::c_int as s16;
        (*anim).unk_2C = 0 as libc::c_int as s16;
        (*anim).unk_2E = 0 as libc::c_int as s16;
        (*anim).unk_28 = 0.0f32;
        (*camera).animState += 1
    }
    if (*anim).unk_32 as libc::c_int != 0 as libc::c_int {
        sp64.r = 10.0f32;
        sp64.pitch = 0x238c as libc::c_int as s16;
        sp64.yaw = (*anim).unk_30;
        Camera_Vec3fVecSphGeoAdd(&mut sp8C, &mut sp6C.pos, &mut sp64);
        sp88 = (*anim).unk_32 as libc::c_int as libc::c_float + 1.0f32;
        (*at).x += (sp8C.x - (*at).x) / sp88;
        (*at).y += (sp8C.y - (*at).y) / sp88;
        (*at).z += (sp8C.z - (*at).z) / sp88;
        sp5C.r -= sp5C.r / sp88;
        sp5C.yaw =
            (sp5C.yaw as libc::c_int +
                 ((sp6C.rot.y as libc::c_int - 0x7fff as libc::c_int) as s16
                      as libc::c_int - sp5C.yaw as libc::c_int) as s16 as
                     libc::c_int / (*anim).unk_32 as libc::c_int) as s16;
        sp5C.pitch =
            (sp5C.pitch as libc::c_int +
                 (sp6C.rot.x as libc::c_int - sp5C.pitch as libc::c_int) as
                     s16 as libc::c_int / (*anim).unk_32 as libc::c_int) as
                s16;
        Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut sp5C);
        *eye = *eyeNext;
        (*anim).unk_32 -= 1;
        return 0 as libc::c_int
    } else { if (*anim).unk_24 < 0.5f32 { return 0 as libc::c_int } }
    Actor_GetWorldPosShapeRot(&mut sp6C, &mut (*(*camera).player).actor);
    Math3D_LineClosestToPoint(&mut (*anim).unk_00, &mut sp6C.pos, eyeNext);
    (*at).x = (*eyeNext).x + (*anim).unk_00.b.x;
    (*at).y = (*eyeNext).y + (*anim).unk_00.b.y;
    (*at).z = (*eyeNext).z + (*anim).unk_00.b.z;
    *eye = *eyeNext;
    sp64.yaw = (*anim).unk_30;
    sp64.r = 5.0f32;
    sp64.pitch = 0x238c as libc::c_int as s16;
    Camera_Vec3fVecSphGeoAdd(&mut sp98, eyeNext, &mut sp64);
    (*anim).unk_2C =
        ((*anim).unk_2C as libc::c_int + 0xbb8 as libc::c_int) as s16;
    temp_f16 = Math_CosS((*anim).unk_2C);
    (*eye).x += (sp98.x - (*eye).x) * fabsf(temp_f16);
    (*eye).y += (sp98.y - (*eye).y) * fabsf(temp_f16);
    (*eye).z += (sp98.z - (*eye).z) * fabsf(temp_f16);
    if (*anim).unk_28 < temp_f16 && (*anim).unk_2E == 0 {
        player = (*camera).player;
        (*anim).unk_2E = 1 as libc::c_int as s16;
        func_800F4010(&mut (*player).actor.projectedPos,
                      ((*player).unk_89E as libc::c_int +
                           0x8b0 as libc::c_int) as u16_0, 4.0f32);
    } else if (*anim).unk_28 > temp_f16 {
        (*anim).unk_2E = 0 as libc::c_int as s16
    }
    (*anim).unk_28 = temp_f16;
    (*(*camera).player).actor.world.pos = *eyeNext;
    (*(*camera).player).actor.world.pos.y = (*camera).playerGroundY;
    (*(*camera).player).actor.shape.rot.y = sp64.yaw;
    temp_f16 = 240.0f32 * temp_f16 * ((*anim).unk_24 * 0.416667f32);
    temp_a0 =
        (temp_f16 + (*anim).unk_30 as libc::c_int as libc::c_float) as s16;
    (*at).x = (*eye).x + Math_SinS(temp_a0) * 10.0f32;
    (*at).y = (*eye).y;
    (*at).z = (*eye).z + Math_CosS(temp_a0) * 10.0f32;
    (*camera).roll =
        Camera_LERPCeilS(0 as libc::c_int as s16, (*camera).roll, 0.5f32,
                         0xa as libc::c_int as s16);
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Subj0(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Data0(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Data1(mut camera: *mut Camera) -> s32 {
    osSyncPrintf(b"chau!chau!\n\x00" as *const u8 as *const libc::c_char);
    return Camera_Normal1(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Data2(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Data3(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Data4(mut camera: *mut Camera) -> s32 {
    let mut pad2: [s32; 2] = [0; 2];
    let mut data4: *mut Data4 =
        (*camera).paramData.as_mut_ptr() as *mut Data4;
    let mut eyeAtOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut atOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut eyeNextAtOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut yNormal: f32_0 = 0.;
    let mut fov: s16 = 0;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut sceneCamData: *mut Vec3s = 0 as *mut Vec3s;
    let mut lookAt: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut values: *mut CameraModeValue = 0 as *mut CameraModeValue;
    let mut initParams: *mut Data4InitParams = &mut (*data4).initParams;
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut playerHeight: f32_0 = 0.;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut pad: s32 = 0;
    playerHeight = Player_GetHeight((*camera).player);
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        values =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        yNormal =
            1.0f32 +
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 -
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 * (68.0f32 / playerHeight);
        let fresh149 = values;
        values = values.offset(1);
        (*data4).yOffset =
            (*fresh149).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh150 = values;
        values = values.offset(1);
        (*data4).fov = (*fresh150).val as f32_0;
        let fresh151 = values;
        values = values.offset(1);
        (*data4).interfaceFlags = (*fresh151).val;
        sceneCamData = Camera_GetCamBGData(camera);
        Camera_Vec3sToVec3f(&mut (*initParams).eyePosRot.pos,
                            &mut *sceneCamData.offset(0 as libc::c_int as
                                                          isize));
        (*initParams).eyePosRot.rot =
            *sceneCamData.offset(1 as libc::c_int as isize);
        fov = (*sceneCamData.offset(2 as libc::c_int as isize)).x;
        (*initParams).fov = fov;
        if fov as libc::c_int != -(1 as libc::c_int) {
            (*data4).fov =
                if ((*initParams).fov as libc::c_int) < 361 as libc::c_int {
                    (*initParams).fov as libc::c_int as libc::c_float
                } else {
                    ((*initParams).fov as libc::c_int as libc::c_float) *
                        0.01f32
                }
        }
        (*initParams).jfifId =
            (*sceneCamData.offset(2 as libc::c_int as isize)).y;
        *eye = (*initParams).eyePosRot.pos
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    sCameraInterfaceFlags = (*data4).interfaceFlags as s32;
    if (*camera).animState as libc::c_int == 0 as libc::c_int {
        (*camera).animState += 1;
        func_80043B60(camera);
    }
    OLib_Vec3fDiffToVecSphGeo(&mut eyeNextAtOffset, at, eyeNext);
    Camera_CalcAtDefault(camera, &mut eyeNextAtOffset, (*data4).yOffset,
                         0 as libc::c_int as s16);
    OLib_Vec3fDiffToVecSphGeo(&mut eyeAtOffset, eye, at);
    atOffset.r = eyeAtOffset.r;
    atOffset.yaw =
        if (*initParams).jfifId as libc::c_int & 1 as libc::c_int != 0 {
            (((*camera).data2 as libc::c_int as libc::c_float * 182.04167f32 +
                  0.5f32) as s16 as libc::c_int) +
                (*initParams).eyePosRot.rot.y as libc::c_int
        } else { eyeAtOffset.yaw as libc::c_int } as s16;
    atOffset.pitch =
        if (*initParams).jfifId as libc::c_int & 2 as libc::c_int != 0 {
            (((*camera).data3 as libc::c_int as libc::c_float * 182.04167f32 +
                  0.5f32) as s16 as libc::c_int) +
                (*initParams).eyePosRot.rot.x as libc::c_int
        } else { eyeAtOffset.pitch as libc::c_int } as s16;
    Camera_Vec3fVecSphGeoAdd(at, eye, &mut atOffset);
    lookAt = (*camera).playerPosRot.pos;
    lookAt.y += playerHeight;
    (*camera).dist = OLib_Vec3fDist(&mut lookAt, eye);
    (*camera).roll = 0 as libc::c_int as s16;
    (*camera).xzSpeed = 0.0f32;
    (*camera).fov = (*data4).fov;
    (*camera).atLERPStepScale = 0 as libc::c_int as f32_0;
    return 1 as libc::c_int;
}
/* *
 * Hanging off of a ledge
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Unique1(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye; // unused
    let mut at: *mut Vec3f = &mut (*camera).at; // unused.
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut playerBodyPart0: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut phiTarget: s16 = 0;
    let mut sp8C: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut unk908PlayerPosOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut eyeAtOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut eyeNextAtOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut playerhead: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut uniq1: *mut Unique1 =
        (*camera).paramData.as_mut_ptr() as *mut Unique1;
    let mut anim: *mut Unique1Anim = &mut (*uniq1).anim;
    let mut pad: s32 = 0;
    let mut playerHeight: f32_0 = 0.;
    let mut pad2: s32 = 0;
    playerHeight = Player_GetHeight((*camera).player);
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let mut yNormal: f32_0 =
            1.0f32 +
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 -
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 * (68.0f32 / playerHeight);
        let fresh152 = values;
        values = values.offset(1);
        (*uniq1).yOffset =
            (*fresh152).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh153 = values;
        values = values.offset(1);
        (*uniq1).distMin =
            (*fresh153).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh154 = values;
        values = values.offset(1);
        (*uniq1).distMax =
            (*fresh154).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh155 = values;
        values = values.offset(1);
        (*uniq1).pitchTarget =
            ((*fresh155).val as libc::c_int as libc::c_float * 182.04167f32 +
                 0.5f32) as s16;
        let fresh156 = values;
        values = values.offset(1);
        (*uniq1).fovTarget = (*fresh156).val as f32_0;
        let fresh157 = values;
        values = values.offset(1);
        (*uniq1).atLERPScaleMax =
            (*fresh157).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh158 = values;
        values = values.offset(1);
        (*uniq1).interfaceFlags = (*fresh158).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           as libc::c_int != 0 as libc::c_int {
        Camera_CopyPREGToModeValues(camera);
    }
    sUpdateCameraDirection = 1 as libc::c_int;
    OLib_Vec3fDiffToVecSphGeo(&mut eyeAtOffset, at, eye);
    OLib_Vec3fDiffToVecSphGeo(&mut eyeNextAtOffset, at, eyeNext);
    sCameraInterfaceFlags = (*uniq1).interfaceFlags as s32;
    if (*camera).animState as libc::c_int == 0 as libc::c_int {
        (*camera).posOffset.y =
            (*camera).posOffset.y - (*camera).playerPosDelta.y;
        (*anim).yawTarget = eyeNextAtOffset.yaw;
        (*anim).unk_00 = 0.0f32;
        playerBodyPart0 =
            (*(*camera).player).bodyPartsPos[0 as libc::c_int as usize];
        OLib_Vec3fDiffToVecSphGeo(&mut unk908PlayerPosOffset,
                                  &mut (*playerPosRot).pos,
                                  &mut playerBodyPart0);
        (*anim).timer =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 23 as libc::c_int) as
                                  usize];
        (*anim).yawTargetAdj =
            if (if (unk908PlayerPosOffset.yaw as libc::c_int -
                        eyeAtOffset.yaw as libc::c_int) as s16 as libc::c_int
                       >= 0 as libc::c_int {
                    (unk908PlayerPosOffset.yaw as libc::c_int -
                         eyeAtOffset.yaw as libc::c_int) as s16 as libc::c_int
                } else {
                    -((unk908PlayerPosOffset.yaw as libc::c_int -
                           eyeAtOffset.yaw as libc::c_int) as s16 as
                          libc::c_int)
                }) < 0x3a98 as libc::c_int {
                0 as libc::c_int
            } else {
                ((unk908PlayerPosOffset.yaw as libc::c_int -
                      eyeAtOffset.yaw as libc::c_int) as s16 as libc::c_int /
                     (*anim).timer as libc::c_int / 4 as libc::c_int) *
                    3 as libc::c_int
            } as s16;
        (*camera).animState += 1
    }
    Actor_GetFocus(&mut playerhead, &mut (*(*camera).player).actor);
    (*camera).yawUpdateRateInv =
        Camera_LERPCeilF(100.0f32, (*camera).yawUpdateRateInv,
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                25 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32,
                         0.1f32);
    (*camera).pitchUpdateRateInv =
        Camera_LERPCeilF(100.0f32, (*camera).pitchUpdateRateInv,
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                25 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32,
                         0.1f32);
    (*camera).xzOffsetUpdateRate =
        Camera_LERPCeilF(0.005f32, (*camera).xzOffsetUpdateRate,
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                25 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32,
                         0.01f32);
    (*camera).yOffsetUpdateRate =
        Camera_LERPCeilF(0.01f32, (*camera).yOffsetUpdateRate,
                         (*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                26 as libc::c_int) as usize]
                             as libc::c_int as libc::c_float * 0.01f32,
                         0.01f32);
    (*camera).fovUpdateRate =
        Camera_LERPCeilF((*gGameInfo).data[(2 as libc::c_int *
                                                6 as libc::c_int *
                                                16 as libc::c_int +
                                                4 as libc::c_int) as usize] as
                             libc::c_int as libc::c_float * 0.01f32,
                         (*camera).fovUpdateRate, 0.05f32, 0.1f32);
    Camera_CalcAtDefault(camera, &mut eyeNextAtOffset, (*uniq1).yOffset,
                         1 as libc::c_int as s16);
    OLib_Vec3fDiffToVecSphGeo(&mut sp8C, at, eyeNext);
    (*camera).dist =
        Camera_LERPClampDist(camera, sp8C.r, (*uniq1).distMin,
                             (*uniq1).distMax);
    phiTarget = (*uniq1).pitchTarget;
    sp8C.pitch =
        Camera_LERPCeilS(phiTarget, eyeNextAtOffset.pitch,
                         1.0f32 / (*camera).pitchUpdateRateInv,
                         0xa as libc::c_int as s16);
    if sp8C.pitch as libc::c_int >
           (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 5 as libc::c_int) as
                                 usize] as libc::c_int {
        sp8C.pitch =
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 5 as libc::c_int) as
                                  usize]
    }
    if (sp8C.pitch as libc::c_int) <
           -((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                    16 as libc::c_int + 5 as libc::c_int) as
                                   usize] as libc::c_int) {
        sp8C.pitch =
            -((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                     16 as libc::c_int + 5 as libc::c_int) as
                                    usize] as libc::c_int) as s16
    }
    if (*anim).timer as libc::c_int != 0 as libc::c_int {
        (*anim).yawTarget =
            ((*anim).yawTarget as libc::c_int +
                 (*anim).yawTargetAdj as libc::c_int) as s16;
        (*anim).timer -= 1
    }
    sp8C.yaw =
        Camera_LERPFloorS((*anim).yawTarget, eyeNextAtOffset.yaw, 0.5f32,
                          0x2710 as libc::c_int as s16);
    Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut sp8C);
    *eye = *eyeNext;
    Camera_BGCheck(camera, at, eye);
    (*camera).fov =
        Camera_LERPCeilF((*uniq1).fovTarget, (*camera).fov,
                         (*camera).fovUpdateRate, 1.0f32);
    (*camera).roll = 0 as libc::c_int as s16;
    (*camera).atLERPStepScale =
        Camera_ClampLERPScale(camera, (*uniq1).atLERPScaleMax);
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Unique2(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut playerPos: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut eyeOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut eyeAtOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut pad: s32 = 0;
    let mut lerpRateFactor: f32_0 = 0.;
    let mut uniq2: *mut Unique2 =
        (*camera).paramData.as_mut_ptr() as *mut Unique2;
    let mut unk10: *mut Unique2Unk10 = &mut (*uniq2).unk_10;
    let mut pad2: s32 = 0;
    let mut playerHeight: f32_0 = 0.;
    playerHeight = Player_GetHeight((*camera).player);
    OLib_Vec3fDiffToVecSphGeo(&mut eyeAtOffset, at, eye);
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let mut yNormal: f32_0 =
            1.0f32 +
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 -
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 * (68.0f32 / playerHeight);
        let fresh159 = values;
        values = values.offset(1);
        (*uniq2).yOffset =
            (*fresh159).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh160 = values;
        values = values.offset(1);
        (*uniq2).distTarget = (*fresh160).val as f32_0;
        let fresh161 = values;
        values = values.offset(1);
        (*uniq2).fovTarget = (*fresh161).val as f32_0;
        let fresh162 = values;
        values = values.offset(1);
        (*uniq2).interfaceFlags = (*fresh162).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    sCameraInterfaceFlags = (*uniq2).interfaceFlags as s32;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*unk10).unk_04 as libc::c_int !=
               (*uniq2).interfaceFlags as libc::c_int {
        (*unk10).unk_04 = (*uniq2).interfaceFlags
    }
    if (*camera).animState as libc::c_int == 0 as libc::c_int {
        (*camera).animState = 1 as libc::c_int as s16;
        func_80043B60(camera);
        (*unk10).unk_00 = 200.0f32;
        if (*uniq2).interfaceFlags as libc::c_int & 0x10 as libc::c_int != 0 {
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int & !(4 as libc::c_int)) as
                    s16
        }
    }
    playerPos = (*camera).playerPosRot.pos;
    lerpRateFactor =
        if (*uniq2).interfaceFlags as libc::c_int & 1 as libc::c_int != 0 {
            1.0f32
        } else { (*camera).speedRatio };
    (*at).x = (*at).x + (playerPos.x - (*at).x) * lerpRateFactor * 0.6f32;
    (*at).y =
        (*at).y +
            (playerPos.y + playerHeight + (*uniq2).yOffset - (*at).y) *
                0.4f32;
    (*at).z = (*at).z + (playerPos.z - (*at).z) * lerpRateFactor * 0.6f32;
    (*unk10).unk_00 = (*unk10).unk_00 + (2.0f32 - (*unk10).unk_00) * 0.05f32;
    if (*uniq2).interfaceFlags as libc::c_int & 1 as libc::c_int != 0 {
        OLib_Vec3fDiffToVecSphGeo(&mut eyeOffset, at, eyeNext);
        eyeOffset.r = (*uniq2).distTarget;
        Camera_Vec3fVecSphGeoAdd(&mut playerPos, at, &mut eyeOffset);
        Camera_LERPCeilVec3f(&mut playerPos, eye, 0.25f32, 0.25f32, 0.2f32);
    } else if (*uniq2).interfaceFlags as libc::c_int & 2 as libc::c_int != 0 {
        if OLib_Vec3fDistXZ(at, eyeNext) < (*uniq2).distTarget {
            OLib_Vec3fDiffToVecSphGeo(&mut eyeOffset, at, eyeNext);
            eyeOffset.yaw =
                Camera_LERPCeilS(eyeOffset.yaw, eyeAtOffset.yaw, 0.1f32,
                                 0xa as libc::c_int as s16);
            eyeOffset.r = (*uniq2).distTarget;
            eyeOffset.pitch = 0 as libc::c_int as s16;
            Camera_Vec3fVecSphGeoAdd(eye, at, &mut eyeOffset);
            (*eye).y = (*eyeNext).y
        } else {
            Camera_LERPCeilVec3f(eyeNext, eye, 0.25f32, 0.25f32, 0.2f32);
        }
    }
    Camera_BGCheck(camera, at, eye);
    (*camera).dist = OLib_Vec3fDist(at, eye);
    (*camera).roll = 0 as libc::c_int as s16;
    (*camera).fov =
        Camera_LERPCeilF((*uniq2).fovTarget, (*camera).fov, 0.2f32, 0.1f32);
    (*camera).atLERPStepScale = Camera_ClampLERPScale(camera, 1.0f32);
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Unique3(mut camera: *mut Camera) -> s32 {
    let mut sp60: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut playerHeight: f32_0 = 0.;
    let mut uniq3: *mut Unique3 =
        (*camera).paramData.as_mut_ptr() as *mut Unique3;
    let mut temp_v0_2: *mut Vec3s = 0 as *mut Vec3s;
    let mut sp4C: Vec3s = Vec3s{x: 0, y: 0, z: 0,};
    let mut anim: *mut Unique3Anim = &mut (*uniq3).anim;
    let mut params: *mut Unique3Params = &mut (*uniq3).params;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut cameraPlayerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    playerHeight = Player_GetHeight((*camera).player);
    (*camera).unk_14C =
        ((*camera).unk_14C as libc::c_int & !(0x10 as libc::c_int)) as s16;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let mut yNormal: f32_0 =
            1.0f32 +
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 -
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 * (68.0f32 / playerHeight);
        let fresh163 = values;
        values = values.offset(1);
        (*params).yOffset =
            (*fresh163).val as libc::c_int as libc::c_float * 0.01f32 *
                playerHeight * yNormal;
        let fresh164 = values;
        values = values.offset(1);
        (*params).fov = (*fresh164).val as f32_0;
        let fresh165 = values;
        values = values.offset(1);
        (*params).interfaceFlags = (*fresh165).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           as libc::c_int != 0 as libc::c_int {
        Camera_CopyPREGToModeValues(camera);
    }
    sCameraInterfaceFlags = (*params).interfaceFlags as s32;
    let mut current_block_52: u64;
    match (*camera).animState as libc::c_int {
        0 => {
            func_80043B60(camera);
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int &
                     !(0x8 as libc::c_int | 0x4 as libc::c_int)) as s16;
            (*anim).initialFov = (*camera).fov;
            (*anim).initialDist = OLib_Vec3fDist(at, &mut (*camera).eye);
            (*camera).animState += 1;
            current_block_52 = 17749695804753746426;
        }
        1 => { current_block_52 = 17749695804753746426; }
        2 => { current_block_52 = 8425362707541413004; }
        3 => { current_block_52 = 18329035507403926228; }
        4 => { current_block_52 = 12890710430445865668; }
        5 => { current_block_52 = 1811006621036413729; }
        _ => { current_block_52 = 12341560758780405305; }
    }
    match current_block_52 {
        17749695804753746426 => {
            let fresh166 = (*uniq3).doorParams.timer1;
            (*uniq3).doorParams.timer1 = (*uniq3).doorParams.timer1 - 1;
            if fresh166 as libc::c_int > 0 as libc::c_int {
                current_block_52 = 981995395831942902;
            } else {
                temp_v0_2 = Camera_GetCamBGData(camera);
                Camera_Vec3sToVec3f(&mut (*camera).eyeNext,
                                    &mut *temp_v0_2.offset(0 as libc::c_int as
                                                               isize));
                (*camera).eye = (*camera).eyeNext;
                sp4C = *temp_v0_2.offset(1 as libc::c_int as isize);
                sp60.r = 100.0f32;
                sp60.yaw = sp4C.y;
                sp60.pitch = -(sp4C.x as libc::c_int) as s16;
                Camera_Vec3fVecSphGeoAdd(at, &mut (*camera).eye, &mut sp60);
                (*camera).animState += 1;
                current_block_52 = 8425362707541413004;
            }
        }
        _ => { }
    }
    match current_block_52 {
        8425362707541413004 => {
            if (*params).interfaceFlags as libc::c_int & 4 as libc::c_int != 0
               {
                (*camera).at = (*cameraPlayerPosRot).pos;
                (*camera).at.y += playerHeight + (*params).yOffset
            }
            let fresh167 = (*uniq3).doorParams.timer2;
            (*uniq3).doorParams.timer2 = (*uniq3).doorParams.timer2 - 1;
            if fresh167 as libc::c_int > 0 as libc::c_int {
                current_block_52 = 981995395831942902;
            } else {
                (*camera).animState += 1;
                current_block_52 = 18329035507403926228;
            }
        }
        _ => { }
    }
    match current_block_52 {
        18329035507403926228 => {
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int |
                     (0x400 as libc::c_int | 0x10 as libc::c_int)) as s16;
            if (*camera).unk_14C as libc::c_int & 8 as libc::c_int !=
                   0 as libc::c_int {
                (*camera).animState += 1;
                current_block_52 = 12890710430445865668;
            } else { current_block_52 = 981995395831942902; }
        }
        _ => { }
    }
    match current_block_52 {
        12890710430445865668 => {
            if (*params).interfaceFlags as libc::c_int & 2 as libc::c_int != 0
               {
                (*camera).unk_14C =
                    ((*camera).unk_14C as libc::c_int | 4 as libc::c_int) as
                        s16;
                (*camera).unk_14C =
                    ((*camera).unk_14C as libc::c_int & !(8 as libc::c_int))
                        as s16;
                Camera_ChangeSettingFlags(camera,
                                          CAM_SET_PIVOT_IN_FRONT as
                                              libc::c_int as s16,
                                          2 as libc::c_int as s16);
                current_block_52 = 981995395831942902;
            } else {
                (*uniq3).doorParams.timer3 = 5 as libc::c_int as s16;
                if (*camera).xzSpeed > 0.001f32 ||
                       !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                       usize].press.button as
                             libc::c_int | !(0x8000 as libc::c_int)) ==
                           0 as libc::c_int ||
                       !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                       usize].press.button as
                             libc::c_int | !(0x4000 as libc::c_int)) ==
                           0 as libc::c_int ||
                       !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                       usize].press.button as
                             libc::c_int | !(0x2 as libc::c_int)) ==
                           0 as libc::c_int ||
                       !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                       usize].press.button as
                             libc::c_int | !(0x4 as libc::c_int)) ==
                           0 as libc::c_int ||
                       !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                       usize].press.button as
                             libc::c_int | !(0x8 as libc::c_int)) ==
                           0 as libc::c_int ||
                       !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                       usize].press.button as
                             libc::c_int | !(0x1 as libc::c_int)) ==
                           0 as libc::c_int ||
                       !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                       usize].press.button as
                             libc::c_int | !(0x10 as libc::c_int)) ==
                           0 as libc::c_int ||
                       !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                       usize].press.button as
                             libc::c_int | !(0x2000 as libc::c_int)) ==
                           0 as libc::c_int {
                    (*camera).animState += 1;
                    current_block_52 = 1811006621036413729;
                } else { current_block_52 = 981995395831942902; }
            }
        }
        _ => { }
    }
    match current_block_52 {
        1811006621036413729 => {
            (*camera).fov =
                Camera_LERPCeilF((*anim).initialFov, (*camera).fov, 0.4f32,
                                 0.1f32);
            OLib_Vec3fDiffToVecSphGeo(&mut sp60, at, &mut (*camera).eye);
            sp60.r = Camera_LERPCeilF(100.0f32, sp60.r, 0.4f32, 0.1f32);
            Camera_Vec3fVecSphGeoAdd(&mut (*camera).eyeNext, at, &mut sp60);
            (*camera).eye = (*camera).eyeNext;
            let fresh168 = (*uniq3).doorParams.timer3;
            (*uniq3).doorParams.timer3 = (*uniq3).doorParams.timer3 - 1;
            if fresh168 as libc::c_int > 0 as libc::c_int {
                current_block_52 = 981995395831942902;
            } else {
                (*camera).animState += 1;
                current_block_52 = 12341560758780405305;
            }
        }
        _ => { }
    }
    match current_block_52 {
        12341560758780405305 => {
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int | 4 as libc::c_int) as s16;
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int & !(8 as libc::c_int)) as
                    s16;
            (*camera).fov = (*params).fov;
            Camera_ChangeSettingFlags(camera, (*camera).prevSetting,
                                      2 as libc::c_int as s16);
            (*camera).atLERPStepScale = 0.0f32;
            (*camera).posOffset.x =
                (*camera).at.x - (*cameraPlayerPosRot).pos.x;
            (*camera).posOffset.y =
                (*camera).at.y - (*cameraPlayerPosRot).pos.y;
            (*camera).posOffset.z =
                (*camera).at.z - (*cameraPlayerPosRot).pos.z
        }
        _ => { }
    }
    return 1 as libc::c_int;
}
/* *
 * Camera's eye is specified by scene camera data, at point is generated at the intersection
 * of the eye to the player
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Unique0(mut camera: *mut Camera) -> s32 {
    let mut yOffset: f32_0 = 0.;
    let mut values: *mut CameraModeValue = 0 as *mut CameraModeValue;
    let mut player: *mut Player = 0 as *mut Player;
    let mut playerPosWithOffset: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut atPlayerOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut sceneCamData: *mut Vec3s = 0 as *mut Vec3s;
    let mut sceneCamRot: Vec3s = Vec3s{x: 0, y: 0, z: 0,};
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut uniq0: *mut Unique0 =
        (*camera).paramData.as_mut_ptr() as *mut Unique0;
    let mut params: *mut Unique0Params = &mut (*uniq0).uniq0;
    let mut anim: *mut Unique0Anim = &mut (*params).anim;
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut fov: s16 = 0;
    yOffset = Player_GetHeight((*camera).player);
    player = (*camera).player;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        values =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let fresh169 = values;
        values = values.offset(1);
        (*params).interfaceFlags = (*fresh169).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    playerPosWithOffset = (*playerPosRot).pos;
    playerPosWithOffset.y += yOffset;
    sCameraInterfaceFlags = (*params).interfaceFlags as s32;
    if (*camera).animState as libc::c_int == 0 as libc::c_int {
        func_80043B60(camera);
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int & !(4 as libc::c_int)) as s16;
        sceneCamData = Camera_GetCamBGData(camera);
        Camera_Vec3sToVec3f(&mut (*anim).sceneCamPosPlayerLine.a,
                            &mut *sceneCamData.offset(0 as libc::c_int as
                                                          isize));
        (*camera).eyeNext = (*anim).sceneCamPosPlayerLine.a;
        *eye = (*camera).eyeNext;
        sceneCamRot = *sceneCamData.offset(1 as libc::c_int as isize);
        fov = (*sceneCamData.offset(2 as libc::c_int as isize)).x;
        if fov as libc::c_int != -(1 as libc::c_int) {
            (*camera).fov =
                if (fov as libc::c_int) < 361 as libc::c_int {
                    fov as libc::c_int as libc::c_float
                } else { (fov as libc::c_int as libc::c_float) * 0.01f32 }
        }
        (*anim).animTimer =
            (*sceneCamData.offset(2 as libc::c_int as isize)).y;
        if (*anim).animTimer as libc::c_int == -(1 as libc::c_int) {
            (*anim).animTimer =
                ((*uniq0).doorParams.timer1 as libc::c_int +
                     (*uniq0).doorParams.timer2 as libc::c_int) as s16
        }
        atPlayerOffset.r = OLib_Vec3fDist(&mut playerPosWithOffset, eye);
        atPlayerOffset.yaw = sceneCamRot.y;
        atPlayerOffset.pitch = -(sceneCamRot.x as libc::c_int) as s16;
        OLib_VecSphGeoToVec3f(&mut (*anim).sceneCamPosPlayerLine.b,
                              &mut atPlayerOffset);
        Math3D_LineClosestToPoint(&mut (*anim).sceneCamPosPlayerLine,
                                  &mut (*playerPosRot).pos,
                                  &mut (*camera).at);
        (*anim).initalPos = (*playerPosRot).pos;
        (*camera).animState += 1
    }
    if (*player).stateFlags1 & 0x20000000 as libc::c_int as libc::c_uint != 0
       {
        (*anim).initalPos = (*playerPosRot).pos
    }
    if (*params).interfaceFlags as libc::c_int & 1 as libc::c_int != 0 {
        if (*anim).animTimer as libc::c_int > 0 as libc::c_int {
            (*anim).animTimer -= 1;
            (*anim).initalPos = (*playerPosRot).pos
        } else if (*player).stateFlags1 &
                      0x20000000 as libc::c_int as libc::c_uint == 0 &&
                      (OLib_Vec3fDistXZ(&mut (*playerPosRot).pos,
                                        &mut (*anim).initalPos) >= 10.0f32 ||
                           !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                           usize].press.button
                                 as libc::c_int | !(0x8000 as libc::c_int)) ==
                               0 as libc::c_int ||
                           !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                           usize].press.button
                                 as libc::c_int | !(0x4000 as libc::c_int)) ==
                               0 as libc::c_int ||
                           !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                           usize].press.button
                                 as libc::c_int | !(0x2 as libc::c_int)) ==
                               0 as libc::c_int ||
                           !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                           usize].press.button
                                 as libc::c_int | !(0x4 as libc::c_int)) ==
                               0 as libc::c_int ||
                           !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                           usize].press.button
                                 as libc::c_int | !(0x8 as libc::c_int)) ==
                               0 as libc::c_int ||
                           !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                           usize].press.button
                                 as libc::c_int | !(0x1 as libc::c_int)) ==
                               0 as libc::c_int ||
                           !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                           usize].press.button
                                 as libc::c_int | !(0x10 as libc::c_int)) ==
                               0 as libc::c_int ||
                           !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                           usize].press.button
                                 as libc::c_int | !(0x2000 as libc::c_int)) ==
                               0 as libc::c_int) {
            (*camera).dist = OLib_Vec3fDist(&mut (*camera).at, eye);
            (*camera).posOffset.x = (*camera).at.x - (*playerPosRot).pos.x;
            (*camera).posOffset.y = (*camera).at.y - (*playerPosRot).pos.y;
            (*camera).posOffset.z = (*camera).at.z - (*playerPosRot).pos.z;
            (*camera).atLERPStepScale = 0.0f32;
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int | 4 as libc::c_int) as s16;
            Camera_ChangeSettingFlags(camera, (*camera).prevSetting,
                                      2 as libc::c_int as s16);
        }
    } else {
        if (*anim).animTimer as libc::c_int > 0 as libc::c_int {
            (*anim).animTimer -= 1;
            if (*anim).animTimer as libc::c_int == 0 as libc::c_int {
                sCameraInterfaceFlags = 0 as libc::c_int
            }
        } else { (*anim).initalPos = (*playerPosRot).pos }
        if (*player).stateFlags1 & 0x20000000 as libc::c_int as libc::c_uint
               == 0 &&
               (0.001f32 < (*camera).xzSpeed ||
                    !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                    usize].press.button as
                          libc::c_int | !(0x8000 as libc::c_int)) ==
                        0 as libc::c_int ||
                    !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                    usize].press.button as
                          libc::c_int | !(0x4000 as libc::c_int)) ==
                        0 as libc::c_int ||
                    !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                    usize].press.button as
                          libc::c_int | !(0x2 as libc::c_int)) ==
                        0 as libc::c_int ||
                    !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                    usize].press.button as
                          libc::c_int | !(0x4 as libc::c_int)) ==
                        0 as libc::c_int ||
                    !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                    usize].press.button as
                          libc::c_int | !(0x8 as libc::c_int)) ==
                        0 as libc::c_int ||
                    !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                    usize].press.button as
                          libc::c_int | !(0x1 as libc::c_int)) ==
                        0 as libc::c_int ||
                    !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                    usize].press.button as
                          libc::c_int | !(0x10 as libc::c_int)) ==
                        0 as libc::c_int ||
                    !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                    usize].press.button as
                          libc::c_int | !(0x2000 as libc::c_int)) ==
                        0 as libc::c_int) {
            (*camera).dist =
                OLib_Vec3fDist(&mut (*camera).at, &mut (*camera).eye);
            (*camera).posOffset.x = (*camera).at.x - (*playerPosRot).pos.x;
            (*camera).posOffset.y = (*camera).at.y - (*playerPosRot).pos.y;
            (*camera).posOffset.z = (*camera).at.z - (*playerPosRot).pos.z;
            (*camera).atLERPStepScale = 0.0f32;
            Camera_ChangeSettingFlags(camera, (*camera).prevSetting,
                                      2 as libc::c_int as s16);
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int | 4 as libc::c_int) as s16
        }
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Unique4(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
/* *
 * Was setup to be used by the camera setting "FOREST_UNUSED"
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Unique5(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
/* *
 * This function doesn't really update much.
 * Eye/at positions are updated via Camera_SetParam
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Unique6(mut camera: *mut Camera) -> s32 {
    let mut uniq6: *mut Unique6 =
        (*camera).paramData.as_mut_ptr() as *mut Unique6;
    let mut values: *mut CameraModeValue = 0 as *mut CameraModeValue;
    let mut sp2C: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut offset: f32_0 = 0.;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        values =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let fresh170 = values;
        values = values.offset(1);
        (*uniq6).interfaceFlags = (*fresh170).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    sCameraInterfaceFlags = (*uniq6).interfaceFlags as s32;
    if (*camera).animState as libc::c_int == 0 as libc::c_int {
        (*camera).animState += 1;
        func_80043ABC(camera);
    }
    if !(*camera).player.is_null() {
        offset = Player_GetHeight((*camera).player);
        sp2C = (*playerPosRot).pos;
        sp2C.y += offset;
        (*camera).dist = OLib_Vec3fDist(&mut sp2C, &mut (*camera).eye);
        (*camera).posOffset.x = (*camera).at.x - (*playerPosRot).pos.x;
        (*camera).posOffset.y = (*camera).at.y - (*playerPosRot).pos.y;
        (*camera).posOffset.z = (*camera).at.z - (*playerPosRot).pos.z
    } else {
        (*camera).dist = OLib_Vec3fDist(&mut (*camera).at, &mut (*camera).eye)
    }
    if (*uniq6).interfaceFlags as libc::c_int & 1 as libc::c_int != 0 &&
           (*camera).timer as libc::c_int > 0 as libc::c_int {
        (*camera).timer -= 1
    }
    return 1 as libc::c_int;
}
/* *
 * Camera is at a fixed point specified by the scene's camera data,
 * camera rotates to follow player
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Unique7(mut camera: *mut Camera) -> s32 {
    let mut pad: s32 = 0; // unused
    let mut uniq7: *mut Unique7 =
        (*camera).paramData.as_mut_ptr() as *mut Unique7;
    let mut values: *mut CameraModeValue = 0 as *mut CameraModeValue;
    let mut playerPosEyeOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut fov: s16 = 0;
    let mut sceneCamData: *mut Vec3s = 0 as *mut Vec3s;
    let mut sceneCamRot: Vec3s = Vec3s{x: 0, y: 0, z: 0,};
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut unk08: *mut Unique7Unk8 = &mut (*uniq7).unk_08;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        values =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let fresh171 = values;
        values = values.offset(1);
        (*uniq7).fov = (*fresh171).val as f32_0;
        let fresh172 = values;
        values = values.offset(1);
        (*uniq7).interfaceFlags = (*fresh172).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    sceneCamData = Camera_GetCamBGData(camera);
    Camera_Vec3sToVec3f(eyeNext,
                        &mut *sceneCamData.offset(0 as libc::c_int as isize));
    *eye = *eyeNext;
    sceneCamRot = *sceneCamData.offset(1 as libc::c_int as isize);
    // suppresses set but unused warning
    OLib_Vec3fDiffToVecSphGeo(&mut playerPosEyeOffset, eye,
                              &mut (*playerPosRot).pos);
    // fov actually goes unused since it's hard set later on.
    fov = (*sceneCamData.offset(2 as libc::c_int as isize)).x;
    if fov as libc::c_int == -(1 as libc::c_int) {
        fov = ((*uniq7).fov * 100.0f32) as s16
    }
    if (fov as libc::c_int) < 361 as libc::c_int {
        fov = (fov as libc::c_int * 100 as libc::c_int) as s16
    }
    sCameraInterfaceFlags = (*uniq7).interfaceFlags as s32;
    if (*camera).animState as libc::c_int == 0 as libc::c_int {
        (*camera).animState += 1;
        (*camera).fov = fov as libc::c_int as libc::c_float * 0.01f32;
        (*camera).atLERPStepScale = 0.0f32;
        (*camera).roll = 0 as libc::c_int as s16;
        (*unk08).unk_00.x = playerPosEyeOffset.yaw
    }
    (*camera).fov = 60.0f32;
    // 0x7D0 ~ 10.98 degres.
    (*unk08).unk_00.x =
        Camera_LERPFloorS(playerPosEyeOffset.yaw, (*unk08).unk_00.x, 0.4f32,
                          0x7d0 as libc::c_int as s16);
    playerPosEyeOffset.pitch =
        (-((*sceneCamData.offset(1 as libc::c_int as isize)).x as libc::c_int)
             as libc::c_float *
             Math_CosS((playerPosEyeOffset.yaw as libc::c_int -
                            (*sceneCamData.offset(1 as libc::c_int as
                                                      isize)).y as
                                libc::c_int) as s16)) as s16;
    Camera_Vec3fVecSphGeoAdd(at, eye, &mut playerPosEyeOffset);
    (*camera).unk_14C =
        ((*camera).unk_14C as libc::c_int | 0x400 as libc::c_int) as s16;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Unique8(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Unique9(mut camera: *mut Camera) -> s32 {
    let mut atTarget: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut eyeTarget: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut uniq9: *mut Unique9 =
        &mut (*((*camera).paramData.as_mut_ptr() as
                    *mut Unique9OnePointCs)).uniq9;
    let mut anim: *mut Unique9Anim = &mut (*uniq9).anim;
    let mut invKeyFrameTimer: f32_0 = 0.;
    let mut eyeNextAtOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut scratchSph: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut playerTargetOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut action: s16 = 0;
    let mut atInitFlags: s16 = 0;
    let mut eyeInitFlags: s16 = 0;
    let mut pad2: s16 = 0;
    let mut targethead: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut playerhead: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut playerPosRot: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut player: *mut Player = (*camera).player;
    let mut focusActor: *mut Actor = 0 as *mut Actor;
    let mut spB4: f32_0 = 0.;
    let mut atFocusPosRot: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut eyeLookAtPos: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut values: *mut CameraModeValue = 0 as *mut CameraModeValue;
    let mut eyeFocusPosRot: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        values =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let fresh173 = values;
        values = values.offset(1);
        (*uniq9).interfaceFlags = (*fresh173).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    sCameraInterfaceFlags = (*uniq9).interfaceFlags as s32;
    Actor_GetWorld(&mut playerPosRot, &mut (*(*camera).player).actor);
    if (*camera).animState as libc::c_int == 0 as libc::c_int {
        (*camera).animState += 1;
        (*anim).curKeyFrameIdx = -(1 as libc::c_int) as s16;
        (*anim).keyFrameTimer = 1 as libc::c_int as s16;
        (*anim).unk_38 = 0 as libc::c_int as s16;
        (*anim).playerPos.x = playerPosRot.pos.x;
        (*anim).playerPos.y = playerPosRot.pos.y;
        (*anim).playerPos.z = playerPosRot.pos.z;
        (*camera).atLERPStepScale = 0.0f32;
        func_80043B60(camera);
    }
    if (*anim).unk_38 as libc::c_int == 0 as libc::c_int &&
           (*anim).keyFrameTimer as libc::c_int > 0 as libc::c_int {
        (*anim).keyFrameTimer -= 1
    }
    if (*anim).keyFrameTimer as libc::c_int == 0 as libc::c_int {
        (*anim).isNewKeyFrame = 1 as libc::c_int as s16;
        (*anim).curKeyFrameIdx += 1;
        if ((*anim).curKeyFrameIdx as libc::c_int) <
               (*((*camera).paramData.as_mut_ptr() as
                      *mut Unique9OnePointCs)).keyFrameCnt {
            (*anim).curKeyFrame =
                &mut *(*((*camera).paramData.as_mut_ptr() as
                             *mut Unique9OnePointCs)).keyFrames.offset((*anim).curKeyFrameIdx
                                                                           as
                                                                           isize)
                    as *mut OnePointCsFull;
            (*anim).keyFrameTimer = (*(*anim).curKeyFrame).timerInit;
            if (*(*anim).curKeyFrame).unk_01 as libc::c_int !=
                   0xff as libc::c_int {
                if (*(*anim).curKeyFrame).unk_01 as libc::c_int &
                       0xf0 as libc::c_int == 0x80 as libc::c_int {
                    D_8011D3AC =
                        (*(*anim).curKeyFrame).unk_01 as libc::c_int &
                            0xf as libc::c_int
                } else if (*(*anim).curKeyFrame).unk_01 as libc::c_int &
                              0xf0 as libc::c_int == 0xc0 as libc::c_int {
                    Camera_UpdateInterface((0xf000 as libc::c_int |
                                                ((*(*anim).curKeyFrame).unk_01
                                                     as libc::c_int &
                                                     0xf as libc::c_int) <<
                                                    8 as libc::c_int) as s16);
                } else if (*(*camera).player).stateFlags1 &
                              0x8000000 as libc::c_int as libc::c_uint != 0 &&
                              (*player).currentBoots as libc::c_int !=
                                  PLAYER_BOOTS_IRON as libc::c_int {
                    func_8002DF38((*camera).globalCtx, (*camera).target,
                                  8 as libc::c_int as u8_0);
                    osSyncPrintf(b"camera: demo: player demo set WAIT\n\x00"
                                     as *const u8 as *const libc::c_char);
                } else {
                    osSyncPrintf(b"camera: demo: player demo set %d\n\x00" as
                                     *const u8 as *const libc::c_char,
                                 (*(*anim).curKeyFrame).unk_01 as
                                     libc::c_int);
                    func_8002DF38((*camera).globalCtx, (*camera).target,
                                  (*(*anim).curKeyFrame).unk_01);
                }
            }
        } else {
            // We've gone through all the keyframes.
            if (*camera).thisIdx as libc::c_int != 0 as libc::c_int {
                (*camera).timer = 0 as libc::c_int as s16
            }
            return 1 as libc::c_int
        }
    } else { (*anim).isNewKeyFrame = 0 as libc::c_int as s16 }
    atInitFlags =
        ((*(*anim).curKeyFrame).initFlags as libc::c_int &
             0xff as libc::c_int) as s16;
    if atInitFlags as libc::c_int == 1 as libc::c_int {
        (*anim).atTarget = (*(*anim).curKeyFrame).atTargetInit
    } else if atInitFlags as libc::c_int == 2 as libc::c_int {
        if (*anim).isNewKeyFrame != 0 {
            (*anim).atTarget.x =
                (*(*camera).globalCtx).view.lookAt.x +
                    (*(*anim).curKeyFrame).atTargetInit.x;
            (*anim).atTarget.y =
                (*(*camera).globalCtx).view.lookAt.y +
                    (*(*anim).curKeyFrame).atTargetInit.y;
            (*anim).atTarget.z =
                (*(*camera).globalCtx).view.lookAt.z +
                    (*(*anim).curKeyFrame).atTargetInit.z
        }
    } else if atInitFlags as libc::c_int == 3 as libc::c_int {
        if (*anim).isNewKeyFrame != 0 {
            (*anim).atTarget.x =
                (*camera).at.x + (*(*anim).curKeyFrame).atTargetInit.x;
            (*anim).atTarget.y =
                (*camera).at.y + (*(*anim).curKeyFrame).atTargetInit.y;
            (*anim).atTarget.z =
                (*camera).at.z + (*(*anim).curKeyFrame).atTargetInit.z
        }
    } else if atInitFlags as libc::c_int == 4 as libc::c_int ||
                  atInitFlags as libc::c_int == 0x84 as libc::c_int {
        if !(*camera).target.is_null() && (*(*camera).target).update.is_some()
           {
            Actor_GetFocus(&mut targethead, (*camera).target);
            Actor_GetFocus(&mut playerhead, &mut (*(*camera).player).actor);
            playerhead.pos.x = playerPosRot.pos.x;
            playerhead.pos.z = playerPosRot.pos.z;
            OLib_Vec3fDiffToVecSphGeo(&mut playerTargetOffset,
                                      &mut targethead.pos,
                                      &mut playerhead.pos);
            if atInitFlags as libc::c_int &
                   0x8080 as libc::c_int as s16 as libc::c_int != 0 {
                scratchSph.pitch =
                    ((*(*anim).curKeyFrame).atTargetInit.x * 182.04167f32 +
                         0.5f32) as s16;
                scratchSph.yaw =
                    ((*(*anim).curKeyFrame).atTargetInit.y * 182.04167f32 +
                         0.5f32) as s16;
                scratchSph.r = (*(*anim).curKeyFrame).atTargetInit.z
            } else {
                OLib_Vec3fToVecSphGeo(&mut scratchSph,
                                      &mut (*(*anim).curKeyFrame).atTargetInit);
            }
            scratchSph.yaw =
                (scratchSph.yaw as libc::c_int +
                     playerTargetOffset.yaw as libc::c_int) as s16;
            scratchSph.pitch =
                (scratchSph.pitch as libc::c_int +
                     playerTargetOffset.pitch as libc::c_int) as s16;
            Camera_Vec3fVecSphGeoAdd(&mut (*anim).atTarget,
                                     &mut targethead.pos, &mut scratchSph);
        } else {
            if (*camera).target.is_null() {
                osSyncPrintf(b"\x1b[43;30mcamera: warning: demo C: actor is not valid\n\x1b[m\x00"
                                 as *const u8 as *const libc::c_char);
            }
            (*camera).target = 0 as *mut Actor;
            (*anim).atTarget = (*camera).at
        }
    } else if atInitFlags as libc::c_int & 0x6060 as libc::c_int != 0 {
        if atInitFlags as libc::c_int & 4 as libc::c_int == 0 ||
               (*anim).isNewKeyFrame as libc::c_int != 0 {
            if atInitFlags as libc::c_int & 0x2020 as libc::c_int != 0 {
                focusActor = &mut (*(*camera).player).actor
            } else if !(*camera).target.is_null() &&
                          (*(*camera).target).update.is_some() {
                focusActor = (*camera).target
            } else {
                (*camera).target = 0 as *mut Actor;
                focusActor = 0 as *mut Actor
            }
            if !focusActor.is_null() {
                if atInitFlags as libc::c_int & 0xf as libc::c_int ==
                       1 as libc::c_int {
                    Actor_GetFocus(&mut atFocusPosRot, focusActor);
                } else if atInitFlags as libc::c_int & 0xf as libc::c_int ==
                              2 as libc::c_int {
                    Actor_GetWorld(&mut atFocusPosRot, focusActor);
                } else {
                    Actor_GetWorldPosShapeRot(&mut atFocusPosRot, focusActor);
                }
                if atInitFlags as libc::c_int &
                       0x8080 as libc::c_int as s16 as libc::c_int != 0 {
                    scratchSph.pitch =
                        ((*(*anim).curKeyFrame).atTargetInit.x * 182.04167f32
                             + 0.5f32) as s16;
                    scratchSph.yaw =
                        ((*(*anim).curKeyFrame).atTargetInit.y * 182.04167f32
                             + 0.5f32) as s16;
                    scratchSph.r = (*(*anim).curKeyFrame).atTargetInit.z
                } else {
                    OLib_Vec3fToVecSphGeo(&mut scratchSph,
                                          &mut (*(*anim).curKeyFrame).atTargetInit);
                }
                scratchSph.yaw =
                    (scratchSph.yaw as libc::c_int +
                         atFocusPosRot.rot.y as libc::c_int) as s16;
                scratchSph.pitch =
                    (scratchSph.pitch as libc::c_int -
                         atFocusPosRot.rot.x as libc::c_int) as s16;
                Camera_Vec3fVecSphGeoAdd(&mut (*anim).atTarget,
                                         &mut atFocusPosRot.pos,
                                         &mut scratchSph);
            } else {
                if (*camera).target.is_null() {
                    osSyncPrintf(b"\x1b[43;30mcamera: warning: demo C: actor is not valid\n\x1b[m\x00"
                                     as *const u8 as *const libc::c_char);
                }
                (*anim).atTarget = *at
            }
        }
    } else { (*anim).atTarget = *at }
    eyeInitFlags =
        ((*(*anim).curKeyFrame).initFlags as libc::c_int &
             0xff00 as libc::c_int) as s16;
    if eyeInitFlags as libc::c_int == 0x100 as libc::c_int {
        (*anim).eyeTarget = (*(*anim).curKeyFrame).eyeTargetInit
    } else if eyeInitFlags as libc::c_int == 0x200 as libc::c_int {
        if (*anim).isNewKeyFrame != 0 {
            (*anim).eyeTarget.x =
                (*(*camera).globalCtx).view.eye.x +
                    (*(*anim).curKeyFrame).eyeTargetInit.x;
            (*anim).eyeTarget.y =
                (*(*camera).globalCtx).view.eye.y +
                    (*(*anim).curKeyFrame).eyeTargetInit.y;
            (*anim).eyeTarget.z =
                (*(*camera).globalCtx).view.eye.z +
                    (*(*anim).curKeyFrame).eyeTargetInit.z
        }
    } else if eyeInitFlags as libc::c_int == 0x300 as libc::c_int {
        if (*anim).isNewKeyFrame != 0 {
            (*anim).eyeTarget.x =
                (*camera).eyeNext.x + (*(*anim).curKeyFrame).eyeTargetInit.x;
            (*anim).eyeTarget.y =
                (*camera).eyeNext.y + (*(*anim).curKeyFrame).eyeTargetInit.y;
            (*anim).eyeTarget.z =
                (*camera).eyeNext.z + (*(*anim).curKeyFrame).eyeTargetInit.z
        }
    } else if eyeInitFlags as libc::c_int == 0x400 as libc::c_int ||
                  eyeInitFlags as libc::c_int ==
                      0x8400 as libc::c_int as s16 as libc::c_int ||
                  eyeInitFlags as libc::c_int == 0x500 as libc::c_int ||
                  eyeInitFlags as libc::c_int ==
                      0x8500 as libc::c_int as s16 as libc::c_int {
        if !(*camera).target.is_null() && (*(*camera).target).update.is_some()
           {
            Actor_GetFocus(&mut targethead, (*camera).target);
            Actor_GetFocus(&mut playerhead, &mut (*(*camera).player).actor);
            playerhead.pos.x = playerPosRot.pos.x;
            playerhead.pos.z = playerPosRot.pos.z;
            OLib_Vec3fDiffToVecSphGeo(&mut playerTargetOffset,
                                      &mut targethead.pos,
                                      &mut playerhead.pos);
            if eyeInitFlags as libc::c_int == 0x400 as libc::c_int ||
                   eyeInitFlags as libc::c_int ==
                       0x8400 as libc::c_int as s16 as libc::c_int {
                eyeLookAtPos = targethead.pos
            } else { eyeLookAtPos = (*anim).atTarget }
            if eyeInitFlags as libc::c_int &
                   0x8080 as libc::c_int as s16 as libc::c_int != 0 {
                scratchSph.pitch =
                    ((*(*anim).curKeyFrame).eyeTargetInit.x * 182.04167f32 +
                         0.5f32) as s16;
                scratchSph.yaw =
                    ((*(*anim).curKeyFrame).eyeTargetInit.y * 182.04167f32 +
                         0.5f32) as s16;
                scratchSph.r = (*(*anim).curKeyFrame).eyeTargetInit.z
            } else {
                OLib_Vec3fToVecSphGeo(&mut scratchSph,
                                      &mut (*(*anim).curKeyFrame).eyeTargetInit);
            }
            scratchSph.yaw =
                (scratchSph.yaw as libc::c_int +
                     playerTargetOffset.yaw as libc::c_int) as s16;
            scratchSph.pitch =
                (scratchSph.pitch as libc::c_int +
                     playerTargetOffset.pitch as libc::c_int) as s16;
            Camera_Vec3fVecSphGeoAdd(&mut (*anim).eyeTarget,
                                     &mut eyeLookAtPos, &mut scratchSph);
        } else {
            if (*camera).target.is_null() {
                osSyncPrintf(b"\x1b[43;30mcamera: warning: demo C: actor is not valid\n\x1b[m\x00"
                                 as *const u8 as *const libc::c_char);
            }
            (*camera).target = 0 as *mut Actor;
            (*anim).eyeTarget = *eyeNext
        }
    } else if eyeInitFlags as libc::c_int & 0x6060 as libc::c_int != 0 {
        if eyeInitFlags as libc::c_int & 0x400 as libc::c_int == 0 ||
               (*anim).isNewKeyFrame as libc::c_int != 0 {
            if eyeInitFlags as libc::c_int & 0x2020 as libc::c_int != 0 {
                focusActor = &mut (*(*camera).player).actor
            } else if !(*camera).target.is_null() &&
                          (*(*camera).target).update.is_some() {
                focusActor = (*camera).target
            } else {
                (*camera).target = 0 as *mut Actor;
                focusActor = 0 as *mut Actor
            }
            if !focusActor.is_null() {
                if eyeInitFlags as libc::c_int & 0xf00 as libc::c_int ==
                       0x100 as libc::c_int {
                    // head
                    Actor_GetFocus(&mut eyeFocusPosRot, focusActor);
                } else if eyeInitFlags as libc::c_int & 0xf00 as libc::c_int
                              == 0x200 as libc::c_int {
                    // world
                    Actor_GetWorld(&mut eyeFocusPosRot, focusActor);
                } else {
                    // world, shapeRot
                    Actor_GetWorldPosShapeRot(&mut eyeFocusPosRot,
                                              focusActor);
                }
                if eyeInitFlags as libc::c_int &
                       0x8080 as libc::c_int as s16 as libc::c_int != 0 {
                    scratchSph.pitch =
                        ((*(*anim).curKeyFrame).eyeTargetInit.x * 182.04167f32
                             + 0.5f32) as s16;
                    scratchSph.yaw =
                        ((*(*anim).curKeyFrame).eyeTargetInit.y * 182.04167f32
                             + 0.5f32) as s16;
                    scratchSph.r = (*(*anim).curKeyFrame).eyeTargetInit.z
                } else {
                    OLib_Vec3fToVecSphGeo(&mut scratchSph,
                                          &mut (*(*anim).curKeyFrame).eyeTargetInit);
                }
                scratchSph.yaw =
                    (scratchSph.yaw as libc::c_int +
                         eyeFocusPosRot.rot.y as libc::c_int) as s16;
                scratchSph.pitch =
                    (scratchSph.pitch as libc::c_int -
                         eyeFocusPosRot.rot.x as libc::c_int) as s16;
                Camera_Vec3fVecSphGeoAdd(&mut (*anim).eyeTarget,
                                         &mut eyeFocusPosRot.pos,
                                         &mut scratchSph);
            } else {
                if (*camera).target.is_null() {
                    osSyncPrintf(b"\x1b[43;30mcamera: warning: demo C: actor is not valid\n\x1b[m\x00"
                                     as *const u8 as *const libc::c_char);
                }
                (*camera).target = 0 as *mut Actor;
                (*anim).eyeTarget = *eyeNext
            }
        }
    } else { (*anim).eyeTarget = *eyeNext }
    if (*(*anim).curKeyFrame).initFlags as libc::c_int == 2 as libc::c_int {
        (*anim).fovTarget = (*(*camera).globalCtx).view.fovy;
        (*anim).rollTarget = 0 as libc::c_int as s16
    } else if (*(*anim).curKeyFrame).initFlags as libc::c_int ==
                  0 as libc::c_int {
        (*anim).fovTarget = (*camera).fov;
        (*anim).rollTarget = (*camera).roll
    } else {
        (*anim).fovTarget = (*(*anim).curKeyFrame).fovTargetInit;
        (*anim).rollTarget =
            ((*(*anim).curKeyFrame).rollTargetInit as libc::c_int as
                 libc::c_float * 182.04167f32 + 0.5f32) as s16
    }
    action =
        ((*(*anim).curKeyFrame).actionFlags as libc::c_int &
             0x1f as libc::c_int) as s16;
    let mut current_block_326: u64;
    match action as libc::c_int {
        15 => {
            // static copy to at/eye/fov/roll
            *at = (*anim).atTarget;
            *eyeNext = (*anim).eyeTarget;
            (*camera).fov = (*anim).fovTarget;
            (*camera).roll = (*anim).rollTarget;
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int | 0x400 as libc::c_int) as
                    s16;
            current_block_326 = 10313911150873838611;
        }
        21 => {
            // same as 15, but with unk_38 ?
            if (*anim).unk_38 as libc::c_int == 0 as libc::c_int {
                (*anim).unk_38 = 1 as libc::c_int as s16
            } else if (*camera).unk_14C as libc::c_int & 8 as libc::c_int != 0
             {
                (*anim).unk_38 = 0 as libc::c_int as s16;
                (*camera).unk_14C =
                    ((*camera).unk_14C as libc::c_int & !(8 as libc::c_int))
                        as s16
            }
            *at = (*anim).atTarget;
            *eyeNext = (*anim).eyeTarget;
            (*camera).fov = (*anim).fovTarget;
            (*camera).roll = (*anim).rollTarget;
            current_block_326 = 10313911150873838611;
        }
        16 => {
            // same as 16, but don't unset bit 0x8 on unk_14C
            if (*anim).unk_38 as libc::c_int == 0 as libc::c_int {
                (*anim).unk_38 = 1 as libc::c_int as s16
            } else if (*camera).unk_14C as libc::c_int & 8 as libc::c_int != 0
             {
                (*anim).unk_38 = 0 as libc::c_int as s16
            }
            *at = (*anim).atTarget;
            *eyeNext = (*anim).eyeTarget;
            (*camera).fov = (*anim).fovTarget;
            (*camera).roll = (*anim).rollTarget;
            current_block_326 = 10313911150873838611;
        }
        1 => {
            // linear interpolation of eye/at using the spherical coordinates
            OLib_Vec3fDiffToVecSphGeo(&mut eyeNextAtOffset, at, eyeNext);
            OLib_Vec3fDiffToVecSphGeo(&mut (*anim).atEyeOffsetTarget,
                                      &mut (*anim).atTarget,
                                      &mut (*anim).eyeTarget);
            invKeyFrameTimer =
                1.0f32 /
                    (*anim).keyFrameTimer as libc::c_int as libc::c_float;
            scratchSph.r =
                eyeNextAtOffset.r +
                    ((*anim).atEyeOffsetTarget.r - eyeNextAtOffset.r) *
                        invKeyFrameTimer;
            scratchSph.pitch =
                (eyeNextAtOffset.pitch as libc::c_int as libc::c_float +
                     ((*anim).atEyeOffsetTarget.pitch as libc::c_int -
                          eyeNextAtOffset.pitch as libc::c_int) as s16 as
                         libc::c_int as libc::c_float * invKeyFrameTimer) as
                    s16;
            scratchSph.yaw =
                (eyeNextAtOffset.yaw as libc::c_int as libc::c_float +
                     ((*anim).atEyeOffsetTarget.yaw as libc::c_int -
                          eyeNextAtOffset.yaw as libc::c_int) as s16 as
                         libc::c_int as libc::c_float * invKeyFrameTimer) as
                    s16;
            Camera_Vec3fVecSphGeoAdd(&mut eyeTarget, at, &mut scratchSph);
            current_block_326 = 12504790875787742761;
        }
        2 => {
            // linear interpolation of eye/at using the eyeTarget
            invKeyFrameTimer =
                1.0f32 /
                    (*anim).keyFrameTimer as libc::c_int as libc::c_float;
            eyeTarget.x =
                (*camera).eyeNext.x +
                    ((*anim).eyeTarget.x - (*camera).eyeNext.x) *
                        invKeyFrameTimer;
            eyeTarget.y =
                (*camera).eyeNext.y +
                    ((*anim).eyeTarget.y - (*camera).eyeNext.y) *
                        invKeyFrameTimer;
            eyeTarget.z =
                (*camera).eyeNext.z +
                    ((*anim).eyeTarget.z - (*camera).eyeNext.z) *
                        invKeyFrameTimer;
            current_block_326 = 12504790875787742761;
        }
        9 | 10 => { current_block_326 = 2662073036543460927; }
        4 => {
            // linear interpolation of eye/at/fov/roll using the step scale, and spherical coordinates
            OLib_Vec3fDiffToVecSphGeo(&mut eyeNextAtOffset, at, eyeNext);
            OLib_Vec3fDiffToVecSphGeo(&mut (*anim).atEyeOffsetTarget,
                                      &mut (*anim).atTarget,
                                      &mut (*anim).eyeTarget);
            scratchSph.r =
                Camera_LERPCeilF((*anim).atEyeOffsetTarget.r,
                                 eyeNextAtOffset.r,
                                 (*(*anim).curKeyFrame).lerpStepScale,
                                 0.1f32);
            scratchSph.pitch =
                Camera_LERPCeilS((*anim).atEyeOffsetTarget.pitch,
                                 eyeNextAtOffset.pitch,
                                 (*(*anim).curKeyFrame).lerpStepScale,
                                 1 as libc::c_int as s16);
            scratchSph.yaw =
                Camera_LERPCeilS((*anim).atEyeOffsetTarget.yaw,
                                 eyeNextAtOffset.yaw,
                                 (*(*anim).curKeyFrame).lerpStepScale,
                                 1 as libc::c_int as s16);
            Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut scratchSph);
            current_block_326 = 702043872316828956;
        }
        3 => {
            // linear interplation of eye/at/fov/roll using the step scale using eyeTarget
            (*camera).eyeNext.x =
                Camera_LERPCeilF((*anim).eyeTarget.x, (*camera).eyeNext.x,
                                 (*(*anim).curKeyFrame).lerpStepScale,
                                 1.0f32);
            (*camera).eyeNext.y =
                Camera_LERPCeilF((*anim).eyeTarget.y, (*camera).eyeNext.y,
                                 (*(*anim).curKeyFrame).lerpStepScale,
                                 1.0f32);
            (*camera).eyeNext.z =
                Camera_LERPCeilF((*anim).eyeTarget.z, (*camera).eyeNext.z,
                                 (*(*anim).curKeyFrame).lerpStepScale,
                                 1.0f32);
            current_block_326 = 702043872316828956;
        }
        11 | 12 => { current_block_326 = 702043872316828956; }
        13 => {
            // linear interpolation of at, with rotation around eyeTargetInit.y
            (*camera).at.x =
                Camera_LERPCeilF((*anim).atTarget.x, (*camera).at.x,
                                 (*(*anim).curKeyFrame).lerpStepScale,
                                 1.0f32);
            (*camera).at.y +=
                (*camera).playerPosDelta.y *
                    (*(*anim).curKeyFrame).lerpStepScale;
            (*camera).at.z =
                Camera_LERPCeilF((*anim).atTarget.z, (*camera).at.z,
                                 (*(*anim).curKeyFrame).lerpStepScale,
                                 1.0f32);
            OLib_Vec3fDiffToVecSphGeo(&mut scratchSph, at, eyeNext);
            scratchSph.yaw =
                (scratchSph.yaw as libc::c_int +
                     ((*(*anim).curKeyFrame).eyeTargetInit.y * 182.04167f32 +
                          0.5f32) as s16 as libc::c_int) as s16;
            // 3A98 ~ 82.40 degrees
            if scratchSph.pitch as libc::c_int >= 0x3a99 as libc::c_int {
                scratchSph.pitch = 0x3a98 as libc::c_int as s16
            }
            if (scratchSph.pitch as libc::c_int) < -(0x3a98 as libc::c_int) {
                scratchSph.pitch = -(0x3a98 as libc::c_int) as s16
            }
            spB4 = scratchSph.r;
            scratchSph.r =
                if !(spB4 < (*(*anim).curKeyFrame).eyeTargetInit.z) {
                    Camera_LERPCeilF((*(*anim).curKeyFrame).eyeTargetInit.z,
                                     spB4,
                                     (*(*anim).curKeyFrame).lerpStepScale,
                                     1.0f32)
                } else { scratchSph.r };
            Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut scratchSph);
            (*camera).fov =
                Camera_LERPCeilF((*camera).fov +
                                     ((*(*anim).curKeyFrame).fovTargetInit -
                                          (*camera).fov) /
                                         (*anim).keyFrameTimer as libc::c_int
                                             as libc::c_float, (*camera).fov,
                                 (*(*anim).curKeyFrame).lerpStepScale,
                                 1.0f32);
            (*camera).roll =
                Camera_LERPCeilS((*anim).rollTarget, (*camera).roll,
                                 (*(*anim).curKeyFrame).lerpStepScale,
                                 1 as libc::c_int as s16);
            current_block_326 = 10313911150873838611;
        }
        24 => {
            // Set current keyframe to the roll target?
            (*anim).curKeyFrameIdx = (*anim).rollTarget;
            current_block_326 = 10313911150873838611;
        }
        19 => {
            // Change the parent camera (or default)'s mode to normal
            let mut camIdx: s32 =
                if (*camera).parentCamIdx as libc::c_int <=
                       -(1 as libc::c_int) {
                    0 as libc::c_int
                } else { (*camera).parentCamIdx as libc::c_int };
            Camera_ChangeModeFlags((*(*camera).globalCtx).cameraPtrs[camIdx as
                                                                         usize],
                                   CAM_MODE_NORMAL as libc::c_int as s16,
                                   1 as libc::c_int as u8_0);
            current_block_326 = 9024338909413786300;
        }
        18 => { current_block_326 = 9024338909413786300; }
        _ => { current_block_326 = 1872968636709110721; }
    }
    match current_block_326 {
        702043872316828956 => {
            // linear interpolation of at/fov/roll using the step scale.
            (*camera).at.x =
                Camera_LERPCeilF((*anim).atTarget.x, (*camera).at.x,
                                 (*(*anim).curKeyFrame).lerpStepScale,
                                 1.0f32);
            (*camera).at.y =
                Camera_LERPCeilF((*anim).atTarget.y, (*camera).at.y,
                                 (*(*anim).curKeyFrame).lerpStepScale,
                                 1.0f32);
            (*camera).at.z =
                Camera_LERPCeilF((*anim).atTarget.z, (*camera).at.z,
                                 (*(*anim).curKeyFrame).lerpStepScale,
                                 1.0f32);
            (*camera).fov =
                Camera_LERPCeilF((*anim).fovTarget, (*camera).fov,
                                 (*(*anim).curKeyFrame).lerpStepScale,
                                 1.0f32);
            (*camera).roll =
                Camera_LERPCeilS((*anim).rollTarget, (*camera).roll,
                                 (*(*anim).curKeyFrame).lerpStepScale,
                                 1 as libc::c_int as s16);
            current_block_326 = 10313911150873838611;
        }
        12504790875787742761 => {
            (*camera).eyeNext.x =
                Camera_LERPFloorF(eyeTarget.x, (*camera).eyeNext.x,
                                  (*(*anim).curKeyFrame).lerpStepScale,
                                  1.0f32);
            (*camera).eyeNext.y =
                Camera_LERPFloorF(eyeTarget.y, (*camera).eyeNext.y,
                                  (*(*anim).curKeyFrame).lerpStepScale,
                                  1.0f32);
            (*camera).eyeNext.z =
                Camera_LERPFloorF(eyeTarget.z, (*camera).eyeNext.z,
                                  (*(*anim).curKeyFrame).lerpStepScale,
                                  1.0f32);
            current_block_326 = 2662073036543460927;
        }
        9024338909413786300 => {
            // copy the current camera to the parent (or default)'s camera.
            let mut camIdx_0: s32 =
                if (*camera).parentCamIdx as libc::c_int <=
                       -(1 as libc::c_int) {
                    0 as libc::c_int
                } else { (*camera).parentCamIdx as libc::c_int };
            let mut cam: *mut Camera =
                (*(*camera).globalCtx).cameraPtrs[camIdx_0 as usize];
            *eye = *eyeNext;
            Camera_Copy(cam, camera);
            current_block_326 = 1872968636709110721;
        }
        _ => { }
    }
    match current_block_326 {
        2662073036543460927 => {
            // linear interpolation of at/fov/roll
            invKeyFrameTimer =
                1.0f32 /
                    (*anim).keyFrameTimer as libc::c_int as libc::c_float;
            atTarget.x =
                (*camera).at.x +
                    ((*anim).atTarget.x - (*camera).at.x) * invKeyFrameTimer;
            atTarget.y =
                (*camera).at.y +
                    ((*anim).atTarget.y - (*camera).at.y) * invKeyFrameTimer;
            atTarget.z =
                (*camera).at.z +
                    ((*anim).atTarget.z - (*camera).at.z) * invKeyFrameTimer;
            (*camera).at.x =
                Camera_LERPFloorF(atTarget.x, (*camera).at.x,
                                  (*(*anim).curKeyFrame).lerpStepScale,
                                  1.0f32);
            (*camera).at.y =
                Camera_LERPFloorF(atTarget.y, (*camera).at.y,
                                  (*(*anim).curKeyFrame).lerpStepScale,
                                  1.0f32);
            (*camera).at.z =
                Camera_LERPFloorF(atTarget.z, (*camera).at.z,
                                  (*(*anim).curKeyFrame).lerpStepScale,
                                  1.0f32);
            (*camera).fov =
                Camera_LERPFloorF((*camera).fov +
                                      ((*anim).fovTarget - (*camera).fov) *
                                          invKeyFrameTimer, (*camera).fov,
                                  (*(*anim).curKeyFrame).lerpStepScale,
                                  0.01f32);
            (*camera).roll =
                Camera_LERPFloorS(((*camera).roll as libc::c_int +
                                       ((*anim).rollTarget as libc::c_int -
                                            (*camera).roll as libc::c_int) as
                                           s16 as libc::c_int /
                                           (*anim).keyFrameTimer as
                                               libc::c_int) as s16,
                                  (*camera).roll,
                                  (*(*anim).curKeyFrame).lerpStepScale,
                                  0xa as libc::c_int as s16)
        }
        1872968636709110721 => {
            if (*camera).thisIdx as libc::c_int != 0 as libc::c_int {
                (*camera).timer = 0 as libc::c_int as s16
            }
        }
        _ => { }
    }
    *eye = *eyeNext;
    if (*(*anim).curKeyFrame).actionFlags as libc::c_int & 0x80 as libc::c_int
           != 0 {
        Camera_BGCheck(camera, at, eye);
    }
    if (*(*anim).curKeyFrame).actionFlags as libc::c_int & 0x40 as libc::c_int
           != 0 {
        // Set the player's position
        (*(*camera).player).actor.world.pos.x = (*anim).playerPos.x;
        (*(*camera).player).actor.world.pos.z = (*anim).playerPos.z;
        if (*(*camera).player).stateFlags1 &
               0x8000000 as libc::c_int as libc::c_uint != 0 &&
               (*player).currentBoots as libc::c_int !=
                   PLAYER_BOOTS_IRON as libc::c_int {
            (*(*camera).player).actor.world.pos.y = (*anim).playerPos.y
        }
    } else {
        (*anim).playerPos.x = playerPosRot.pos.x;
        (*anim).playerPos.y = playerPosRot.pos.y;
        (*anim).playerPos.z = playerPosRot.pos.z
    }
    if (*anim).unk_38 as libc::c_int == 0 as libc::c_int &&
           (*camera).timer as libc::c_int > 0 as libc::c_int {
        (*camera).timer -= 1
    }
    if !(*camera).player.is_null() {
        (*camera).posOffset.x = (*camera).at.x - (*camera).playerPosRot.pos.x;
        (*camera).posOffset.y = (*camera).at.y - (*camera).playerPosRot.pos.y;
        (*camera).posOffset.z = (*camera).at.z - (*camera).playerPosRot.pos.z
    }
    (*camera).dist = OLib_Vec3fDist(at, eye);
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_DebugPrintSplineArray(mut name:
                                                          *mut libc::c_char,
                                                      mut length: s16,
                                                      mut cameraPoints:
                                                          *mut CutsceneCameraPoint) {
    let mut i: s32 = 0;
    osSyncPrintf(b"static SplinedatZ  %s[] = {\n\x00" as *const u8 as
                     *const libc::c_char, name);
    i = 0 as libc::c_int;
    while i < length as libc::c_int {
        osSyncPrintf(b"    /* key frame %2d */ {\n\x00" as *const u8 as
                         *const libc::c_char, i);
        osSyncPrintf(b"    /*     code     */ %d,\n\x00" as *const u8 as
                         *const libc::c_char,
                     (*cameraPoints.offset(i as isize)).continueFlag as
                         libc::c_int);
        osSyncPrintf(b"    /*     z        */ %d,\n\x00" as *const u8 as
                         *const libc::c_char,
                     (*cameraPoints.offset(i as isize)).cameraRoll as
                         libc::c_int);
        osSyncPrintf(b"    /*     T        */ %d,\n\x00" as *const u8 as
                         *const libc::c_char,
                     (*cameraPoints.offset(i as isize)).nextPointFrame as
                         libc::c_int);
        osSyncPrintf(b"    /*     zoom     */ %f,\n\x00" as *const u8 as
                         *const libc::c_char,
                     (*cameraPoints.offset(i as isize)).viewAngle as
                         libc::c_double);
        osSyncPrintf(b"    /*     pos      */ { %d, %d, %d }\n\x00" as
                         *const u8 as *const libc::c_char,
                     (*cameraPoints.offset(i as isize)).pos.x as libc::c_int,
                     (*cameraPoints.offset(i as isize)).pos.y as libc::c_int,
                     (*cameraPoints.offset(i as isize)).pos.z as libc::c_int);
        osSyncPrintf(b"    },\n\x00" as *const u8 as *const libc::c_char);
        i += 1
    }
    osSyncPrintf(b"};\n\n\x00" as *const u8 as *const libc::c_char);
}
/* *
 * Copies `src` to `dst`, used in Camera_Demo1
 * Name from AC map: Camera2_SetPos_Demo
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Vec3fCopy(mut src: *mut Vec3f,
                                          mut dst: *mut Vec3f) {
    (*dst).x = (*src).x;
    (*dst).y = (*src).y;
    (*dst).z = (*src).z;
}
/* *
 * Calculates new position from `at` to `pos`, outputs to `dst
 * Name from AC map: Camera2_CalcPos_Demo
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_RotateAroundPoint(mut at: *mut PosRot,
                                                  mut pos: *mut Vec3f,
                                                  mut dst: *mut Vec3f) {
    let mut posSph: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut posCopy: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    Camera_Vec3fCopy(pos, &mut posCopy);
    OLib_Vec3fToVecSphGeo(&mut posSph, &mut posCopy);
    posSph.yaw =
        (posSph.yaw as libc::c_int + (*at).rot.y as libc::c_int) as s16;
    Camera_Vec3fVecSphGeoAdd(dst, &mut (*at).pos, &mut posSph);
}
/* *
 * Camera follows points specified at pointers to CutsceneCameraPoints,
 * camera->data0 for camera at positions, and camera->data1 for camera eye positions
 * until all keyFrames have been exhausted.
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Demo1(mut camera: *mut Camera) -> s32 {
    let mut pad: s32 = 0;
    let mut demo1: *mut Demo1 =
        (*camera).paramData.as_mut_ptr() as *mut Demo1;
    let mut values: *mut CameraModeValue = 0 as *mut CameraModeValue;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut csAtPoints: *mut CutsceneCameraPoint =
        (*camera).data0 as *mut CutsceneCameraPoint;
    let mut csEyePoints: *mut CutsceneCameraPoint =
        (*camera).data1 as *mut CutsceneCameraPoint;
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut curPlayerPosRot: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut csEyeUpdate: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut csAtUpdate: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut newRoll: f32_0 = 0.;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut cameraFOV: *mut f32_0 = &mut (*camera).fov;
    let mut relativeToPlayer: *mut s16 = &mut (*camera).data2;
    let mut anim: *mut Demo1Anim = &mut (*demo1).anim;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        values =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let fresh174 = values;
        values = values.offset(1);
        (*demo1).interfaceFlags = (*fresh174).val
    }
    sCameraInterfaceFlags = (*demo1).interfaceFlags as s32;
    let mut current_block_30: u64;
    match (*camera).animState as libc::c_int {
        0 => {
            // initalize camera state
            (*anim).keyframe = 0 as libc::c_int as s16;
            (*anim).curFrame = 0.0f32;
            (*camera).animState += 1;
            // "absolute" : "relative"
            osSyncPrintf(b"\x1b[1m%06u:\x1b[m camera: spline demo: start %s \n\x00"
                             as *const u8 as *const libc::c_char,
                         (*(*camera).globalCtx).state.frames,
                         if *relativeToPlayer as libc::c_int ==
                                0 as libc::c_int {
                             b"\xe7\xb5\xb6\xe5\xaf\xbe\x00" as *const u8 as
                                 *const libc::c_char
                         } else {
                             b"\xe7\x9b\xb8\xe5\xaf\xbe\x00" as *const u8 as
                                 *const libc::c_char
                         });
            if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                                      16 as libc::c_int + 93 as libc::c_int)
                                     as usize] != 0 {
                Camera_DebugPrintSplineArray(b"CENTER\x00" as *const u8 as
                                                 *const libc::c_char as
                                                 *mut libc::c_char,
                                             5 as libc::c_int as s16,
                                             csAtPoints);
                Camera_DebugPrintSplineArray(b"   EYE\x00" as *const u8 as
                                                 *const libc::c_char as
                                                 *mut libc::c_char,
                                             5 as libc::c_int as s16,
                                             csEyePoints);
            }
            current_block_30 = 490258784982539099;
        }
        1 => { current_block_30 = 490258784982539099; }
        _ => { current_block_30 = 7659304154607701039; }
    }
    match current_block_30 {
        490258784982539099 => {
            // follow CutsceneCameraPoints.  function returns 1 if at the end.
            if func_800BB2B4(&mut csEyeUpdate, &mut newRoll, cameraFOV,
                             csEyePoints, &mut (*anim).keyframe,
                             &mut (*anim).curFrame) != 0 ||
                   func_800BB2B4(&mut csAtUpdate, &mut newRoll, cameraFOV,
                                 csAtPoints, &mut (*anim).keyframe,
                                 &mut (*anim).curFrame) != 0 {
                (*camera).animState += 1
            }
            if *relativeToPlayer != 0 {
                // if the camera is set to be relative to the player, move the interpolated points
                // relative to the player's position
                if !(*camera).player.is_null() &&
                       (*(*camera).player).actor.update.is_some() {
                    Actor_GetWorld(&mut curPlayerPosRot,
                                   &mut (*(*camera).player).actor);
                    Camera_RotateAroundPoint(&mut curPlayerPosRot,
                                             &mut csEyeUpdate, eyeNext);
                    Camera_RotateAroundPoint(&mut curPlayerPosRot,
                                             &mut csAtUpdate, at);
                } else {
                    osSyncPrintf(b"\x1b[41;37mcamera: spline demo: owner dead\n\x1b[m\x00"
                                     as *const u8 as *const libc::c_char);
                }
            } else {
                // simply copy the interpolated values to the eye and at
                Camera_Vec3fCopy(&mut csEyeUpdate, eyeNext);
                Camera_Vec3fCopy(&mut csAtUpdate, at);
            }
            *eye = *eyeNext;
            (*camera).roll = (newRoll * 256.0f32) as s16;
            (*camera).dist = OLib_Vec3fDist(at, eye)
        }
        _ => { }
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Demo2(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
/* *
 * Opening large chests.
 * The camera position will be at a fixed point, and rotate around at different intervals.
 * The direction, and initial position is dependent on when the camera was started.
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Demo3(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye; // unused.
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut camPlayerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut eyeAtOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut eyeOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut atOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut sp74: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut sp68: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut sp5C: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut temp_f0: f32_0 = 0.;
    let mut pad: s32 = 0;
    let mut skipUpdateEye: u8_0 = 0 as libc::c_int as u8_0;
    let mut yOffset: f32_0 = Player_GetHeight((*camera).player);
    let mut angle: s16 = 0;
    let mut demo3: *mut Demo3 =
        (*camera).paramData.as_mut_ptr() as *mut Demo3;
    let mut anim: *mut Demo3Anim = &mut (*demo3).anim;
    let mut pad2: s32 = 0;
    (*camera).unk_14C =
        ((*camera).unk_14C as libc::c_int & !(0x10 as libc::c_int)) as s16;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let fresh175 = values;
        values = values.offset(1);
        (*demo3).fov = (*fresh175).val as f32_0;
        let fresh176 = values;
        values = values.offset(1);
        (*demo3).unk_04 = (*fresh176).val as f32_0;
        let fresh177 = values;
        values = values.offset(1);
        (*demo3).interfaceFlags = (*fresh177).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    OLib_Vec3fDiffToVecSphGeo(&mut eyeAtOffset, at, eye);
    sCameraInterfaceFlags = (*demo3).interfaceFlags as s32;
    let mut current_block_106: u64;
    match (*camera).animState as libc::c_int {
        0 => {
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int &
                     !(0x8 as libc::c_int | 0x4 as libc::c_int)) as s16;
            func_80043B60(camera);
            (*camera).fov = (*demo3).fov;
            (*anim).animFrame = 0 as libc::c_int as s16;
            (*camera).roll = (*anim).animFrame;
            (*anim).initialAt = (*camPlayerPosRot).pos;
            if (*camera).playerGroundY != -32000.0f32 {
                (*anim).initialAt.y = (*camera).playerGroundY
            }
            angle = (*camPlayerPosRot).rot.y;
            sp68.x = (*anim).initialAt.x + Math_SinS(angle) * 40.0f32;
            sp68.y = (*anim).initialAt.y + 40.0f32;
            sp68.z = (*anim).initialAt.z + Math_CosS(angle) * 40.0f32;
            if (*(*camera).globalCtx).state.frames &
                   1 as libc::c_int as libc::c_uint != 0 {
                angle = (angle as libc::c_int - 0x3fff as libc::c_int) as s16;
                (*anim).yawDir = 1 as libc::c_int as s16
            } else {
                angle = (angle as libc::c_int + 0x3fff as libc::c_int) as s16;
                (*anim).yawDir = -(1 as libc::c_int) as s16
            }
            sp74.x =
                sp68.x +
                    D_8011D658[1 as libc::c_int as usize].r *
                        Math_SinS(angle);
            sp74.y = (*anim).initialAt.y + 5.0f32;
            sp74.z =
                sp68.z +
                    D_8011D658[1 as libc::c_int as usize].r *
                        Math_CosS(angle);
            if Camera_BGCheck(camera, &mut sp68, &mut sp74) != 0 {
                (*anim).yawDir = -((*anim).yawDir as libc::c_int) as s16
            }
            OLib_Vec3fToVecSphGeo(&mut atOffset,
                                  &mut *D_8011D678.as_mut_ptr().offset(0 as
                                                                           libc::c_int
                                                                           as
                                                                           isize));
            atOffset.yaw =
                (atOffset.yaw as libc::c_int +
                     (*camPlayerPosRot).rot.y as libc::c_int) as s16;
            Camera_Vec3fVecSphGeoAdd(at, &mut (*anim).initialAt,
                                     &mut atOffset);
            eyeOffset.r = D_8011D658[0 as libc::c_int as usize].r;
            eyeOffset.pitch = D_8011D658[0 as libc::c_int as usize].pitch;
            eyeOffset.yaw =
                (D_8011D658[0 as libc::c_int as usize].yaw as libc::c_int *
                     (*anim).yawDir as libc::c_int +
                     (*camPlayerPosRot).rot.y as libc::c_int) as s16;
            (*anim).unk_0C = 1.0f32;
            current_block_106 = 12065775993741208975;
        }
        1 => {
            temp_f0 =
                ((*anim).animFrame as libc::c_int - 2 as libc::c_int) as
                    libc::c_float * (1.0f32 / 146.0f32);
            sp5C.x =
                D_8011D678[0 as libc::c_int as usize].x +
                    (D_8011D678[1 as libc::c_int as usize].x -
                         D_8011D678[0 as libc::c_int as usize].x) * temp_f0;
            sp5C.y =
                D_8011D678[0 as libc::c_int as usize].y +
                    (D_8011D678[1 as libc::c_int as usize].y -
                         D_8011D678[0 as libc::c_int as usize].y) * temp_f0;
            sp5C.z =
                D_8011D678[0 as libc::c_int as usize].z +
                    (D_8011D678[1 as libc::c_int as usize].z -
                         D_8011D678[0 as libc::c_int as usize].z) * temp_f0;
            OLib_Vec3fToVecSphGeo(&mut atOffset, &mut sp5C);
            atOffset.yaw =
                (atOffset.yaw as libc::c_int * (*anim).yawDir as libc::c_int +
                     (*camPlayerPosRot).rot.y as libc::c_int) as s16;
            Camera_Vec3fVecSphGeoAdd(at, &mut (*anim).initialAt,
                                     &mut atOffset);
            atOffset.r =
                D_8011D658[0 as libc::c_int as usize].r +
                    (D_8011D658[1 as libc::c_int as usize].r -
                         D_8011D658[0 as libc::c_int as usize].r) * temp_f0;
            atOffset.pitch =
                (D_8011D658[0 as libc::c_int as usize].pitch as libc::c_int +
                     ((D_8011D658[1 as libc::c_int as usize].pitch as
                           libc::c_int -
                           D_8011D658[0 as libc::c_int as usize].pitch as
                               libc::c_int) as s16 as libc::c_int as
                          libc::c_float * temp_f0) as s16 as libc::c_int) as
                    s16;
            atOffset.yaw =
                (D_8011D658[0 as libc::c_int as usize].yaw as libc::c_int +
                     ((D_8011D658[1 as libc::c_int as usize].yaw as
                           libc::c_int -
                           D_8011D658[0 as libc::c_int as usize].yaw as
                               libc::c_int) as s16 as libc::c_int as
                          libc::c_float * temp_f0) as s16 as libc::c_int) as
                    s16;
            eyeOffset.r = atOffset.r;
            eyeOffset.pitch = atOffset.pitch;
            eyeOffset.yaw =
                (atOffset.yaw as libc::c_int * (*anim).yawDir as libc::c_int +
                     (*camPlayerPosRot).rot.y as libc::c_int) as s16;
            (*anim).unk_0C -= 1.0f32 / 365.0f32;
            current_block_106 = 12065775993741208975;
        }
        2 => {
            temp_f0 =
                ((*anim).animFrame as libc::c_int - 0x94 as libc::c_int) as
                    libc::c_float * 0.1f32;
            sp5C.x =
                D_8011D678[1 as libc::c_int as usize].x +
                    (D_8011D678[2 as libc::c_int as usize].x -
                         D_8011D678[1 as libc::c_int as usize].x) * temp_f0;
            sp5C.y =
                D_8011D678[1 as libc::c_int as usize].y - yOffset +
                    (D_8011D678[2 as libc::c_int as usize].y -
                         (D_8011D678[1 as libc::c_int as usize].y - yOffset))
                        * temp_f0;
            sp5C.y += yOffset;
            sp5C.z =
                D_8011D678[1 as libc::c_int as usize].z +
                    (D_8011D678[2 as libc::c_int as usize].z -
                         D_8011D678[1 as libc::c_int as usize].z) * temp_f0;
            OLib_Vec3fToVecSphGeo(&mut atOffset, &mut sp5C);
            atOffset.yaw =
                (atOffset.yaw as libc::c_int * (*anim).yawDir as libc::c_int +
                     (*camPlayerPosRot).rot.y as libc::c_int) as s16;
            Camera_Vec3fVecSphGeoAdd(at, &mut (*anim).initialAt,
                                     &mut atOffset);
            atOffset.r =
                D_8011D658[1 as libc::c_int as usize].r +
                    (D_8011D658[2 as libc::c_int as usize].r -
                         D_8011D658[1 as libc::c_int as usize].r) * temp_f0;
            atOffset.pitch =
                (D_8011D658[1 as libc::c_int as usize].pitch as libc::c_int +
                     ((D_8011D658[2 as libc::c_int as usize].pitch as
                           libc::c_int -
                           D_8011D658[1 as libc::c_int as usize].pitch as
                               libc::c_int) as s16 as libc::c_int as
                          libc::c_float * temp_f0) as s16 as libc::c_int) as
                    s16;
            atOffset.yaw =
                (D_8011D658[1 as libc::c_int as usize].yaw as libc::c_int +
                     ((D_8011D658[2 as libc::c_int as usize].yaw as
                           libc::c_int -
                           D_8011D658[1 as libc::c_int as usize].yaw as
                               libc::c_int) as s16 as libc::c_int as
                          libc::c_float * temp_f0) as s16 as libc::c_int) as
                    s16;
            eyeOffset.r = atOffset.r;
            eyeOffset.pitch = atOffset.pitch;
            eyeOffset.yaw =
                (atOffset.yaw as libc::c_int * (*anim).yawDir as libc::c_int +
                     (*camPlayerPosRot).rot.y as libc::c_int) as s16;
            (*anim).unk_0C -= 0.04f32;
            current_block_106 = 12065775993741208975;
        }
        3 => {
            temp_f0 =
                ((*anim).animFrame as libc::c_int - 0x9f as libc::c_int) as
                    libc::c_float * (1.0f32 / 9.0f32);
            sp5C.x =
                D_8011D678[2 as libc::c_int as usize].x +
                    (D_8011D678[3 as libc::c_int as usize].x -
                         D_8011D678[2 as libc::c_int as usize].x) * temp_f0;
            sp5C.y =
                D_8011D678[2 as libc::c_int as usize].y +
                    (D_8011D678[3 as libc::c_int as usize].y -
                         D_8011D678[2 as libc::c_int as usize].y) * temp_f0;
            sp5C.y += yOffset;
            sp5C.z =
                D_8011D678[2 as libc::c_int as usize].z +
                    (D_8011D678[3 as libc::c_int as usize].z -
                         D_8011D678[2 as libc::c_int as usize].z) * temp_f0;
            OLib_Vec3fToVecSphGeo(&mut atOffset, &mut sp5C);
            atOffset.yaw =
                (atOffset.yaw as libc::c_int * (*anim).yawDir as libc::c_int +
                     (*camPlayerPosRot).rot.y as libc::c_int) as s16;
            Camera_Vec3fVecSphGeoAdd(at, &mut (*anim).initialAt,
                                     &mut atOffset);
            atOffset.r =
                D_8011D658[2 as libc::c_int as usize].r +
                    (D_8011D658[3 as libc::c_int as usize].r -
                         D_8011D658[2 as libc::c_int as usize].r) * temp_f0;
            atOffset.pitch =
                (D_8011D658[2 as libc::c_int as usize].pitch as libc::c_int +
                     ((D_8011D658[3 as libc::c_int as usize].pitch as
                           libc::c_int -
                           D_8011D658[2 as libc::c_int as usize].pitch as
                               libc::c_int) as s16 as libc::c_int as
                          libc::c_float * temp_f0) as s16 as libc::c_int) as
                    s16;
            atOffset.yaw =
                (D_8011D658[2 as libc::c_int as usize].yaw as libc::c_int +
                     ((D_8011D658[3 as libc::c_int as usize].yaw as
                           libc::c_int -
                           D_8011D658[2 as libc::c_int as usize].yaw as
                               libc::c_int) as s16 as libc::c_int as
                          libc::c_float * temp_f0) as s16 as libc::c_int) as
                    s16;
            eyeOffset.r = atOffset.r;
            eyeOffset.pitch = atOffset.pitch;
            eyeOffset.yaw =
                (atOffset.yaw as libc::c_int * (*anim).yawDir as libc::c_int +
                     (*camPlayerPosRot).rot.y as libc::c_int) as s16;
            (*anim).unk_0C += 4.0f32 / 45.0f32;
            current_block_106 = 12065775993741208975;
        }
        30 => {
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int | 0x400 as libc::c_int) as
                    s16;
            if (*camera).unk_14C as libc::c_int & 8 as libc::c_int != 0 {
                (*camera).animState = 4 as libc::c_int as s16
            }
            current_block_106 = 17408211522349833069;
        }
        10 | 20 => { current_block_106 = 17408211522349833069; }
        4 => {
            eyeOffset.r = 80.0f32;
            eyeOffset.pitch = 0 as libc::c_int as s16;
            eyeOffset.yaw = eyeAtOffset.yaw;
            (*anim).unk_0C = 0.1f32;
            sCameraInterfaceFlags = 0x3400 as libc::c_int;
            if !((((*anim).animFrame as libc::c_int) < 0 as libc::c_int ||
                      (*camera).xzSpeed > 0.001f32 ||
                      !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                      usize].press.button as
                            libc::c_int | !(0x8000 as libc::c_int)) ==
                          0 as libc::c_int ||
                      !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                      usize].press.button as
                            libc::c_int | !(0x4000 as libc::c_int)) ==
                          0 as libc::c_int ||
                      !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                      usize].press.button as
                            libc::c_int | !(0x2 as libc::c_int)) ==
                          0 as libc::c_int ||
                      !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                      usize].press.button as
                            libc::c_int | !(0x4 as libc::c_int)) ==
                          0 as libc::c_int ||
                      !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                      usize].press.button as
                            libc::c_int | !(0x8 as libc::c_int)) ==
                          0 as libc::c_int ||
                      !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                      usize].press.button as
                            libc::c_int | !(0x1 as libc::c_int)) ==
                          0 as libc::c_int ||
                      !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                      usize].press.button as
                            libc::c_int | !(0x10 as libc::c_int)) ==
                          0 as libc::c_int ||
                      !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                      usize].press.button as
                            libc::c_int | !(0x2000 as libc::c_int)) ==
                          0 as libc::c_int) &&
                     (*camera).unk_14C as libc::c_int & 8 as libc::c_int != 0)
               {
                current_block_106 = 14982401436832768797;
            } else { current_block_106 = 14538974875612732614; }
        }
        _ => { current_block_106 = 14538974875612732614; }
    }
    match current_block_106 {
        14538974875612732614 => {
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int | 0x14 as libc::c_int) as
                    s16;
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int & !(8 as libc::c_int)) as
                    s16;
            if ((*camera).prevCamDataIdx as libc::c_int) < 0 as libc::c_int {
                Camera_ChangeSettingFlags(camera, (*camera).prevSetting,
                                          2 as libc::c_int as s16);
            } else {
                Camera_ChangeDataIdx(camera, (*camera).prevCamDataIdx as s32);
                (*camera).prevCamDataIdx = -(1 as libc::c_int) as s16
            }
            sCameraInterfaceFlags = 0 as libc::c_int;
            current_block_106 = 14982401436832768797;
        }
        17408211522349833069 => {
            skipUpdateEye = 1 as libc::c_int as u8_0;
            current_block_106 = 12065775993741208975;
        }
        _ => { }
    }
    match current_block_106 {
        14982401436832768797 => { skipUpdateEye = 1 as libc::c_int as u8_0 }
        _ => { }
    }
    (*anim).animFrame += 1;
    if (*anim).animFrame as libc::c_int == 1 as libc::c_int {
        (*camera).animState = 0xa as libc::c_int as s16
    } else if (*anim).animFrame as libc::c_int == 2 as libc::c_int {
        (*camera).animState = 0x1 as libc::c_int as s16
    } else if (*anim).animFrame as libc::c_int == 0x94 as libc::c_int {
        (*camera).animState = 2 as libc::c_int as s16
    } else if (*anim).animFrame as libc::c_int == 0x9e as libc::c_int {
        (*camera).animState = 0x14 as libc::c_int as s16
    } else if (*anim).animFrame as libc::c_int == 0x9f as libc::c_int {
        (*camera).animState = 3 as libc::c_int as s16
    } else if (*anim).animFrame as libc::c_int == 0xa8 as libc::c_int {
        (*camera).animState = 0x1e as libc::c_int as s16
    } else if (*anim).animFrame as libc::c_int == 0xe4 as libc::c_int {
        (*camera).animState = 4 as libc::c_int as s16
    }
    if skipUpdateEye == 0 {
        eyeOffset.r =
            Camera_LERPCeilF(eyeOffset.r, eyeAtOffset.r, (*anim).unk_0C,
                             2.0f32);
        eyeOffset.pitch =
            Camera_LERPCeilS(eyeOffset.pitch, eyeAtOffset.pitch,
                             (*anim).unk_0C, 0xa as libc::c_int as s16);
        eyeOffset.yaw =
            Camera_LERPCeilS(eyeOffset.yaw, eyeAtOffset.yaw, (*anim).unk_0C,
                             0xa as libc::c_int as s16);
        Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut eyeOffset);
        *eye = *eyeNext
    }
    (*camera).dist = OLib_Vec3fDist(at, eye);
    (*camera).atLERPStepScale = 0.1f32;
    (*camera).posOffset.x = (*camera).at.x - (*camPlayerPosRot).pos.x;
    (*camera).posOffset.y = (*camera).at.y - (*camPlayerPosRot).pos.y;
    (*camera).posOffset.z = (*camera).at.z - (*camPlayerPosRot).pos.z;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Demo4(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
/* *
 * Sets up a cutscene for Camera_Uniq9
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Demo5(mut camera: *mut Camera) -> s32 {
    let mut eyeTargetDist: f32_0 = 0.;
    let mut sp90: f32_0 = 0.;
    let mut playerTargetGeo: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut eyePlayerGeo: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut sp78: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut playerhead: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut targethead: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut player: *mut Player = 0 as *mut Player;
    let mut sp4A: s16 = 0;
    let mut pad: s32 = 0;
    let mut temp_v0: s32 = 0;
    let mut t: s16 = 0;
    let mut pad2: s32 = 0;
    Actor_GetFocus(&mut playerhead, &mut (*(*camera).player).actor);
    player = (*camera).player;
    sCameraInterfaceFlags = 0x3200 as libc::c_int;
    if (*camera).target.is_null() || (*(*camera).target).update.is_none() {
        if (*camera).target.is_null() {
            osSyncPrintf(b"\x1b[43;30mcamera: warning: attention: target is not valid, stop!\n\x1b[m\x00"
                             as *const u8 as *const libc::c_char);
        }
        (*camera).target = 0 as *mut Actor;
        return 1 as libc::c_int
    }
    Actor_GetFocus(&mut (*camera).targetPosRot, (*camera).target);
    OLib_Vec3fDiffToVecSphGeo(&mut playerTargetGeo,
                              &mut (*camera).targetPosRot.pos,
                              &mut (*camera).playerPosRot.pos);
    D_8011D3AC = (*(*camera).target).category as s32;
    Actor_GetScreenPos((*camera).globalCtx, (*camera).target, &mut sp78.yaw,
                       &mut sp78.pitch);
    eyeTargetDist =
        OLib_Vec3fDist(&mut (*camera).targetPosRot.pos, &mut (*camera).eye);
    OLib_Vec3fDiffToVecSphGeo(&mut eyePlayerGeo, &mut playerhead.pos,
                              &mut (*camera).eyeNext);
    sp4A =
        (eyePlayerGeo.yaw as libc::c_int - playerTargetGeo.yaw as libc::c_int)
            as s16;
    if (*(*camera).target).category as libc::c_int ==
           ACTORCAT_PLAYER as libc::c_int {
        // camera is targeting a(the) player actor
        if eyePlayerGeo.r > 30.0f32 {
            D_8011D6AC[1 as libc::c_int as usize].timerInit =
                ((*camera).timer as libc::c_int - 1 as libc::c_int) as s16;
            D_8011D6AC[1 as libc::c_int as usize].atTargetInit.z =
                Rand_ZeroOne() * 10.0f32;
            D_8011D6AC[1 as libc::c_int as usize].eyeTargetInit.x =
                Rand_ZeroOne() * 10.0f32;
            let ref mut fresh178 =
                (*((*camera).paramData.as_mut_ptr() as
                       *mut Unique9OnePointCs)).keyFrames;
            *fresh178 = D_8011D6AC.as_mut_ptr();
            (*((*camera).paramData.as_mut_ptr() as
                   *mut Unique9OnePointCs)).keyFrameCnt =
                (::std::mem::size_of::<[OnePointCsFull; 3]>() as
                     libc::c_ulong).wrapping_div(::std::mem::size_of::<OnePointCsFull>()
                                                     as libc::c_ulong) as s32;
            if (*camera).parentCamIdx as libc::c_int != 0 as libc::c_int {
                let ref mut fresh179 =
                    (*((*camera).paramData.as_mut_ptr() as
                           *mut Unique9OnePointCs)).keyFrameCnt;
                *fresh179 -= 1
            } else {
                (*camera).timer =
                    ((*camera).timer as libc::c_int +
                         D_8011D6AC[2 as libc::c_int as usize].timerInit as
                             libc::c_int) as s16
            }
        } else {
            D_8011D724[1 as libc::c_int as usize].eyeTargetInit.x =
                Rand_ZeroOne() * 10.0f32;
            D_8011D724[1 as libc::c_int as usize].timerInit =
                ((*camera).timer as libc::c_int - 1 as libc::c_int) as s16;
            let ref mut fresh180 =
                (*((*camera).paramData.as_mut_ptr() as
                       *mut Unique9OnePointCs)).keyFrames;
            *fresh180 = D_8011D724.as_mut_ptr();
            (*((*camera).paramData.as_mut_ptr() as
                   *mut Unique9OnePointCs)).keyFrameCnt =
                (::std::mem::size_of::<[OnePointCsFull; 3]>() as
                     libc::c_ulong).wrapping_div(::std::mem::size_of::<OnePointCsFull>()
                                                     as libc::c_ulong) as s32;
            if (*camera).parentCamIdx as libc::c_int != 0 as libc::c_int {
                let ref mut fresh181 =
                    (*((*camera).paramData.as_mut_ptr() as
                           *mut Unique9OnePointCs)).keyFrameCnt;
                *fresh181 -= 1
            } else {
                (*camera).timer =
                    ((*camera).timer as libc::c_int +
                         D_8011D724[2 as libc::c_int as usize].timerInit as
                             libc::c_int) as s16
            }
        }
    } else if playerTargetGeo.r < 30.0f32 {
        // distance between player and target is less than 30 units.
        let ref mut fresh182 =
            (*((*camera).paramData.as_mut_ptr() as
                   *mut Unique9OnePointCs)).keyFrames;
        *fresh182 = D_8011D79C.as_mut_ptr();
        (*((*camera).paramData.as_mut_ptr() as
               *mut Unique9OnePointCs)).keyFrameCnt =
            (::std::mem::size_of::<[OnePointCsFull; 4]>() as
                 libc::c_ulong).wrapping_div(::std::mem::size_of::<OnePointCsFull>()
                                                 as libc::c_ulong) as s32;
        if (sp78.yaw as libc::c_int) < 0x15 as libc::c_int ||
               sp78.yaw as libc::c_int >= 0x12c as libc::c_int ||
               (sp78.pitch as libc::c_int) < 0x29 as libc::c_int ||
               sp78.pitch as libc::c_int >= 0xc8 as libc::c_int {
            D_8011D79C[0 as libc::c_int as usize].actionFlags =
                0x41 as libc::c_int as u8_0;
            D_8011D79C[0 as libc::c_int as usize].atTargetInit.y = -30.0f32;
            D_8011D79C[0 as libc::c_int as usize].atTargetInit.x = 0.0f32;
            D_8011D79C[0 as libc::c_int as usize].atTargetInit.z = 0.0f32;
            D_8011D79C[0 as libc::c_int as usize].eyeTargetInit.y = 0.0f32;
            D_8011D79C[0 as libc::c_int as usize].eyeTargetInit.x = 10.0f32;
            D_8011D79C[0 as libc::c_int as usize].eyeTargetInit.z = -50.0f32
        }
        D_8011D79C[1 as libc::c_int as usize].timerInit =
            ((*camera).timer as libc::c_int - 1 as libc::c_int) as s16;
        if (*camera).parentCamIdx as libc::c_int != 0 as libc::c_int {
            let ref mut fresh183 =
                (*((*camera).paramData.as_mut_ptr() as
                       *mut Unique9OnePointCs)).keyFrameCnt;
            *fresh183 -= 2 as libc::c_int
        } else {
            (*camera).timer =
                ((*camera).timer as libc::c_int +
                     (D_8011D79C[2 as libc::c_int as usize].timerInit as
                          libc::c_int +
                          D_8011D79C[3 as libc::c_int as usize].timerInit as
                              libc::c_int)) as s16
        }
    } else if eyeTargetDist < 300.0f32 && eyePlayerGeo.r < 30.0f32 {
        // distance from the camera's current positon and the target is less than 300 units
        // and the distance fromthe camera's current position to the player is less than 30 units
        D_8011D83C[0 as libc::c_int as usize].timerInit = (*camera).timer;
        let ref mut fresh184 =
            (*((*camera).paramData.as_mut_ptr() as
                   *mut Unique9OnePointCs)).keyFrames;
        *fresh184 = D_8011D83C.as_mut_ptr();
        (*((*camera).paramData.as_mut_ptr() as
               *mut Unique9OnePointCs)).keyFrameCnt =
            (::std::mem::size_of::<[OnePointCsFull; 2]>() as
                 libc::c_ulong).wrapping_div(::std::mem::size_of::<OnePointCsFull>()
                                                 as libc::c_ulong) as s32;
        if (*camera).parentCamIdx as libc::c_int != 0 as libc::c_int {
            let ref mut fresh185 =
                (*((*camera).paramData.as_mut_ptr() as
                       *mut Unique9OnePointCs)).keyFrameCnt;
            *fresh185 -= 1
        } else {
            (*camera).timer =
                ((*camera).timer as libc::c_int +
                     D_8011D83C[1 as libc::c_int as usize].timerInit as
                         libc::c_int) as s16
        }
    } else if eyeTargetDist < 700.0f32 &&
                  (if sp4A as libc::c_int >= 0 as libc::c_int {
                       sp4A as libc::c_int
                   } else { -(sp4A as libc::c_int) }) < 0x36b0 as libc::c_int
     {
        // The distance between the camera's current position and the target is less than 700 units
        // and the angle between the camera's position and the player, and the player to the target
        // is less than ~76.9 degrees
        if sp78.yaw as libc::c_int >= 0x15 as libc::c_int &&
               (sp78.yaw as libc::c_int) < 0x12c as libc::c_int &&
               sp78.pitch as libc::c_int >= 0x29 as libc::c_int &&
               (sp78.pitch as libc::c_int) < 0xc8 as libc::c_int &&
               eyePlayerGeo.r > 30.0f32 {
            D_8011D88C[0 as libc::c_int as usize].timerInit = (*camera).timer;
            let ref mut fresh186 =
                (*((*camera).paramData.as_mut_ptr() as
                       *mut Unique9OnePointCs)).keyFrames;
            *fresh186 = D_8011D88C.as_mut_ptr();
            (*((*camera).paramData.as_mut_ptr() as
                   *mut Unique9OnePointCs)).keyFrameCnt =
                (::std::mem::size_of::<[OnePointCsFull; 2]>() as
                     libc::c_ulong).wrapping_div(::std::mem::size_of::<OnePointCsFull>()
                                                     as libc::c_ulong) as s32;
            if (*camera).parentCamIdx as libc::c_int != 0 as libc::c_int {
                let ref mut fresh187 =
                    (*((*camera).paramData.as_mut_ptr() as
                           *mut Unique9OnePointCs)).keyFrameCnt;
                *fresh187 -= 1
            } else {
                (*camera).timer =
                    ((*camera).timer as libc::c_int +
                         D_8011D88C[1 as libc::c_int as usize].timerInit as
                             libc::c_int) as s16
            }
        } else {
            D_8011D8DC[0 as libc::c_int as usize].atTargetInit.z =
                eyeTargetDist * 0.6f32;
            D_8011D8DC[0 as libc::c_int as usize].eyeTargetInit.z =
                eyeTargetDist + 50.0f32;
            D_8011D8DC[0 as libc::c_int as usize].eyeTargetInit.x =
                Rand_ZeroOne() * 10.0f32;
            if (eyePlayerGeo.yaw as libc::c_int -
                    playerTargetGeo.yaw as libc::c_int) as s16 as libc::c_int
                   > 0 as libc::c_int {
                D_8011D8DC[0 as libc::c_int as usize].atTargetInit.x =
                    -D_8011D8DC[0 as libc::c_int as usize].atTargetInit.x;
                D_8011D8DC[0 as libc::c_int as usize].eyeTargetInit.x =
                    -D_8011D8DC[0 as libc::c_int as usize].eyeTargetInit.x;
                D_8011D8DC[0 as libc::c_int as usize].rollTargetInit =
                    -(D_8011D8DC[0 as libc::c_int as usize].rollTargetInit as
                          libc::c_int) as s16
            }
            D_8011D8DC[0 as libc::c_int as usize].timerInit = (*camera).timer;
            D_8011D8DC[1 as libc::c_int as usize].timerInit =
                ((eyeTargetDist * 0.005f32) as s16 as libc::c_int +
                     8 as libc::c_int) as s16;
            let ref mut fresh188 =
                (*((*camera).paramData.as_mut_ptr() as
                       *mut Unique9OnePointCs)).keyFrames;
            *fresh188 = D_8011D8DC.as_mut_ptr();
            (*((*camera).paramData.as_mut_ptr() as
                   *mut Unique9OnePointCs)).keyFrameCnt =
                (::std::mem::size_of::<[OnePointCsFull; 3]>() as
                     libc::c_ulong).wrapping_div(::std::mem::size_of::<OnePointCsFull>()
                                                     as libc::c_ulong) as s32;
            if (*camera).parentCamIdx as libc::c_int != 0 as libc::c_int {
                let ref mut fresh189 =
                    (*((*camera).paramData.as_mut_ptr() as
                           *mut Unique9OnePointCs)).keyFrameCnt;
                *fresh189 -= 2 as libc::c_int
            } else {
                (*camera).timer =
                    ((*camera).timer as libc::c_int +
                         (D_8011D8DC[1 as libc::c_int as usize].timerInit as
                              libc::c_int +
                              D_8011D8DC[2 as libc::c_int as usize].timerInit
                                  as libc::c_int)) as s16
            }
        }
    } else if (*(*camera).target).category as libc::c_int ==
                  ACTORCAT_DOOR as libc::c_int {
        // the target is a door.
        D_8011D954[0 as libc::c_int as usize].timerInit =
            ((*camera).timer as libc::c_int - 5 as libc::c_int) as s16;
        sp4A = 0 as libc::c_int as s16;
        if func_800C0D34((*camera).globalCtx, (*camera).target, &mut sp4A) ==
               0 {
            osSyncPrintf(b"\x1b[43;30mcamera: attention demo: this door is dummy door!\n\x1b[m\x00"
                             as *const u8 as *const libc::c_char);
            if (if playerTargetGeo.yaw as libc::c_int -
                       (*(*camera).target).shape.rot.y as libc::c_int >=
                       0 as libc::c_int {
                    (playerTargetGeo.yaw as libc::c_int) -
                        (*(*camera).target).shape.rot.y as libc::c_int
                } else {
                    -(playerTargetGeo.yaw as libc::c_int -
                          (*(*camera).target).shape.rot.y as libc::c_int)
                }) >= 0x4000 as libc::c_int {
                sp4A = (*(*camera).target).shape.rot.y
            } else {
                sp4A =
                    ((*(*camera).target).shape.rot.y as libc::c_int -
                         0x7fff as libc::c_int) as s16
            }
        }
        D_8011D954[1 as libc::c_int as usize].atTargetInit.y =
            if (*(*camera).target).shape.rot.y as libc::c_int ==
                   sp4A as libc::c_int {
                180.0f32
            } else { 0.0f32 };
        D_8011D954[0 as libc::c_int as usize].eyeTargetInit.y =
            D_8011D954[1 as libc::c_int as usize].atTargetInit.y;
        D_8011D954[0 as libc::c_int as usize].atTargetInit.y =
            D_8011D954[0 as libc::c_int as usize].eyeTargetInit.y;
        sp90 =
            (if ((playerTargetGeo.yaw as libc::c_int - sp4A as libc::c_int) as
                     s16 as libc::c_int) < 0 as libc::c_int {
                 20.0f32
             } else { -20.0f32 }) * Rand_ZeroOne();
        D_8011D954[0 as libc::c_int as usize].eyeTargetInit.y =
            (*D_8011D954.as_mut_ptr()).eyeTargetInit.y + sp90;
        temp_v0 = (Rand_ZeroOne() * (sp90 * -0.2f32)) as s32;
        D_8011D954[1 as libc::c_int as usize].rollTargetInit = temp_v0 as s16;
        D_8011D954[0 as libc::c_int as usize].rollTargetInit = temp_v0 as s16;
        Actor_GetFocus(&mut targethead, (*camera).target);
        targethead.pos.x +=
            50.0f32 *
                Math_SinS((sp4A as libc::c_int - 0x7fff as libc::c_int) as
                              s16);
        targethead.pos.z +=
            50.0f32 *
                Math_CosS((sp4A as libc::c_int - 0x7fff as libc::c_int) as
                              s16);
        if Camera_BGCheck(camera, &mut playerhead.pos, &mut targethead.pos) !=
               0 {
            D_8011D954[1 as libc::c_int as usize].actionFlags =
                0xc1 as libc::c_int as u8_0;
            D_8011D954[2 as libc::c_int as usize].actionFlags =
                0x8f as libc::c_int as u8_0
        } else {
            D_8011D954[2 as libc::c_int as usize].timerInit =
                ((eyeTargetDist * 0.004f32) as s16 as libc::c_int +
                     6 as libc::c_int) as s16
        }
        let ref mut fresh190 =
            (*((*camera).paramData.as_mut_ptr() as
                   *mut Unique9OnePointCs)).keyFrames;
        *fresh190 = D_8011D954.as_mut_ptr();
        (*((*camera).paramData.as_mut_ptr() as
               *mut Unique9OnePointCs)).keyFrameCnt =
            (::std::mem::size_of::<[OnePointCsFull; 4]>() as
                 libc::c_ulong).wrapping_div(::std::mem::size_of::<OnePointCsFull>()
                                                 as libc::c_ulong) as s32;
        if (*camera).parentCamIdx as libc::c_int != 0 as libc::c_int {
            let ref mut fresh191 =
                (*((*camera).paramData.as_mut_ptr() as
                       *mut Unique9OnePointCs)).keyFrameCnt;
            *fresh191 -= 2 as libc::c_int
        } else {
            (*camera).timer =
                ((*camera).timer as libc::c_int +
                     (D_8011D954[2 as libc::c_int as usize].timerInit as
                          libc::c_int +
                          D_8011D954[3 as libc::c_int as usize].timerInit as
                              libc::c_int)) as s16
        }
    } else {
        if playerTargetGeo.r < 200.0f32 {
            D_8011D9F4[0 as libc::c_int as usize].eyeTargetInit.z =
                playerTargetGeo.r;
            D_8011D9F4[0 as libc::c_int as usize].atTargetInit.z =
                playerTargetGeo.r * 0.25f32
        }
        if playerTargetGeo.r < 400.0f32 {
            D_8011D9F4[0 as libc::c_int as usize].eyeTargetInit.x =
                Rand_ZeroOne() * 25.0f32
        }
        Player_GetHeight((*camera).player);
        D_8011D9F4[0 as libc::c_int as usize].timerInit = (*camera).timer;
        Actor_GetFocus(&mut targethead, (*camera).target);
        if Camera_BGCheck(camera, &mut playerhead.pos, &mut targethead.pos) !=
               0 {
            D_8011D9F4[1 as libc::c_int as usize].timerInit =
                4 as libc::c_int as s16;
            D_8011D9F4[1 as libc::c_int as usize].actionFlags =
                0x8f as libc::c_int as u8_0
        } else {
            t = (eyeTargetDist * 0.005f32) as s16;
            D_8011D9F4[1 as libc::c_int as usize].timerInit =
                (t as libc::c_int + 8 as libc::c_int) as s16
        }
        let ref mut fresh192 =
            (*((*camera).paramData.as_mut_ptr() as
                   *mut Unique9OnePointCs)).keyFrames;
        *fresh192 = D_8011D9F4.as_mut_ptr();
        (*((*camera).paramData.as_mut_ptr() as
               *mut Unique9OnePointCs)).keyFrameCnt =
            (::std::mem::size_of::<[OnePointCsFull; 3]>() as
                 libc::c_ulong).wrapping_div(::std::mem::size_of::<OnePointCsFull>()
                                                 as libc::c_ulong) as s32;
        if (*camera).parentCamIdx as libc::c_int != 0 as libc::c_int {
            if (*(*camera).globalCtx).state.frames &
                   1 as libc::c_int as libc::c_uint != 0 {
                D_8011D9F4[0 as libc::c_int as usize].rollTargetInit =
                    -(D_8011D9F4[0 as libc::c_int as usize].rollTargetInit as
                          libc::c_int) as s16;
                D_8011D9F4[1 as libc::c_int as usize].rollTargetInit =
                    -(D_8011D9F4[1 as libc::c_int as usize].rollTargetInit as
                          libc::c_int) as s16
            }
            let ref mut fresh193 =
                (*((*camera).paramData.as_mut_ptr() as
                       *mut Unique9OnePointCs)).keyFrameCnt;
            *fresh193 -= 2 as libc::c_int
        } else {
            (*camera).timer =
                ((*camera).timer as libc::c_int +
                     (D_8011D9F4[1 as libc::c_int as usize].timerInit as
                          libc::c_int +
                          D_8011D9F4[2 as libc::c_int as usize].timerInit as
                              libc::c_int)) as s16;
            D_8011D9F4[1 as libc::c_int as usize].rollTargetInit =
                0 as libc::c_int as s16;
            D_8011D9F4[0 as libc::c_int as usize].rollTargetInit =
                D_8011D9F4[1 as libc::c_int as usize].rollTargetInit
        }
    }
    pad =
        (sDemo5PrevSfxFrame as
             libc::c_uint).wrapping_sub((*(*camera).globalCtx).state.frames)
            as s32;
    if pad >= 0x33 as libc::c_int || pad < -(0x32 as libc::c_int) {
        func_80078884((*camera).data1 as u16_0);
    }
    sDemo5PrevSfxFrame = (*(*camera).globalCtx).state.frames as s32;
    if (*(*camera).player).stateFlags1 &
           0x8000000 as libc::c_int as libc::c_uint != 0 &&
           (*player).currentBoots as libc::c_int !=
               PLAYER_BOOTS_IRON as libc::c_int {
        // swimming, and not iron boots
        (*player).stateFlags1 |= 0x20000000 as libc::c_int as libc::c_uint;
        // env frozen
        (*player).actor.freezeTimer = (*camera).timer as u16_0
    } else {
        sp4A =
            (playerhead.rot.y as libc::c_int -
                 playerTargetGeo.yaw as libc::c_int) as s16;
        if (*(*camera).target).category as libc::c_int ==
               ACTORCAT_PLAYER as libc::c_int {
            pad =
                (*(*camera).globalCtx).state.frames.wrapping_sub(sDemo5PrevAction12Frame
                                                                     as
                                                                     libc::c_uint)
                    as s32;
            if (*player).stateFlags1 & 0x800 as libc::c_int as libc::c_uint !=
                   0 {
                // holding object over head.
                func_8002DF54((*camera).globalCtx, (*camera).target,
                              8 as libc::c_int as u8_0);
            } else if (if pad >= 0 as libc::c_int { pad } else { -pad }) >
                          3000 as libc::c_int {
                func_8002DF54((*camera).globalCtx, (*camera).target,
                              12 as libc::c_int as u8_0);
            } else {
                func_8002DF54((*camera).globalCtx, (*camera).target,
                              69 as libc::c_int as u8_0);
            }
        } else {
            func_8002DF54((*camera).globalCtx, (*camera).target,
                          1 as libc::c_int as u8_0);
        }
    }
    sDemo5PrevAction12Frame = (*(*camera).globalCtx).state.frames as s32;
    Camera_ChangeSettingFlags(camera, CAM_SET_CS_C as libc::c_int as s16,
                              (4 as libc::c_int | 1 as libc::c_int) as s16);
    Camera_Unique9(camera);
    return 1 as libc::c_int;
}
/* *
 * Used in Forest Temple when poes are defeated, follows the flames to the torches.
 * Fixed position, rotates to follow the target
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Demo6(mut camera: *mut Camera) -> s32 {
    let mut mainCam: *mut Camera = 0 as *mut Camera;
    let mut anim: *mut Demo6Anim =
        &mut (*((*camera).paramData.as_mut_ptr() as *mut Demo6)).anim as
            *mut Demo6Anim;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut values: *mut CameraModeValue = 0 as *mut CameraModeValue;
    let mut eyeOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut camFocus: *mut Actor = 0 as *mut Actor;
    let mut focusPosRot: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut stateTimers: [s16; 4] = [0; 4];
    let mut at: *mut Vec3f = &mut (*camera).at;
    mainCam =
        Gameplay_GetCamera((*camera).globalCtx, 0 as libc::c_int as s16);
    camFocus = (*camera).target;
    stateTimers[1 as libc::c_int as usize] = 0x37 as libc::c_int as s16;
    stateTimers[2 as libc::c_int as usize] = 0x46 as libc::c_int as s16;
    stateTimers[3 as libc::c_int as usize] = 0x5a as libc::c_int as s16;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        values =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let fresh194 = values;
        values = values.offset(1);
        (*((*camera).paramData.as_mut_ptr() as *mut Demo6)).interfaceFlags =
            (*fresh194).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    let mut current_block_38: u64;
    match (*camera).animState as libc::c_int {
        0 => {
            // initalizes the camera state.
            (*anim).animTimer = 0 as libc::c_int as s16;
            (*camera).fov = 60.0f32;
            Actor_GetWorld(&mut focusPosRot, camFocus);
            (*camera).at.x = focusPosRot.pos.x;
            (*camera).at.y = focusPosRot.pos.y + 20.0f32;
            (*camera).at.z = focusPosRot.pos.z;
            eyeOffset.r = 200.0f32;
            // 0x7D0 ~10.99 degrees
            eyeOffset.yaw =
                (Camera_XZAngle(&mut focusPosRot.pos,
                                &mut (*mainCam).playerPosRot.pos) as
                     libc::c_int + 0x7d0 as libc::c_int) as s16;
            // -0x3E8 ~5.49 degrees
            eyeOffset.pitch = -(0x3e8 as libc::c_int) as s16;
            Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut eyeOffset);
            (*camera).eye = *eyeNext;
            (*camera).animState += 1;
            current_block_38 = 6352833200186027269;
        }
        1 => { current_block_38 = 6352833200186027269; }
        2 => { current_block_38 = 6479993889776210843; }
        3 => { current_block_38 = 3309978060059975247; }
        _ => { current_block_38 = 1356832168064818221; }
    }
    match current_block_38 {
        6352833200186027269 => {
            if (stateTimers[(*camera).animState as usize] as libc::c_int) <
                   (*anim).animTimer as libc::c_int {
                func_8002DF54((*camera).globalCtx,
                              &mut (*(*camera).player).actor,
                              8 as libc::c_int as u8_0);
                Actor_GetWorld(&mut focusPosRot, camFocus);
                (*anim).atTarget.x = focusPosRot.pos.x;
                (*anim).atTarget.y = focusPosRot.pos.y - 20.0f32;
                (*anim).atTarget.z = focusPosRot.pos.z;
                (*camera).animState += 1;
                current_block_38 = 6479993889776210843;
            } else { current_block_38 = 1356832168064818221; }
        }
        _ => { }
    }
    match current_block_38 {
        6479993889776210843 => {
            Camera_LERPCeilVec3f(&mut (*anim).atTarget, at, 0.1f32, 0.1f32,
                                 8.0f32);
            if (stateTimers[(*camera).animState as usize] as libc::c_int) <
                   (*anim).animTimer as libc::c_int {
                (*camera).animState += 1;
                current_block_38 = 3309978060059975247;
            } else { current_block_38 = 1356832168064818221; }
        }
        _ => { }
    }
    match current_block_38 {
        3309978060059975247 => {
            (*camera).fov =
                Camera_LERPCeilF(50.0f32, (*camera).fov, 0.2f32, 0.01f32);
            if (stateTimers[(*camera).animState as usize] as libc::c_int) <
                   (*anim).animTimer as libc::c_int {
                (*camera).timer = 0 as libc::c_int as s16;
                return 1 as libc::c_int
            }
        }
        _ => { }
    }
    (*anim).animTimer += 1;
    Actor_GetWorld(&mut focusPosRot, camFocus);
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Demo7(mut camera: *mut Camera) -> s32 {
    if (*camera).animState as libc::c_int == 0 as libc::c_int {
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int & !(4 as libc::c_int)) as s16;
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int | 0x1000 as libc::c_int) as s16;
        (*camera).animState += 1
    }
    panic!("Reached end of non-void function without returning");
    // ! @bug doesn't return
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Demo8(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
/* *
 * Camera follows points specified by demo9.atPoints and demo9.eyePoints, allows finer control
 * over the final eye and at points than Camera_Demo1, by allowing the interpolated at and eye points
 * to be relative to the main camera's player, the current camera's player, or the main camera's target
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Demo9(mut camera: *mut Camera) -> s32 {
    let mut pad: s32 = 0;
    let mut finishAction: s32 = 0;
    let mut onePointTimer: s16 = 0;
    let mut demo9OnePoint: *mut Demo9OnePointCs =
        (*camera).paramData.as_mut_ptr() as *mut Demo9OnePointCs;
    let mut csEyeUpdate: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut csAtUpdate: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut newEye: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut newAt: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut newRoll: f32_0 = 0.;
    let mut values: *mut CameraModeValue = 0 as *mut CameraModeValue;
    let mut mainCam: *mut Camera = 0 as *mut Camera;
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut mainCamPlayerPosRot: *mut PosRot = 0 as *mut PosRot;
    let mut focusPosRot: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut pad3: s32 = 0;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut demo9: *mut Demo9 = &mut (*demo9OnePoint).demo9;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut camFOV: *mut f32_0 = &mut (*camera).fov;
    let mut anim: *mut Demo9Anim = &mut (*demo9).anim;
    mainCam =
        Gameplay_GetCamera((*camera).globalCtx, 0 as libc::c_int as s16);
    mainCamPlayerPosRot = &mut (*mainCam).playerPosRot;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        values =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let fresh195 = values;
        values = values.offset(1);
        (*demo9).interfaceFlags = (*fresh195).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    sCameraInterfaceFlags = (*demo9).interfaceFlags as s32;
    let mut current_block_71: u64;
    match (*camera).animState as libc::c_int {
        0 => {
            // initalize the camera state
            (*anim).keyframe = 0 as libc::c_int as s16;
            (*anim).finishAction = 0 as libc::c_int as s16;
            (*anim).curFrame = 0.0f32;
            (*camera).animState += 1;
            (*anim).doLERPAt = 0 as libc::c_int as s16;
            finishAction =
                (*demo9OnePoint).onePointCs.actionParameters as libc::c_int &
                    0xf000 as libc::c_int;
            if finishAction != 0 as libc::c_int {
                (*anim).finishAction = finishAction as s16;
                // Clear finish parameters
                (*demo9OnePoint).onePointCs.actionParameters =
                    ((*demo9OnePoint).onePointCs.actionParameters as
                         libc::c_int & 0xfff as libc::c_int) as s16
            }
            (*anim).animTimer = (*demo9OnePoint).onePointCs.initTimer;
            current_block_71 = 147318819208827315;
        }
        1 => { current_block_71 = 147318819208827315; }
        3 => { current_block_71 = 11840830062664830704; }
        2 => {
            // standby while the timer finishes, change the animState to finish when
            // the timer runs out.
            (*anim).animTimer -= 1;
            if ((*anim).animTimer as libc::c_int) < 0 as libc::c_int {
                (*camera).animState += 1
            }
            current_block_71 = 2472048668343472511;
        }
        4 | _ => { current_block_71 = 2472048668343472511; }
    }
    match current_block_71 {
        147318819208827315 =>
        // Run the camera state
        {
            if (*anim).animTimer as libc::c_int > 0 as libc::c_int {
                // if the animation timer is still running, run the demo logic
                // if it is not, then the case will fallthrough to the finish logic.
                // Run the at and eye cs interpoloation functions, if either of them return 1 (that no more points
                // exist) change the animation state to 2 (standby)
                if func_800BB2B4(&mut csEyeUpdate, &mut newRoll, camFOV,
                                 (*demo9OnePoint).onePointCs.eyePoints,
                                 &mut (*anim).keyframe, &mut (*anim).curFrame)
                       != 0 as libc::c_int ||
                       func_800BB2B4(&mut csAtUpdate, &mut newRoll, camFOV,
                                     (*demo9OnePoint).onePointCs.atPoints,
                                     &mut (*anim).keyframe,
                                     &mut (*anim).curFrame) !=
                           0 as libc::c_int {
                    (*camera).animState = 2 as libc::c_int as s16
                }
                if (*demo9OnePoint).onePointCs.actionParameters as libc::c_int
                       == 1 as libc::c_int {
                    // rotate around mainCam's player
                    Camera_RotateAroundPoint(mainCamPlayerPosRot,
                                             &mut csEyeUpdate, &mut newEye);
                    Camera_RotateAroundPoint(mainCamPlayerPosRot,
                                             &mut csAtUpdate, &mut newAt);
                } else if (*demo9OnePoint).onePointCs.actionParameters as
                              libc::c_int == 4 as libc::c_int {
                    // rotate around the current camera's player
                    Actor_GetWorld(&mut focusPosRot,
                                   &mut (*(*camera).player).actor);
                    Camera_RotateAroundPoint(&mut focusPosRot,
                                             &mut csEyeUpdate, &mut newEye);
                    Camera_RotateAroundPoint(&mut focusPosRot,
                                             &mut csAtUpdate, &mut newAt);
                } else if (*demo9OnePoint).onePointCs.actionParameters as
                              libc::c_int == 8 as libc::c_int {
                    // rotate around the current camera's target
                    if !(*camera).target.is_null() &&
                           (*(*camera).target).update.is_some() {
                        Actor_GetWorld(&mut focusPosRot, (*camera).target);
                        Camera_RotateAroundPoint(&mut focusPosRot,
                                                 &mut csEyeUpdate,
                                                 &mut newEye);
                        Camera_RotateAroundPoint(&mut focusPosRot,
                                                 &mut csAtUpdate, &mut newAt);
                    } else {
                        (*camera).target = 0 as *mut Actor;
                        newEye = *eye;
                        newAt = *at
                    }
                } else {
                    // simple copy
                    Camera_Vec3fCopy(&mut csEyeUpdate, &mut newEye);
                    Camera_Vec3fCopy(&mut csAtUpdate, &mut newAt);
                }
                *eyeNext = newEye;
                *eye = *eyeNext;
                if (*anim).doLERPAt != 0 {
                    Camera_LERPCeilVec3f(&mut newAt, at, 0.5f32, 0.5f32,
                                         0.1f32);
                } else {
                    *at = newAt;
                    (*anim).doLERPAt = 1 as libc::c_int as s16
                }
                (*camera).roll = (newRoll * 256.0f32) as s16;
                (*anim).animTimer -= 1;
                current_block_71 = 2472048668343472511;
            } else { current_block_71 = 11840830062664830704; }
        }
        _ => { }
    }
    match current_block_71 {
        11840830062664830704 => {
            // the cs is finished, decide the next action
            (*camera).timer = 0 as libc::c_int as s16;
            if (*anim).finishAction as libc::c_int != 0 as libc::c_int {
                if (*anim).finishAction as libc::c_int !=
                       0x1000 as libc::c_int {
                    if (*anim).finishAction as libc::c_int ==
                           0x2000 as libc::c_int {
                        // finish action = 0x2000, run OnePointCs 0x3FC (Dramatic Return to Link)
                        onePointTimer =
                            if ((*demo9OnePoint).onePointCs.initTimer as
                                    libc::c_int) < 50 as libc::c_int {
                                5 as libc::c_int
                            } else {
                                ((*demo9OnePoint).onePointCs.initTimer as
                                     libc::c_int) / 5 as libc::c_int
                            } as s16;
                        OnePointCutscene_Init((*camera).globalCtx,
                                              1020 as libc::c_int as s16,
                                              onePointTimer, 0 as *mut Actor,
                                              (*camera).parentCamIdx);
                    }
                } else {
                    // finish action = 0x1000, copy the current camera's values to the
                    // default camera.
                    Camera_Copy(mainCam, camera);
                }
            }
        }
        _ => { }
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Demo0(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Special0(mut camera: *mut Camera) -> s32 {
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut spec0: *mut Special0 =
        (*camera).paramData.as_mut_ptr() as *mut Special0;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let fresh196 = values;
        values = values.offset(1);
        (*spec0).lerpAtScale =
            (*fresh196).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh197 = values;
        values = values.offset(1);
        (*spec0).interfaceFlags = (*fresh197).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    sCameraInterfaceFlags = (*spec0).interfaceFlags as s32;
    if (*camera).animState as libc::c_int == 0 as libc::c_int {
        (*camera).animState += 1
    }
    if (*camera).target.is_null() || (*(*camera).target).update.is_none() {
        if (*camera).target.is_null() {
            osSyncPrintf(b"\x1b[43;30mcamera: warning: circle: target is not valid, stop!\n\x1b[m\x00"
                             as *const u8 as *const libc::c_char);
        }
        (*camera).target = 0 as *mut Actor;
        return 1 as libc::c_int
    }
    Actor_GetFocus(&mut (*camera).targetPosRot, (*camera).target);
    Camera_LERPCeilVec3f(&mut (*camera).targetPosRot.pos, &mut (*camera).at,
                         (*spec0).lerpAtScale, (*spec0).lerpAtScale, 0.1f32);
    (*camera).posOffset.x = (*camera).at.x - (*playerPosRot).pos.x;
    (*camera).posOffset.y = (*camera).at.y - (*playerPosRot).pos.y;
    (*camera).posOffset.z = (*camera).at.z - (*playerPosRot).pos.z;
    (*camera).dist = OLib_Vec3fDist(&mut (*camera).at, &mut (*camera).eye);
    (*camera).xzSpeed = 0.0f32;
    if (*camera).timer as libc::c_int > 0 as libc::c_int {
        (*camera).timer -= 1
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Special1(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Special2(mut camera: *mut Camera) -> s32 {
    return Camera_Unique2(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Special3(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Special4(mut camera: *mut Camera) -> s32 {
    let mut curTargetPosRot: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut sp3A: s16 = 0;
    let mut timer: *mut s16 = &mut (*camera).timer;
    let mut spec4: *mut Special4 =
        (*camera).paramData.as_mut_ptr() as *mut Special4;
    if (*camera).animState as libc::c_int == 0 as libc::c_int {
        sCameraInterfaceFlags = 0x3200 as libc::c_int;
        (*camera).fov = 40.0f32;
        (*camera).animState += 1;
        (*spec4).initalTimer = (*camera).timer
    }
    (*camera).fov =
        Camera_LERPCeilF(80.0f32, (*camera).fov,
                         1.0f32 / *timer as libc::c_int as libc::c_float,
                         0.1f32);
    if ((*spec4).initalTimer as libc::c_int - *timer as libc::c_int) <
           0xf as libc::c_int {
        *timer -= 1;
        return 0 as libc::c_int
    } else {
        (*camera).roll = -(0x1f4 as libc::c_int) as s16;
        Actor_GetWorld(&mut curTargetPosRot, (*camera).target);
        (*camera).at = curTargetPosRot.pos;
        (*camera).at.y -= 150.0f32;
        // 0x3E8 ~ 5.49 degrees
        sp3A =
            ((curTargetPosRot.rot.y as libc::c_int - 0x7fff as libc::c_int) as
                 s16 as libc::c_int + 0x3e8 as libc::c_int) as s16;
        (*camera).eyeNext.x = Math_SinS(sp3A) * 780.0f32 + (*camera).at.x;
        (*camera).eye.x = (*camera).eyeNext.x;
        (*camera).eyeNext.y = (*camera).at.y;
        (*camera).eyeNext.z = Math_CosS(sp3A) * 780.0f32 + (*camera).at.z;
        (*camera).eye.z = (*camera).eyeNext.z;
        (*camera).eye.y = curTargetPosRot.pos.y;
        (*camera).eye.y =
            Camera_GetFloorY(camera, &mut (*camera).eye) + 20.0f32;
        *timer -= 1;
        return 1 as libc::c_int
    };
}
/* *
 * Flying with hookshot
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Special5(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut spA8: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut pad: s16 = 0;
    let mut spA4: s16 = 0;
    let mut sp7C: CamColChk =
        CamColChk{pos: Vec3f{x: 0., y: 0., z: 0.,},
                  norm: Vec3f{x: 0., y: 0., z: 0.,},
                  poly: 0 as *mut CollisionPoly,
                  sphNorm: VecSph{r: 0., pitch: 0, yaw: 0,},
                  bgId: 0,};
    let mut sp74: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut sp6C: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut sp64: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut sp5C: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut spec5: *mut Special5 =
        (*camera).paramData.as_mut_ptr() as *mut Special5;
    let mut anim: *mut Special5Anim = &mut (*spec5).anim;
    let mut temp_f0_2: f32_0 = 0.;
    let mut yOffset: f32_0 = 0.;
    yOffset = Player_GetHeight((*camera).player);
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let mut yNormal: f32_0 =
            1.0f32 +
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 -
                (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                       16 as libc::c_int + 46 as libc::c_int)
                                      as usize] as libc::c_int as
                    libc::c_float * 0.01f32 * (68.0f32 / yOffset);
        let fresh198 = values;
        values = values.offset(1);
        (*spec5).yOffset =
            (*fresh198).val as libc::c_int as libc::c_float * 0.01f32 *
                yOffset * yNormal;
        let fresh199 = values;
        values = values.offset(1);
        (*spec5).eyeDist = (*fresh199).val as f32_0;
        let fresh200 = values;
        values = values.offset(1);
        (*spec5).minDistForRot = (*fresh200).val as f32_0;
        let fresh201 = values;
        values = values.offset(1);
        (*spec5).timerInit = (*fresh201).val;
        let fresh202 = values;
        values = values.offset(1);
        (*spec5).pitch =
            ((*fresh202).val as libc::c_int as libc::c_float * 182.04167f32 +
                 0.5f32) as s16;
        let fresh203 = values;
        values = values.offset(1);
        (*spec5).fovTarget = (*fresh203).val as f32_0;
        let fresh204 = values;
        values = values.offset(1);
        (*spec5).atMaxLERPScale =
            (*fresh204).val as libc::c_int as libc::c_float * 0.01f32;
        let fresh205 = values;
        values = values.offset(1);
        (*spec5).interfaceFlags = (*fresh205).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    OLib_Vec3fDiffToVecSphGeo(&mut sp64, at, eye);
    OLib_Vec3fDiffToVecSphGeo(&mut sp5C, at, eyeNext);
    Actor_GetWorld(&mut spA8, (*camera).target);
    sCameraInterfaceFlags = (*spec5).interfaceFlags as s32;
    if (*camera).animState as libc::c_int == 0 as libc::c_int {
        (*camera).animState += 1;
        (*anim).animTimer = (*spec5).timerInit
    }
    if (*anim).animTimer as libc::c_int > 0 as libc::c_int {
        (*anim).animTimer -= 1
    } else if (*anim).animTimer as libc::c_int == 0 as libc::c_int {
        if (*camera).target.is_null() || (*(*camera).target).update.is_none()
           {
            (*camera).target = 0 as *mut Actor;
            return 1 as libc::c_int
        }
        (*anim).animTimer -= 1;
        if (*spec5).minDistForRot <
               OLib_Vec3fDist(&mut spA8.pos, &mut (*playerPosRot).pos) {
            sp6C.yaw = (*playerPosRot).rot.y;
            sp6C.pitch = -((*playerPosRot).rot.x as libc::c_int) as s16;
            sp6C.r = 20.0f32;
            Camera_Vec3fVecSphGeoAdd(&mut sp7C.pos, &mut spA8.pos, &mut sp6C);
            Camera_BGCheckInfo(camera, at, &mut sp7C);
            OLib_Vec3fToVecSphGeo(&mut sp6C, &mut sp7C.norm);
            spA4 =
                ((*playerPosRot).rot.y as libc::c_int -
                     sp6C.yaw as libc::c_int) as s16;
            sp74.r = (*spec5).eyeDist;
            temp_f0_2 = Rand_ZeroOne();
            sp74.yaw =
                (((*playerPosRot).rot.y as libc::c_int -
                      0x7fff as libc::c_int) as s16 as libc::c_int +
                     (if (spA4 as libc::c_int) < 0 as libc::c_int {
                          -((0x1553 as libc::c_int +
                                 (temp_f0_2 * 2730.0f32) as s16 as
                                     libc::c_int) as s16 as libc::c_int)
                      } else {
                          (0x1553 as libc::c_int +
                               (temp_f0_2 * 2730.0f32) as s16 as libc::c_int)
                              as s16 as libc::c_int
                      }) as s16 as libc::c_int) as s16;
            sp74.pitch = (*spec5).pitch;
            Camera_Vec3fVecSphGeoAdd(eyeNext, &mut spA8.pos, &mut sp74);
            *eye = *eyeNext;
            Camera_BGCheck(camera, &mut spA8.pos, eye);
        }
    }
    Camera_CalcAtDefault(camera, &mut sp5C, (*spec5).yOffset,
                         0 as libc::c_int as s16);
    (*camera).fov =
        Camera_LERPCeilF((*spec5).fovTarget, (*camera).fov,
                         (*camera).atLERPStepScale *
                             ((*gGameInfo).data[(2 as libc::c_int *
                                                     6 as libc::c_int *
                                                     16 as libc::c_int +
                                                     4 as libc::c_int) as
                                                    usize] as libc::c_int as
                                  libc::c_float * 0.01f32), 1.0f32);
    (*camera).roll =
        Camera_LERPCeilS(0 as libc::c_int as s16, (*camera).roll, 0.5f32,
                         0xa as libc::c_int as s16);
    (*camera).atLERPStepScale =
        Camera_ClampLERPScale(camera, (*spec5).atMaxLERPScale);
    return 1 as libc::c_int;
}
/* *
 * Camera's eye is fixed at points specified at D_8011DA6C / D_8011DA9C
 * depending on the player's position
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Special7(mut camera: *mut Camera) -> s32 {
    let mut spec7: *mut Special7 =
        (*camera).paramData.as_mut_ptr() as *mut Special7;
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut atTarget: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut yOffset: f32_0 = 0.;
    let mut temp_f0: f32_0 = 0.;
    yOffset = Player_GetHeight((*camera).player);
    if (*camera).animState as libc::c_int == 0 as libc::c_int {
        if (*(*camera).globalCtx).sceneNum as libc::c_int ==
               SCENE_JYASINZOU as libc::c_int {
            // Spirit Temple
            (*spec7).idx = 3 as libc::c_int as s16
        } else if (*playerPosRot).pos.x < 1500.0f32 {
            (*spec7).idx = 2 as libc::c_int as s16
        } else if (*playerPosRot).pos.y < 3000.0f32 {
            (*spec7).idx = 0 as libc::c_int as s16
        } else { (*spec7).idx = 1 as libc::c_int as s16 }
        (*camera).animState += 1;
        (*camera).roll = 0 as libc::c_int as s16
    }
    if (*camera).at.y < D_8011DACC[(*spec7).idx as usize] {
        atTarget = (*playerPosRot).pos;
        atTarget.y -= 20.0f32;
        Camera_LERPCeilVec3f(&mut atTarget, &mut (*camera).at, 0.4f32, 0.4f32,
                             0.10f32);
        (*camera).eyeNext = D_8011DA6C[(*spec7).idx as usize];
        (*camera).eye = (*camera).eyeNext;
        temp_f0 =
            ((*playerPosRot).pos.y - D_8011DADC[(*spec7).idx as usize]) /
                (D_8011DACC[(*spec7).idx as usize] -
                     D_8011DADC[(*spec7).idx as usize]);
        (*camera).roll =
            (D_8011DAEC[(*spec7).idx as usize] as libc::c_int as libc::c_float
                 * temp_f0) as s16;
        (*camera).fov = 20.0f32 * temp_f0 + 60.0f32
    } else {
        atTarget = (*playerPosRot).pos;
        atTarget.y += yOffset;
        Camera_LERPCeilVec3f(&mut atTarget, &mut (*camera).at, 0.4f32, 0.4f32,
                             0.1f32);
        (*camera).roll = 0 as libc::c_int as s16;
        (*camera).eyeNext = D_8011DA9C[(*spec7).idx as usize];
        (*camera).eye = (*camera).eyeNext;
        (*camera).fov = 70.0f32
    }
    (*camera).dist = OLib_Vec3fDist(&mut (*camera).at, &mut (*camera).eye);
    (*camera).atLERPStepScale = 0.0f32;
    (*camera).posOffset.x = (*camera).at.x - (*playerPosRot).pos.x;
    (*camera).posOffset.y = (*camera).at.y - (*playerPosRot).pos.y;
    (*camera).posOffset.z = (*camera).at.z - (*playerPosRot).pos.z;
    return 1 as libc::c_int;
}
/* *
 * Courtyard.
 * Camera's eye is fixed on the z plane, slides on the xy plane with link
 * When the camera's scene data changes the animation to the next "screen"
 * happens for 12 frames.  The camera's eyeNext is the scene's camera data's position
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Special6(mut camera: *mut Camera) -> s32 {
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut atOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut sceneCamPos: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut eyePosCalc: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut eyeAnim: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut atAnim: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut eyeAtOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut sceneCamData: *mut Vec3s = 0 as *mut Vec3s;
    let mut sceneCamRot: Vec3s = Vec3s{x: 0, y: 0, z: 0,};
    let mut fov: s16 = 0;
    let mut sp54: f32_0 = 0.;
    let mut timerF: f32_0 = 0.;
    let mut timerDivisor: f32_0 = 0.;
    let mut spec6: *mut Special6 =
        (*camera).paramData.as_mut_ptr() as *mut Special6;
    let mut anim: *mut Special6Anim = &mut (*spec6).anim;
    let mut pad: s32 = 0;
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let fresh206 = values;
        values = values.offset(1);
        (*spec6).interfaceFlags = (*fresh206).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    OLib_Vec3fDiffToVecSphGeo(&mut eyeAtOffset, eye, at);
    sceneCamData = Camera_GetCamBGData(camera);
    Camera_Vec3sToVec3f(&mut sceneCamPos,
                        &mut *sceneCamData.offset(0 as libc::c_int as isize));
    sceneCamRot = *sceneCamData.offset(1 as libc::c_int as isize);
    fov = (*sceneCamData.offset(2 as libc::c_int as isize)).x;
    if fov as libc::c_int == -(1 as libc::c_int) {
        fov = 6000 as libc::c_int as s16
    }
    if (fov as libc::c_int) < 361 as libc::c_int {
        fov = (fov as libc::c_int * 100 as libc::c_int) as s16
    }
    sCameraInterfaceFlags = (*spec6).interfaceFlags as s32;
    if (*eyeNext).x != sceneCamPos.x || (*eyeNext).y != sceneCamPos.y ||
           (*eyeNext).z != sceneCamPos.z ||
           (*camera).animState as libc::c_int == 0 as libc::c_int {
        // A change in the current scene's camera positon has been detected,
        // Change "screens"
        (*(*camera).player).actor.freezeTimer = 12 as libc::c_int as u16_0;
        sCameraInterfaceFlags =
            sCameraInterfaceFlags & 0xf0ff as libc::c_int |
                0x300 as libc::c_int;
        (*anim).initalPlayerY = (*playerPosRot).pos.y;
        (*anim).animTimer = 12 as libc::c_int as s16;
        *eyeNext = sceneCamPos;
        if (*camera).animState as libc::c_int == 0 as libc::c_int {
            (*camera).animState += 1
        }
    }
    if (*anim).animTimer as libc::c_int > 0 as libc::c_int {
        // In transition between "screens"
        timerF = (*anim).animTimer as f32_0;
        eyePosCalc = *eyeNext;
        eyePosCalc.x += ((*playerPosRot).pos.x - eyePosCalc.x) * 0.5f32;
        eyePosCalc.y +=
            ((*playerPosRot).pos.y - (*anim).initalPlayerY) * 0.2f32;
        eyeAnim = eyePosCalc;
        eyeAnim.y = Camera_LERPCeilF(eyePosCalc.y, (*eye).y, 0.5f32, 0.01f32);
        // set the at point to be 100 units from the eye looking at the
        // direction specified in the scene's camera data.
        atOffset.r = 100.0f32;
        atOffset.yaw = sceneCamRot.y;
        atOffset.pitch = -(sceneCamRot.x as libc::c_int) as s16;
        Camera_Vec3fVecSphGeoAdd(&mut atAnim, &mut eyeAnim, &mut atOffset);
        timerDivisor = 1.0f32 / timerF;
        (*eye).x += (eyeAnim.x - (*eye).x) * timerDivisor;
        (*eye).y += (eyeAnim.y - (*eye).y) * timerDivisor;
        (*eye).z += (eyeAnim.z - (*eye).z) * timerDivisor;
        (*at).x += (atAnim.x - (*at).x) * timerDivisor;
        (*at).y += (atAnim.y - (*at).y) * timerDivisor;
        (*at).z += (atAnim.z - (*at).z) * timerDivisor;
        (*camera).fov +=
            (fov as libc::c_int as libc::c_float * 0.01f32 - (*camera).fov) /
                (*anim).animTimer as libc::c_int as libc::c_float;
        (*anim).animTimer -= 1
    } else {
        // Camera following link on the x axis.
        sCameraInterfaceFlags &= 0xf0ff as libc::c_int;
        eyePosCalc = *eyeNext;
        eyePosCalc.x += ((*playerPosRot).pos.x - eyePosCalc.x) * 0.5f32;
        eyePosCalc.y +=
            ((*playerPosRot).pos.y - (*anim).initalPlayerY) * 0.2f32;
        *eye = eyePosCalc;
        (*eye).y = Camera_LERPCeilF(eyePosCalc.y, (*eye).y, 0.5f32, 0.01f32);
        // set the at point to be 100 units from the eye looking at the
        // direction specified in the scene's camera data.
        atOffset.r = 100.0f32;
        atOffset.yaw = sceneCamRot.y;
        atOffset.pitch = -(sceneCamRot.x as libc::c_int) as s16;
        Camera_Vec3fVecSphGeoAdd(at, eye, &mut atOffset);
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Special8(mut camera: *mut Camera) -> s32 {
    return Camera_Noop(camera);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Special9(mut camera: *mut Camera) -> s32 {
    let mut pad: s32 = 0;
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    let mut spAC: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut eyeAdjustment: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut atEyeOffsetGeo: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut playerYOffset: f32_0 = 0.;
    let mut pad3: s32 = 0;
    let mut playerPosRot: *mut PosRot = &mut (*camera).playerPosRot;
    let mut adjustedPlayerPosRot: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut yNormal: f32_0 = 0.;
    let mut spec9: *mut Special9 =
        (*camera).paramData.as_mut_ptr() as *mut Special9;
    let mut params: *mut Special9Params = &mut (*spec9).params;
    let mut anim: *mut Special9Anim = &mut (*params).anim;
    let mut pad4: s32 = 0;
    let mut camPosData: *mut Vec3s = 0 as *mut Vec3s;
    playerYOffset = Player_GetHeight((*camera).player);
    (*camera).unk_14C =
        ((*camera).unk_14C as libc::c_int & !(0x10 as libc::c_int)) as s16;
    yNormal =
        1.0f32 +
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 46 as libc::c_int) as
                                  usize] as libc::c_int as libc::c_float *
                0.01f32 -
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 46 as libc::c_int) as
                                  usize] as libc::c_int as libc::c_float *
                0.01f32 * (68.0f32 / playerYOffset);
    if (*camera).animState as libc::c_int == 0 as libc::c_int ||
           (*camera).animState as libc::c_int == 0xa as libc::c_int ||
           (*camera).animState as libc::c_int == 0x14 as libc::c_int ||
           (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 0 as libc::c_int) as
                                 usize] as libc::c_int != 0 {
        let mut values: *mut CameraModeValue =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        let fresh207 = values;
        values = values.offset(1);
        (*params).yOffset =
            (*fresh207).val as libc::c_int as libc::c_float * 0.01f32 *
                playerYOffset * yNormal;
        let fresh208 = values;
        values = values.offset(1);
        (*params).unk_04 = (*fresh208).val as f32_0;
        let fresh209 = values;
        values = values.offset(1);
        (*params).interfaceFlags = (*fresh209).val
    }
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           != 0 {
        Camera_CopyPREGToModeValues(camera);
    }
    if !(*spec9).doorParams.doorActor.is_null() {
        Actor_GetWorldPosShapeRot(&mut adjustedPlayerPosRot,
                                  (*spec9).doorParams.doorActor);
    } else {
        adjustedPlayerPosRot = *playerPosRot;
        adjustedPlayerPosRot.pos.y += playerYOffset + (*params).yOffset;
        adjustedPlayerPosRot.rot.x = 0 as libc::c_int as s16
    }
    OLib_Vec3fDiffToVecSphGeo(&mut atEyeOffsetGeo, at, eye);
    sCameraInterfaceFlags = (*params).interfaceFlags as s32;
    let mut current_block_70: u64;
    match (*camera).animState as libc::c_int {
        0 => {
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int &
                     !(0x4 as libc::c_int | 0x2 as libc::c_int)) as s16;
            (*camera).animState += 1;
            (*anim).targetYaw =
                if (if (*playerPosRot).rot.y as libc::c_int -
                           adjustedPlayerPosRot.rot.y as libc::c_int >=
                           0 as libc::c_int {
                        ((*playerPosRot).rot.y as libc::c_int) -
                            adjustedPlayerPosRot.rot.y as libc::c_int
                    } else {
                        -((*playerPosRot).rot.y as libc::c_int -
                              adjustedPlayerPosRot.rot.y as libc::c_int)
                    }) >= 0x4000 as libc::c_int {
                    (adjustedPlayerPosRot.rot.y as libc::c_int -
                         0x7fff as libc::c_int) as s16 as libc::c_int
                } else { adjustedPlayerPosRot.rot.y as libc::c_int } as s16;
            current_block_70 = 12494757165120417614;
        }
        1 => { current_block_70 = 12494757165120417614; }
        2 => { current_block_70 = 6830093769047841215; }
        3 => { current_block_70 = 8740638911239154796; }
        4 => { current_block_70 = 4854588732142293303; }
        _ => { current_block_70 = 7890945164767570132; }
    }
    match current_block_70 {
        12494757165120417614 => {
            (*spec9).doorParams.timer1 -= 1;
            if (*spec9).doorParams.timer1 as libc::c_int <= 0 as libc::c_int {
                (*camera).animState += 1;
                if (*params).interfaceFlags as libc::c_int & 1 as libc::c_int
                       != 0 {
                    camPosData = Camera_GetCamBGData(camera);
                    Camera_Vec3sToVec3f(eyeNext,
                                        &mut *camPosData.offset(0 as
                                                                    libc::c_int
                                                                    as
                                                                    isize));
                    *eye = *eyeNext;
                    spAC = *eye
                } else {
                    let mut yaw: s16 = 0;
                    // 0xE38 ~ 20 degrees
                    eyeAdjustment.pitch = 0xe38 as libc::c_int as s16;
                    // 0xAAA ~ 15 degrees.
                    yaw =
                        (0xaaa as libc::c_int *
                             (if (*(*camera).globalCtx).state.frames &
                                     1 as libc::c_int as libc::c_uint != 0 {
                                  1 as libc::c_int
                              } else { -(1 as libc::c_int) })) as s16;
                    eyeAdjustment.yaw =
                        ((*anim).targetYaw as libc::c_int +
                             yaw as libc::c_int) as s16;
                    eyeAdjustment.r = 200.0f32 * yNormal;
                    Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut eyeAdjustment);
                    *eye = *eyeNext;
                    spAC = *eye;
                    if Camera_CheckOOB(camera, &mut spAC,
                                       &mut (*playerPosRot).pos) != 0 {
                        yaw = -(yaw as libc::c_int) as s16;
                        eyeAdjustment.yaw =
                            ((*anim).targetYaw as libc::c_int +
                                 yaw as libc::c_int) as s16;
                        Camera_Vec3fVecSphGeoAdd(eyeNext, at,
                                                 &mut eyeAdjustment);
                        *eye = *eyeNext
                    }
                }
                current_block_70 = 6830093769047841215;
            } else { current_block_70 = 17019156190352891614; }
        }
        _ => { }
    }
    match current_block_70 {
        6830093769047841215 => {
            spAC = (*playerPosRot).pos;
            spAC.y += playerYOffset + (*params).yOffset;
            Camera_LERPCeilVec3f(&mut spAC, at, 0.25f32, 0.25f32, 0.1f32);
            (*spec9).doorParams.timer2 -= 1;
            if (*spec9).doorParams.timer2 as libc::c_int <= 0 as libc::c_int {
                (*camera).animState += 1;
                (*anim).targetYaw =
                    ((*anim).targetYaw as libc::c_int - 0x7fff as libc::c_int)
                        as s16;
                current_block_70 = 8740638911239154796;
            } else { current_block_70 = 17019156190352891614; }
        }
        _ => { }
    }
    match current_block_70 {
        8740638911239154796 => {
            spAC = (*playerPosRot).pos;
            spAC.y += playerYOffset + (*params).yOffset;
            Camera_LERPCeilVec3f(&mut spAC, at, 0.5f32, 0.5f32, 0.1f32);
            eyeAdjustment.pitch =
                Camera_LERPCeilS(0xaaa as libc::c_int as s16,
                                 atEyeOffsetGeo.pitch, 0.3f32,
                                 0xa as libc::c_int as s16);
            eyeAdjustment.yaw =
                Camera_LERPCeilS((*anim).targetYaw, atEyeOffsetGeo.yaw,
                                 0.3f32, 0xa as libc::c_int as s16);
            eyeAdjustment.r =
                Camera_LERPCeilF(60.0f32, atEyeOffsetGeo.r, 0.3f32, 1.0f32);
            Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut eyeAdjustment);
            *eye = *eyeNext;
            (*spec9).doorParams.timer3 -= 1;
            if (*spec9).doorParams.timer3 as libc::c_int <= 0 as libc::c_int {
                (*camera).animState += 1;
                current_block_70 = 4854588732142293303;
            } else { current_block_70 = 17019156190352891614; }
        }
        _ => { }
    }
    match current_block_70 {
        4854588732142293303 => {
            (*camera).animState += 1;
            current_block_70 = 7890945164767570132;
        }
        _ => { }
    }
    match current_block_70 {
        7890945164767570132 => {
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int |
                     (0x400 as libc::c_int | 0x10 as libc::c_int)) as s16;
            sCameraInterfaceFlags = 0 as libc::c_int;
            if (*camera).xzSpeed > 0.001f32 ||
                   !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                   usize].press.button as
                         libc::c_int | !(0x8000 as libc::c_int)) ==
                       0 as libc::c_int ||
                   !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                   usize].press.button as
                         libc::c_int | !(0x4000 as libc::c_int)) ==
                       0 as libc::c_int ||
                   !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                   usize].press.button as
                         libc::c_int | !(0x2 as libc::c_int)) ==
                       0 as libc::c_int ||
                   !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                   usize].press.button as
                         libc::c_int | !(0x4 as libc::c_int)) ==
                       0 as libc::c_int ||
                   !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                   usize].press.button as
                         libc::c_int | !(0x8 as libc::c_int)) ==
                       0 as libc::c_int ||
                   !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                   usize].press.button as
                         libc::c_int | !(0x1 as libc::c_int)) ==
                       0 as libc::c_int ||
                   !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                   usize].press.button as
                         libc::c_int | !(0x10 as libc::c_int)) ==
                       0 as libc::c_int ||
                   !((*D_8015BD7C).state.input[0 as libc::c_int as
                                                   usize].press.button as
                         libc::c_int | !(0x2000 as libc::c_int)) ==
                       0 as libc::c_int ||
                   (*params).interfaceFlags as libc::c_int &
                       0x8 as libc::c_int != 0 {
                Camera_ChangeSettingFlags(camera, (*camera).prevSetting,
                                          2 as libc::c_int as s16);
                (*camera).unk_14C =
                    ((*camera).unk_14C as libc::c_int |
                         (0x4 as libc::c_int | 0x2 as libc::c_int)) as s16
            }
        }
        _ => { }
    }
    spAC = (*playerPosRot).pos;
    spAC.y += playerYOffset;
    (*camera).dist = OLib_Vec3fDist(&mut spAC, eye);
    (*camera).posOffset.x = (*camera).at.x - (*playerPosRot).pos.x;
    (*camera).posOffset.y = (*camera).at.y - (*playerPosRot).pos.y;
    (*camera).posOffset.z = (*camera).at.z - (*playerPosRot).pos.z;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Create(mut view: *mut View,
                                       mut colCtx: *mut CollisionContext,
                                       mut globalCtx: *mut GlobalContext)
 -> *mut Camera {
    let mut newCamera: *mut Camera =
        ZeldaArena_MallocDebug(::std::mem::size_of::<Camera>() as
                                   libc::c_ulong,
                               b"../z_camera.c\x00" as *const u8 as
                                   *const libc::c_char, 9370 as libc::c_int)
            as *mut Camera;
    if !newCamera.is_null() {
        osSyncPrintf(b"\x1b[34mcamera: create --- allocate %d byte\x1b[m\n\x00"
                         as *const u8 as *const libc::c_char,
                     (::std::mem::size_of::<Camera>() as
                          libc::c_ulong).wrapping_mul(4 as libc::c_int as
                                                          libc::c_uint));
        Camera_Init(newCamera, view, colCtx, globalCtx);
    } else {
        osSyncPrintf(b"\x1b[41;37mcamera: create: not enough memory\n\x1b[m\x00"
                         as *const u8 as *const libc::c_char);
    }
    return newCamera;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Destroy(mut camera: *mut Camera) {
    if !camera.is_null() {
        osSyncPrintf(b"\x1b[34mcamera: destroy ---\x1b[m\n\x00" as *const u8
                         as *const libc::c_char);
        ZeldaArena_FreeDebug(camera as *mut libc::c_void,
                             b"../z_camera.c\x00" as *const u8 as
                                 *const libc::c_char, 9391 as libc::c_int);
    } else {
        osSyncPrintf(b"\x1b[43;30mcamera: destroy: already cleared\n\x1b[m\x00"
                         as *const u8 as *const libc::c_char);
    };
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Init(mut camera: *mut Camera,
                                     mut view: *mut View,
                                     mut colCtx: *mut CollisionContext,
                                     mut globalCtx: *mut GlobalContext) {
    let mut camP: *mut Camera = 0 as *mut Camera;
    let mut i: s32 = 0;
    let mut curUID: s16 = 0;
    let mut j: s16 = 0;
    func_80106860(camera as *mut libc::c_void, 0 as libc::c_int,
                  ::std::mem::size_of::<Camera>() as libc::c_ulong as size_t);
    if sInitRegs != 0 {
        i = 0 as libc::c_int;
        while i < sOREGInitCnt as libc::c_int {
            (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + i) as usize] =
                sOREGInit[i as usize];
            i += 1
        }
        i = 0 as libc::c_int;
        while i < sPREGInitCnt as libc::c_int {
            (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + i) as usize] =
                sPREGInit[i as usize];
            i += 1
        }
        DbCamera_Reset(camera, &mut D_8015BD80);
        sInitRegs = 0 as libc::c_int;
        (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 88 as libc::c_int) as
                              usize] = -(1 as libc::c_int) as s16
    }
    D_8015BD7C = globalCtx;
    (*camera).globalCtx = D_8015BD7C;
    DbCamera_Init(&mut D_8015BD80, camera);
    curUID = sNextUID;
    sNextUID += 1;
    while curUID as libc::c_int != 0 as libc::c_int {
        if curUID as libc::c_int == 0 as libc::c_int { sNextUID += 1 }
        j = 0 as libc::c_int as s16;
        while (j as libc::c_int) < 4 as libc::c_int {
            camP = (*(*camera).globalCtx).cameraPtrs[j as usize];
            if !camP.is_null() &&
                   curUID as libc::c_int == (*camP).uid as libc::c_int {
                break ;
            }
            j += 1
        }
        if j as libc::c_int == 4 as libc::c_int { break ; }
        let fresh210 = sNextUID;
        sNextUID = sNextUID + 1;
        curUID = fresh210
    }
    // ~ 90 degrees
    (*camera).inputDir.y = 0x3fff as libc::c_int as s16;
    (*camera).uid = curUID;
    (*camera).camDir = (*camera).inputDir;
    (*camera).rUpdateRateInv = 10.0f32;
    (*camera).yawUpdateRateInv = 10.0f32;
    (*camera).up.x = 0.0f32;
    (*camera).up.y = 1.0f32;
    (*camera).up.z = 0.0f32;
    (*camera).fov = 60.0f32;
    (*camera).pitchUpdateRateInv =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 7 as libc::c_int) as usize]
            as f32_0;
    (*camera).xzOffsetUpdateRate =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 2 as libc::c_int) as usize]
            as libc::c_int as libc::c_float * 0.01f32;
    (*camera).yOffsetUpdateRate =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 3 as libc::c_int) as usize]
            as libc::c_int as libc::c_float * 0.01f32;
    (*camera).fovUpdateRate =
        (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 4 as libc::c_int) as usize]
            as libc::c_int as libc::c_float * 0.01f32;
    sCameraShrinkWindowVal = 0x20 as libc::c_int;
    sCameraInterfaceAlpha = 0 as libc::c_int;
    (*camera).unk_14C = 0 as libc::c_int as s16;
    (*camera).prevSetting = CAM_SET_FREE0 as libc::c_int as s16;
    (*camera).setting = (*camera).prevSetting;
    (*camera).prevCamDataIdx = -(1 as libc::c_int) as s16;
    (*camera).camDataIdx = (*camera).prevCamDataIdx;
    (*camera).mode = 0 as libc::c_int as s16;
    (*camera).bgCheckId = 50 as libc::c_int as s16;
    (*camera).csId = 0x7fff as libc::c_int as s16;
    (*camera).timer = -(1 as libc::c_int) as s16;
    (*camera).unk_14C =
        ((*camera).unk_14C as libc::c_int | 0x4000 as libc::c_int) as s16;
    (*camera).up.y = 1.0f32;
    (*camera).up.x = 0.0f32;
    (*camera).up.z = (*camera).up.x;
    (*camera).skyboxOffset.z = 0 as libc::c_int as f32_0;
    (*camera).skyboxOffset.y = (*camera).skyboxOffset.z;
    (*camera).skyboxOffset.x = (*camera).skyboxOffset.y;
    (*camera).atLERPStepScale = 1 as libc::c_int as f32_0;
    sCameraInterfaceFlags = 0xff00 as libc::c_int;
    sDbgModeIdx = -(1 as libc::c_int);
    D_8011D3F0 = 3 as libc::c_int;
    osSyncPrintf(b"\x1b[34mcamera: initialize --- \x1b[m UID %d\n\x00" as
                     *const u8 as *const libc::c_char,
                 (*camera).uid as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn func_80057FC4(mut camera: *mut Camera) {
    if camera != &mut (*(*camera).globalCtx).mainCamera as *mut Camera {
        (*camera).setting = CAM_SET_FREE0 as libc::c_int as s16;
        (*camera).prevSetting = (*camera).setting;
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int & !(0x4 as libc::c_int)) as s16
    } else if (*(*(*camera).globalCtx).roomCtx.curRoom.mesh).polygon.type_0 as
                  libc::c_int != 1 as libc::c_int {
        match (*(*camera).globalCtx).roomCtx.curRoom.unk_03 as libc::c_int {
            1 => {
                Camera_ChangeDoorCam(camera, 0 as *mut Actor,
                                     -(99 as libc::c_int) as s16,
                                     0 as libc::c_int as f32_0,
                                     0 as libc::c_int as s16,
                                     18 as libc::c_int as s16,
                                     10 as libc::c_int as s16);
                (*camera).setting = CAM_SET_DUNGEON0 as libc::c_int as s16;
                (*camera).prevSetting = (*camera).setting
            }
            0 => {
                osSyncPrintf(b"camera: room type: default set field\n\x00" as
                                 *const u8 as *const libc::c_char);
                Camera_ChangeDoorCam(camera, 0 as *mut Actor,
                                     -(99 as libc::c_int) as s16,
                                     0 as libc::c_int as f32_0,
                                     0 as libc::c_int as s16,
                                     18 as libc::c_int as s16,
                                     10 as libc::c_int as s16);
                (*camera).setting = CAM_SET_NORMAL0 as libc::c_int as s16;
                (*camera).prevSetting = (*camera).setting
            }
            _ => {
                osSyncPrintf(b"camera: room type: default set etc (%d)\n\x00"
                                 as *const u8 as *const libc::c_char,
                             (*(*camera).globalCtx).roomCtx.curRoom.unk_03 as
                                 libc::c_int);
                Camera_ChangeDoorCam(camera, 0 as *mut Actor,
                                     -(99 as libc::c_int) as s16,
                                     0 as libc::c_int as f32_0,
                                     0 as libc::c_int as s16,
                                     18 as libc::c_int as s16,
                                     10 as libc::c_int as s16);
                (*camera).setting = CAM_SET_NORMAL0 as libc::c_int as s16;
                (*camera).prevSetting = (*camera).setting;
                (*camera).unk_14C =
                    ((*camera).unk_14C as libc::c_int | 4 as libc::c_int) as
                        s16
            }
        }
    } else {
        osSyncPrintf(b"camera: room type: prerender\n\x00" as *const u8 as
                         *const libc::c_char);
        (*camera).setting = CAM_SET_FREE0 as libc::c_int as s16;
        (*camera).prevSetting = (*camera).setting;
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int & !(0x4 as libc::c_int)) as s16
    };
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Stub80058140(mut camera: *mut Camera) { }
#[no_mangle]
pub unsafe extern "C" fn Camera_InitPlayerSettings(mut camera: *mut Camera,
                                                   mut player: *mut Player) {
    let mut playerPosShape: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut eyeNextAtOffset: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut bgId: s32 = 0;
    let mut floorPos: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut upXZ: s32 = 0;
    let mut playerYOffset: f32_0 = 0.;
    let mut eye: *mut Vec3f = &mut (*camera).eye;
    let mut at: *mut Vec3f = &mut (*camera).at;
    let mut eyeNext: *mut Vec3f = &mut (*camera).eyeNext;
    Actor_GetWorldPosShapeRot(&mut playerPosShape, &mut (*player).actor);
    playerYOffset = Player_GetHeight(player);
    (*camera).player = player;
    (*camera).playerPosRot = playerPosShape;
    eyeNextAtOffset.r = 180.0f32;
    (*camera).dist = eyeNextAtOffset.r;
    (*camera).inputDir.y = playerPosShape.rot.y;
    eyeNextAtOffset.yaw =
        ((*camera).inputDir.y as libc::c_int - 0x7fff as libc::c_int) as s16;
    eyeNextAtOffset.pitch = 0x71c as libc::c_int as s16;
    (*camera).inputDir.x = eyeNextAtOffset.pitch;
    (*camera).inputDir.z = 0 as libc::c_int as s16;
    (*camera).camDir = (*camera).inputDir;
    (*camera).xzSpeed = 0.0f32;
    (*camera).playerPosDelta.y = 0.0f32;
    (*camera).at = playerPosShape.pos;
    (*camera).at.y += playerYOffset;
    (*camera).posOffset.x = 0 as libc::c_int as f32_0;
    (*camera).posOffset.y = playerYOffset;
    (*camera).posOffset.z = 0 as libc::c_int as f32_0;
    Camera_Vec3fVecSphGeoAdd(eyeNext, at, &mut eyeNextAtOffset);
    *eye = *eyeNext;
    (*camera).roll = 0 as libc::c_int as s16;
    upXZ = 0 as libc::c_int;
    (*camera).up.z = upXZ as f32_0;
    (*camera).up.y = 1.0f32;
    (*camera).up.x = upXZ as f32_0;
    if Camera_GetFloorYNorm(camera, &mut floorPos, at, &mut bgId) !=
           -32000.0f32 {
        (*camera).bgCheckId = bgId as s16
    }
    (*camera).waterPrevCamIdx = -(1 as libc::c_int);
    (*camera).waterPrevCamSetting = -(1 as libc::c_int);
    (*camera).unk_14C =
        ((*camera).unk_14C as libc::c_int | 4 as libc::c_int) as s16;
    if camera == &mut (*(*camera).globalCtx).mainCamera as *mut Camera {
        sCameraInterfaceFlags = 0xb200 as libc::c_int
    } else { sCameraInterfaceFlags = 0 as libc::c_int }
    func_80057FC4(camera);
    (*camera).unk_14A = 0 as libc::c_int as s16;
    (*camera).paramFlags = 0 as libc::c_int as s16;
    (*camera).nextCamDataIdx = -(1 as libc::c_int) as s16;
    (*camera).atLERPStepScale = 1.0f32;
    Camera_CopyModeValuesToPREG(camera, (*camera).mode);
    Camera_QRegInit();
    osSyncPrintf(b"\x1b[34mcamera: personalize ---\x1b[m\n\x00" as *const u8
                     as *const libc::c_char);
    if (*camera).thisIdx as libc::c_int == 0 as libc::c_int {
        Camera_CheckWater(camera);
    };
}
#[no_mangle]
pub unsafe extern "C" fn Camera_ChangeStatus(mut camera: *mut Camera,
                                             mut status: s16) -> s16 {
    let mut values: *mut CameraModeValue = 0 as *mut CameraModeValue;
    let mut valueP: *mut CameraModeValue = 0 as *mut CameraModeValue;
    let mut i: s32 = 0;
    if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 82 as libc::c_int) as usize]
           != 0 {
        osSyncPrintf(b"camera: change camera status: cond %c%c\n\x00" as
                         *const u8 as *const libc::c_char,
                     if status as libc::c_int == 7 as libc::c_int {
                         'o' as i32
                     } else { 'x' as i32 },
                     if (*camera).status as libc::c_int != 7 as libc::c_int {
                         'o' as i32
                     } else { 'x' as i32 });
    }
    if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 82 as libc::c_int) as usize]
           != 0 {
        osSyncPrintf(b"camera: res: stat (%d/%d/%d)\n\x00" as *const u8 as
                         *const libc::c_char,
                     (*camera).thisIdx as libc::c_int,
                     (*camera).setting as libc::c_int,
                     (*camera).mode as libc::c_int);
    }
    if status as libc::c_int == 7 as libc::c_int &&
           (*camera).status as libc::c_int != 7 as libc::c_int {
        values =
            (*sCameraSettings[(*camera).setting as
                                  usize].cameraModes.offset((*camera).mode as
                                                                isize)).values;
        i = 0 as libc::c_int;
        while i <
                  (*sCameraSettings[(*camera).setting as
                                        usize].cameraModes.offset((*camera).mode
                                                                      as
                                                                      isize)).valueCnt
                      as libc::c_int {
            valueP = &mut *values.offset(i as isize) as *mut CameraModeValue;
            (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int +
                                   (*valueP).param as libc::c_int) as usize] =
                (*valueP).val;
            if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                                      16 as libc::c_int + 82 as libc::c_int)
                                     as usize] != 0 {
                osSyncPrintf(b"camera: change camera status: PREG(%02d) = %d\n\x00"
                                 as *const u8 as *const libc::c_char,
                             (*valueP).param as libc::c_int,
                             (*valueP).val as libc::c_int);
            }
            i += 1
        }
    }
    (*camera).status = status;
    return (*camera).status;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_PrintSettings(mut camera: *mut Camera) {
    let mut sp58: [libc::c_char; 8] = [0; 8];
    let mut sp50: [libc::c_char; 8] = [0; 8];
    let mut sp48: [libc::c_char; 8] = [0; 8];
    let mut i: s32 = 0;
    if (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           as libc::c_int & 1 as libc::c_int != 0 &&
           (*(*camera).globalCtx).activeCamera as libc::c_int ==
               (*camera).thisIdx as libc::c_int && gDbgCamEnabled == 0 {
        i = 0 as libc::c_int;
        while i < 4 as libc::c_int {
            if (*(*camera).globalCtx).cameraPtrs[i as usize].is_null() {
                sp58[i as usize] = '-' as i32 as libc::c_char;
                sp48[i as usize] = ' ' as i32 as libc::c_char
            } else {
                match (*(*(*camera).globalCtx).cameraPtrs[i as usize]).status
                          as libc::c_int {
                    0 => { sp58[i as usize] = 'c' as i32 as libc::c_char }
                    1 => { sp58[i as usize] = 'w' as i32 as libc::c_char }
                    3 => { sp58[i as usize] = 's' as i32 as libc::c_char }
                    7 => { sp58[i as usize] = 'a' as i32 as libc::c_char }
                    256 => { sp58[i as usize] = 'd' as i32 as libc::c_char }
                    _ => { sp58[i as usize] = '*' as i32 as libc::c_char }
                }
            }
            sp48[i as usize] = ' ' as i32 as libc::c_char;
            i += 1
        }
        sp58[i as usize] = '\u{0}' as i32 as libc::c_char;
        sp48[i as usize] = '\u{0}' as i32 as libc::c_char;
        sp48[(*(*camera).globalCtx).activeCamera as usize] =
            'a' as i32 as libc::c_char;
        func_8006376C(3 as libc::c_int as u8_0, 0x16 as libc::c_int as u8_0,
                      5 as libc::c_int as u8_0, sp58.as_mut_ptr());
        func_8006376C(3 as libc::c_int as u8_0, 0x16 as libc::c_int as u8_0,
                      1 as libc::c_int as u8_0, sp48.as_mut_ptr());
        func_8006376C(3 as libc::c_int as u8_0, 0x17 as libc::c_int as u8_0,
                      5 as libc::c_int as u8_0,
                      b"S:\x00" as *const u8 as *const libc::c_char);
        func_8006376C(5 as libc::c_int as u8_0, 0x17 as libc::c_int as u8_0,
                      4 as libc::c_int as u8_0,
                      sCameraSettingNames[(*camera).setting as
                                              usize].as_mut_ptr());
        func_8006376C(3 as libc::c_int as u8_0, 0x18 as libc::c_int as u8_0,
                      5 as libc::c_int as u8_0,
                      b"M:\x00" as *const u8 as *const libc::c_char);
        func_8006376C(5 as libc::c_int as u8_0, 0x18 as libc::c_int as u8_0,
                      4 as libc::c_int as u8_0,
                      sCameraModeNames[(*camera).mode as usize].as_mut_ptr());
        func_8006376C(3 as libc::c_int as u8_0, 0x19 as libc::c_int as u8_0,
                      5 as libc::c_int as u8_0,
                      b"F:\x00" as *const u8 as *const libc::c_char);
        func_8006376C(5 as libc::c_int as u8_0, 0x19 as libc::c_int as u8_0,
                      4 as libc::c_int as u8_0,
                      sCameraFunctionNames[(*sCameraSettings[(*camera).setting
                                                                 as
                                                                 usize].cameraModes.offset((*camera).mode
                                                                                               as
                                                                                               isize)).funcIdx
                                               as usize].as_mut_ptr());
        i = 0 as libc::c_int;
        if ((*camera).camDataIdx as libc::c_int) < 0 as libc::c_int {
            let fresh211 = i;
            i = i + 1;
            sp50[fresh211 as usize] = '-' as i32 as libc::c_char
        }
        // ! @bug: this code was clearly meaning to print `abs(camera->camDataIdx)` as a
        // ! one-or-two-digit number, instead of `i`.
        // "sp50[i++] = ..." matches here, but is undefined behavior due to conflicting
        // reads/writes between sequence points, triggering warnings. Work around by
        // putting i++ afterwards while on the same line.
        // clang-format off
        if (*camera).camDataIdx as libc::c_int / 10 as libc::c_int !=
               0 as libc::c_int {
            sp50[i as usize] =
                (i / 10 as libc::c_int + '0' as i32) as libc::c_char;
            i += 1
        }
        sp50[i as usize] =
            (i % 10 as libc::c_int + '0' as i32) as libc::c_char;
        i += 1;
        // clang-format on
        let fresh212 = i;
        i = i + 1;
        sp50[fresh212 as usize] = ' ' as i32 as libc::c_char;
        let fresh213 = i;
        i = i + 1;
        sp50[fresh213 as usize] = ' ' as i32 as libc::c_char;
        let fresh214 = i;
        i = i + 1;
        sp50[fresh214 as usize] = ' ' as i32 as libc::c_char;
        let fresh215 = i;
        i = i + 1;
        sp50[fresh215 as usize] = ' ' as i32 as libc::c_char;
        sp50[i as usize] = '\u{0}' as i32 as libc::c_char;
        func_8006376C(3 as libc::c_int as u8_0, 26 as libc::c_int as u8_0,
                      5 as libc::c_int as u8_0,
                      b"I:\x00" as *const u8 as *const libc::c_char);
        func_8006376C(5 as libc::c_int as u8_0, 26 as libc::c_int as u8_0,
                      4 as libc::c_int as u8_0, sp50.as_mut_ptr());
    };
}
#[no_mangle]
pub unsafe extern "C" fn Camera_CheckWater(mut camera: *mut Camera) -> s32 {
    let mut waterY: f32_0 = 0.;
    let mut newQuakeId: s16 = 0;
    let mut waterLightsIndex: s32 = 0;
    let mut waterPrevCamSetting: *mut s32 =
        &mut (*camera).waterPrevCamSetting;
    let mut waterCamIdx: s16 = 0;
    let mut quakeId: *mut s16 =
        &mut (*camera).waterQuakeId as *mut s32 as *mut s16;
    let mut player: *mut Player = (*camera).player;
    let mut prevBgId: s16 = 0;
    if (*camera).unk_14C as libc::c_int & 2 as libc::c_int == 0 ||
           sCameraSettings[(*camera).setting as usize].c2rust_unnamed.unk_00 &
               0x40000000 as libc::c_int as libc::c_uint != 0 {
        return 0 as libc::c_int
    }
    if (*camera).unk_14C as libc::c_int & 0x200 as libc::c_int != 0 {
        if (*player).stateFlags2 & 0x800 as libc::c_int as libc::c_uint != 0 {
            Camera_ChangeSettingFlags(camera,
                                      CAM_SET_PIVOT_WATER_SURFACE as
                                          libc::c_int as s16,
                                      6 as libc::c_int as s16);
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int |
                     0x8000 as libc::c_int as s16 as libc::c_int) as s16
        } else if (*camera).unk_14C as libc::c_int &
                      0x8000 as libc::c_int as s16 as libc::c_int != 0 {
            Camera_ChangeSettingFlags(camera, *waterPrevCamSetting as s16,
                                      6 as libc::c_int as s16);
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int &
                     !(0x8000 as libc::c_int as s16 as libc::c_int)) as s16
        }
    }
    if (*camera).unk_14C as libc::c_int &
           0x8000 as libc::c_int as s16 as libc::c_int == 0 {
        waterCamIdx = Camera_GetWaterBoxDataIdx(camera, &mut waterY) as s16;
        if waterCamIdx as libc::c_int == -(2 as libc::c_int) {
            // No camera data idx
            if (*camera).unk_14C as libc::c_int & 0x200 as libc::c_int == 0 {
                (*camera).unk_14C =
                    ((*camera).unk_14C as libc::c_int | 0x200 as libc::c_int)
                        as s16;
                (*camera).waterYPos = waterY;
                (*camera).waterPrevCamIdx = (*camera).camDataIdx as s32;
                *quakeId = -(1 as libc::c_int) as s16
            }
            if (*camera).playerGroundY != (*camera).playerPosRot.pos.y {
                prevBgId = (*camera).bgCheckId;
                (*camera).bgCheckId = 50 as libc::c_int as s16;
                Camera_ChangeSettingFlags(camera,
                                          CAM_SET_NORMAL3 as libc::c_int as
                                              s16, 2 as libc::c_int as s16);
                *waterPrevCamSetting = (*camera).setting as s32;
                (*camera).bgCheckId = prevBgId;
                (*camera).camDataIdx = -(2 as libc::c_int) as s16
            }
        } else if waterCamIdx as libc::c_int != -(1 as libc::c_int) {
            // player is in a water box
            if (*camera).unk_14C as libc::c_int & 0x200 as libc::c_int == 0 {
                (*camera).unk_14C =
                    ((*camera).unk_14C as libc::c_int | 0x200 as libc::c_int)
                        as s16;
                (*camera).waterYPos = waterY;
                (*camera).waterPrevCamIdx = (*camera).camDataIdx as s32;
                *quakeId = -(1 as libc::c_int) as s16
            }
            if (*camera).playerGroundY != (*camera).playerPosRot.pos.y {
                prevBgId = (*camera).bgCheckId;
                (*camera).bgCheckId = 50 as libc::c_int as s16;
                Camera_ChangeDataIdx(camera, waterCamIdx as s32);
                *waterPrevCamSetting = (*camera).setting as s32;
                (*camera).bgCheckId = prevBgId
            }
        } else if (*camera).unk_14C as libc::c_int & 0x200 as libc::c_int != 0
         {
            // player is out of a water box.
            osSyncPrintf(b"camera: water: off\n\x00" as *const u8 as
                             *const libc::c_char);
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int & !(0x200 as libc::c_int))
                    as s16;
            prevBgId = (*camera).bgCheckId;
            (*camera).bgCheckId = 50 as libc::c_int as s16;
            if (*camera).waterPrevCamIdx < 0 as libc::c_int {
                func_80057FC4(camera);
                (*camera).camDataIdx = -(1 as libc::c_int) as s16
            } else {
                Camera_ChangeDataIdx(camera, (*camera).waterPrevCamIdx);
            }
            (*camera).bgCheckId = prevBgId
        }
    }
    waterY =
        Camera_GetWaterSurface(camera, &mut (*camera).eye,
                               &mut waterLightsIndex);
    if waterY != -32000.0f32 {
        (*camera).waterYPos = waterY;
        if (*camera).unk_14C as libc::c_int & 0x100 as libc::c_int == 0 {
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int | 0x100 as libc::c_int) as
                    s16;
            osSyncPrintf(b"kankyo changed water, sound on\n\x00" as *const u8
                             as *const libc::c_char);
            Environment_EnableUnderwaterLights((*camera).globalCtx,
                                               waterLightsIndex);
            (*camera).unk_150 = 0x50 as libc::c_int as s16
        }
        Audio_SetExtraFilter(0x20 as libc::c_int as u8_0);
        if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 81 as libc::c_int) as
                                 usize] != 0 {
            Quake_RemoveFromIdx(*quakeId);
            *quakeId = -(1 as libc::c_int) as s16;
            (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                                   16 as libc::c_int + 81 as libc::c_int) as
                                  usize] = 0 as libc::c_int as s16
        }
        if *quakeId as libc::c_int == -(1 as libc::c_int) ||
               Quake_GetCountdown(*quakeId) as libc::c_int ==
                   0xa as libc::c_int {
            newQuakeId = Quake_Add(camera, 5 as libc::c_uint);
            *quakeId = newQuakeId;
            if newQuakeId as libc::c_int != 0 as libc::c_int {
                Quake_SetSpeed(*quakeId, 550 as libc::c_int as s16);
                Quake_SetQuakeValues(*quakeId, 1 as libc::c_int as s16,
                                     1 as libc::c_int as s16,
                                     180 as libc::c_int as s16,
                                     0 as libc::c_int as s16);
                Quake_SetCountdown(*quakeId, 1000 as libc::c_int as s16);
            }
        }
        if (*camera).unk_150 as libc::c_int > 0 as libc::c_int {
            (*camera).unk_150 -= 1;
            (*camera).unk_152 =
                ((*camera).unk_152 as libc::c_int | 8 as libc::c_int) as s16
        } else if (*(*camera).globalCtx).sceneNum as libc::c_int ==
                      0x49 as libc::c_int {
            (*camera).unk_152 =
                ((*camera).unk_152 as libc::c_int | 0x10 as libc::c_int) as
                    s16
        } else {
            (*camera).unk_152 =
                ((*camera).unk_152 as libc::c_int | 2 as libc::c_int) as s16
        }
    } else {
        if (*camera).unk_14C as libc::c_int & 0x100 as libc::c_int != 0 {
            (*camera).unk_14C =
                ((*camera).unk_14C as libc::c_int & !(0x100 as libc::c_int))
                    as s16;
            osSyncPrintf(b"kankyo changed water off, sound off\n\x00" as
                             *const u8 as *const libc::c_char);
            Environment_DisableUnderwaterLights((*camera).globalCtx);
            if *quakeId as libc::c_int != 0 as libc::c_int {
                Quake_RemoveFromIdx(*quakeId);
            }
            (*camera).unk_150 = 0 as libc::c_int as s16;
            (*camera).unk_152 = 0 as libc::c_int as s16
        }
        Audio_SetExtraFilter(0 as libc::c_int as u8_0);
    }
    panic!("Reached end of non-void function without returning");
    // ! @bug: doesn't always return a value, but sometimes does.
}
/* *
 * Sets the room to be hot camera quake flag
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_SetRoomHotFlag(mut camera: *mut Camera)
 -> s32 {
    (*camera).unk_152 =
        ((*camera).unk_152 as libc::c_int & !(1 as libc::c_int)) as s16;
    if (*(*camera).globalCtx).roomCtx.curRoom.unk_02 as libc::c_int ==
           3 as libc::c_int {
        (*camera).unk_152 =
            ((*camera).unk_152 as libc::c_int | 1 as libc::c_int) as s16
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_DbgChangeMode(mut camera: *mut Camera)
 -> s32 {
    let mut changeDir: s32 = 0 as libc::c_int;
    if gDbgCamEnabled == 0 &&
           (*(*camera).globalCtx).activeCamera as libc::c_int ==
               0 as libc::c_int {
        if !((*D_8015BD7C).state.input[2 as libc::c_int as usize].press.button
                 as libc::c_int | !(0x8 as libc::c_int)) == 0 as libc::c_int {
            osSyncPrintf(b"attention sound URGENCY\n\x00" as *const u8 as
                             *const libc::c_char);
            func_80078884(0x4837 as libc::c_int as u16_0);
        }
        if !((*D_8015BD7C).state.input[2 as libc::c_int as usize].press.button
                 as libc::c_int | !(0x4 as libc::c_int)) == 0 as libc::c_int {
            osSyncPrintf(b"attention sound NORMAL\n\x00" as *const u8 as
                             *const libc::c_char);
            func_80078884(0x480c as libc::c_int as u16_0);
        }
        if !((*D_8015BD7C).state.input[2 as libc::c_int as usize].press.button
                 as libc::c_int | !(0x1 as libc::c_int)) == 0 as libc::c_int {
            changeDir = 1 as libc::c_int
        }
        if !((*D_8015BD7C).state.input[2 as libc::c_int as usize].press.button
                 as libc::c_int | !(0x2 as libc::c_int)) == 0 as libc::c_int {
            changeDir = -(1 as libc::c_int)
        }
        if changeDir != 0 as libc::c_int {
            sDbgModeIdx = (sDbgModeIdx + changeDir) % 6 as libc::c_int;
            if Camera_ChangeSetting(camera, D_8011DAFC[sDbgModeIdx as usize])
                   > 0 as libc::c_int {
                osSyncPrintf(b"camera: force change SET to %s!\n\x00" as
                                 *const u8 as *const libc::c_char,
                             sCameraSettingNames[D_8011DAFC[sDbgModeIdx as
                                                                usize] as
                                                     usize].as_mut_ptr());
            }
        }
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn func_80058E8C(mut camera: *mut Camera) {
    static mut D_8011DB08: s16 = 0x3f0 as libc::c_int as s16;
    static mut D_8011DB0C: s16 = 0x156 as libc::c_int as s16;
    let mut pad3: s32 = 0;
    let mut sp60: f32_0 = 0.;
    let mut pad: s32 = 0;
    let mut pad1: s32 = 0;
    let mut pad4: s32 = 0;
    let mut phi_f2: f32_0 = 0.;
    let mut pad2: s32 = 0;
    let mut phi_f0: f32_0 = 0.;
    let mut phi_f20: f32_0 = 0.;
    let mut sp40: f32_0 = 0.;
    let mut sp3C: f32_0 = 0.;
    let mut sp38: f32_0 = 0.;
    let mut sp34: f32_0 = 0.;
    if (*camera).unk_152 as libc::c_int != 0 as libc::c_int {
        if (*camera).unk_152 as libc::c_int & 4 as libc::c_int != 0 {
            phi_f0 = 0.0f32;
            phi_f2 = 170.0f32;
            sp3C = 0.01f32;
            sp40 = -0.01f32;
            sp38 = 0.0f32;
            sp34 = 0.6f32;
            phi_f20 =
                (*camera).unk_150 as libc::c_int as libc::c_float / 60.0f32;
            sp60 = 1.0f32
        } else if (*camera).unk_152 as libc::c_int & 8 as libc::c_int != 0 {
            phi_f0 = 248.0f32;
            phi_f2 = -90.0f32;
            sp38 = 0.2f32;
            sp34 = 0.2f32;
            sp40 = -0.3f32;
            sp3C = 0.3f32;
            phi_f20 =
                (*camera).unk_150 as libc::c_int as libc::c_float / 80.0f32;
            sp60 = 1.0f32
        } else if (*camera).unk_152 as libc::c_int & 2 as libc::c_int != 0 {
            phi_f0 = 359.2f32;
            phi_f2 = -18.5f32;
            sp40 = 0.09f32;
            sp38 = 0.01f32;
            sp3C = 0.09f32;
            sp34 = 0.08f32;
            phi_f20 =
                (if (*camera).waterYPos - (*camera).eye.y > 150.0f32 {
                     1.0f32
                 } else {
                     ((*camera).waterYPos - (*camera).eye.y) / 150.0f32
                 }) * 0.45f32 + (*camera).speedRatio * 0.45f32;
            sp60 = phi_f20
        } else if (*camera).unk_152 as libc::c_int & 1 as libc::c_int != 0 {
            // hot room flag
            phi_f2 = 150.0f32;
            phi_f0 = 0.0f32;
            sp3C = 0.01f32;
            sp38 = 0.01f32;
            sp40 = -0.01f32;
            sp34 = 0.6f32;
            sp60 = 1.0f32;
            phi_f20 = 1.0f32
        } else { return }
        D_8011DB08 =
            (D_8011DB08 as libc::c_int +
                 (phi_f0 * 182.04167f32 + 0.5f32) as s16 as libc::c_int) as
                s16;
        D_8011DB0C =
            (D_8011DB0C as libc::c_int +
                 (phi_f2 * 182.04167f32 + 0.5f32) as s16 as libc::c_int) as
                s16;
        Math_CosS(D_8011DB08);
        Math_SinS(D_8011DB08);
        Math_SinS(D_8011DB0C);
        func_800AA76C(&mut (*(*camera).globalCtx).view, 0.0f32, 0.0f32,
                      0.0f32);
        func_800AA78C(&mut (*(*camera).globalCtx).view,
                      Math_SinS(D_8011DB0C) * (sp40 * phi_f20) + 1.0f32,
                      Math_CosS(D_8011DB0C) * (sp3C * phi_f20) + 1.0f32,
                      Math_CosS(D_8011DB08) * (sp38 * phi_f20) + 1.0f32);
        func_800AA7AC(&mut (*(*camera).globalCtx).view, sp34 * sp60);
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int | 0x40 as libc::c_int) as s16
    } else if (*camera).unk_14C as libc::c_int & 0x40 as libc::c_int != 0 {
        func_800AA814(&mut (*(*camera).globalCtx).view);
        (*camera).unk_14C =
            ((*camera).unk_14C as libc::c_int & !(0x40 as libc::c_int)) as s16
    };
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Update(mut camera: *mut Camera) -> Vec3s {
    static mut sOOBTimer: s32 = 0 as libc::c_int;
    let mut viewAt: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut viewEye: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut viewUp: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut viewFov: f32_0 = 0.;
    let mut spAC: Vec3f = Vec3f{x: 0., y: 0., z: 0.,};
    let mut bgId: s32 = 0;
    let mut playerGroundY: f32_0 = 0.;
    let mut playerXZSpeed: f32_0 = 0.;
    let mut eyeAtAngle: VecSph = VecSph{r: 0., pitch: 0, yaw: 0,};
    let mut camDataIdx: s16 = 0;
    let mut curPlayerPosRot: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    let mut quake: QuakeCamCalc =
        QuakeCamCalc{atOffset: Vec3f{x: 0., y: 0., z: 0.,},
                     eyeOffset: Vec3f{x: 0., y: 0., z: 0.,},
                     rotZ: 0,
                     unk_1A: 0,
                     zoom: 0,
                     unk_20: 0.,};
    let mut player: *mut Player = 0 as *mut Player;
    player =
        (*(*(*camera).globalCtx).cameraPtrs[0 as libc::c_int as
                                                usize]).player;
    if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 80 as libc::c_int) as usize]
           != 0 {
        osSyncPrintf(b"camera: in %x\n\x00" as *const u8 as
                         *const libc::c_char, camera);
    }
    if (*camera).status as libc::c_int == 0 as libc::c_int {
        if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 80 as libc::c_int) as
                                 usize] != 0 {
            osSyncPrintf(b"camera: cut out %x\n\x00" as *const u8 as
                             *const libc::c_char, camera);
        }
        return (*camera).inputDir
    }
    sUpdateCameraDirection = 0 as libc::c_int;
    if !(*camera).player.is_null() {
        Actor_GetWorldPosShapeRot(&mut curPlayerPosRot,
                                  &mut (*(*camera).player).actor);
        playerXZSpeed =
            OLib_Vec3fDistXZ(&mut curPlayerPosRot.pos,
                             &mut (*camera).playerPosRot.pos);
        (*camera).xzSpeed = playerXZSpeed;
        (*camera).speedRatio =
            OLib_ClampMaxDist(playerXZSpeed /
                                  (func_8002DCE4((*camera).player) *
                                       ((*gGameInfo).data[(2 as libc::c_int *
                                                               6 as
                                                                   libc::c_int
                                                               *
                                                               16 as
                                                                   libc::c_int
                                                               +
                                                               8 as
                                                                   libc::c_int)
                                                              as usize] as
                                            libc::c_int as libc::c_float *
                                            0.01f32)), 1.0f32);
        (*camera).playerPosDelta.x =
            curPlayerPosRot.pos.x - (*camera).playerPosRot.pos.x;
        (*camera).playerPosDelta.y =
            curPlayerPosRot.pos.y - (*camera).playerPosRot.pos.y;
        (*camera).playerPosDelta.z =
            curPlayerPosRot.pos.z - (*camera).playerPosRot.pos.z;
        spAC = curPlayerPosRot.pos;
        spAC.y += Player_GetHeight((*camera).player);
        playerGroundY =
            BgCheck_EntityRaycastFloor5((*camera).globalCtx,
                                        &mut (*(*camera).globalCtx).colCtx,
                                        &mut playerFloorPoly, &mut bgId,
                                        &mut (*(*camera).player).actor,
                                        &mut spAC);
        if playerGroundY != -32000.0f32 {
            // player is above ground.
            sOOBTimer = 0 as libc::c_int;
            (*camera).floorNorm.x =
                (*playerFloorPoly).normal.x as libc::c_int as libc::c_float *
                    (1.0f32 / 32767.0f32);
            (*camera).floorNorm.y =
                (*playerFloorPoly).normal.y as libc::c_int as libc::c_float *
                    (1.0f32 / 32767.0f32);
            (*camera).floorNorm.z =
                (*playerFloorPoly).normal.z as libc::c_int as libc::c_float *
                    (1.0f32 / 32767.0f32);
            (*camera).bgCheckId = bgId as s16;
            (*camera).playerGroundY = playerGroundY
        } else {
            // player is not above ground.
            sOOBTimer += 1;
            (*camera).floorNorm.x = 0.0f64 as f32_0;
            (*camera).floorNorm.y = 1.0f32;
            (*camera).floorNorm.z = 0.0f64 as f32_0
        }
        (*camera).playerPosRot = curPlayerPosRot;
        if sOOBTimer < 200 as libc::c_int {
            if (*camera).status as libc::c_int == 7 as libc::c_int {
                Camera_CheckWater(camera);
                Camera_SetRoomHotFlag(camera);
            }
            if (*camera).unk_14C as libc::c_int & 4 as libc::c_int == 0 {
                (*camera).nextCamDataIdx = -(1 as libc::c_int) as s16
            }
            if (*camera).unk_14C as libc::c_int & 1 as libc::c_int != 0 &&
                   (*camera).unk_14C as libc::c_int & 4 as libc::c_int != 0 &&
                   (*camera).unk_14C as libc::c_int & 0x400 as libc::c_int ==
                       0 &&
                   ((*camera).unk_14C as libc::c_int & 0x200 as libc::c_int ==
                        0 ||
                        (*player).currentBoots as libc::c_int ==
                            PLAYER_BOOTS_IRON as libc::c_int) &&
                   (*camera).unk_14C as libc::c_int &
                       0x8000 as libc::c_int as s16 as libc::c_int == 0 &&
                   playerGroundY != -32000.0f32 {
                camDataIdx =
                    Camera_GetDataIdxForPoly(camera, &mut bgId,
                                             playerFloorPoly) as s16;
                if camDataIdx as libc::c_int != -(1 as libc::c_int) {
                    (*camera).nextBGCheckId = bgId as s16;
                    if bgId == 50 as libc::c_int {
                        (*camera).nextCamDataIdx = camDataIdx
                    }
                }
            }
            if (*camera).nextCamDataIdx as libc::c_int != -(1 as libc::c_int)
                   && fabsf(curPlayerPosRot.pos.y - playerGroundY) < 2.0f32 &&
                   ((*camera).unk_14C as libc::c_int & 0x200 as libc::c_int ==
                        0 ||
                        (*player).currentBoots as libc::c_int ==
                            PLAYER_BOOTS_IRON as libc::c_int) {
                (*camera).bgCheckId = (*camera).nextBGCheckId;
                Camera_ChangeDataIdx(camera, (*camera).nextCamDataIdx as s32);
                (*camera).nextCamDataIdx = -(1 as libc::c_int) as s16
            }
        }
    }
    Camera_PrintSettings(camera);
    Camera_DbgChangeMode(camera);
    if (*camera).status as libc::c_int == 1 as libc::c_int {
        if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 80 as libc::c_int) as
                                 usize] != 0 {
            osSyncPrintf(b"camera: wait out %x\n\x00" as *const u8 as
                             *const libc::c_char, camera);
        }
        return (*camera).inputDir
    }
    (*camera).unk_14A = 0 as libc::c_int as s16;
    (*camera).unk_14C =
        ((*camera).unk_14C as libc::c_int &
             !(0x400 as libc::c_int | 0x20 as libc::c_int)) as s16;
    (*camera).unk_14C =
        ((*camera).unk_14C as libc::c_int | 0x10 as libc::c_int) as s16;
    if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 80 as libc::c_int) as usize]
           != 0 {
        osSyncPrintf(b"camera: engine (%d %d %d) %04x \n\x00" as *const u8 as
                         *const libc::c_char,
                     (*camera).setting as libc::c_int,
                     (*camera).mode as libc::c_int,
                     (*sCameraSettings[(*camera).setting as
                                           usize].cameraModes.offset((*camera).mode
                                                                         as
                                                                         isize)).funcIdx
                         as libc::c_int, (*camera).unk_14C as libc::c_int);
    }
    if sOOBTimer < 200 as libc::c_int {
        sCameraFunctions[(*sCameraSettings[(*camera).setting as
                                               usize].cameraModes.offset((*camera).mode
                                                                             as
                                                                             isize)).funcIdx
                             as
                             usize].expect("non-null function pointer")(camera);
    } else if !(*camera).player.is_null() {
        OLib_Vec3fDiffToVecSphGeo(&mut eyeAtAngle, &mut (*camera).at,
                                  &mut (*camera).eye);
        Camera_CalcAtDefault(camera, &mut eyeAtAngle, 0.0f32,
                             0 as libc::c_int as s16);
    }
    if (*camera).status as libc::c_int == 7 as libc::c_int {
        if gSaveContext.gameMode != 0 as libc::c_int &&
               gSaveContext.gameMode != 3 as libc::c_int {
            sCameraInterfaceFlags = 0 as libc::c_int;
            Camera_UpdateInterface(sCameraInterfaceFlags as s16);
        } else if D_8011D3F0 != 0 as libc::c_int &&
                      (*camera).thisIdx as libc::c_int == 0 as libc::c_int {
            D_8011D3F0 -= 1;
            sCameraInterfaceFlags = 0x3200 as libc::c_int;
            Camera_UpdateInterface(sCameraInterfaceFlags as s16);
        } else if (*(*camera).globalCtx).transitionMode as libc::c_int !=
                      0 as libc::c_int {
            sCameraInterfaceFlags = 0xf200 as libc::c_int;
            Camera_UpdateInterface(sCameraInterfaceFlags as s16);
        } else if (*(*camera).globalCtx).csCtx.state as libc::c_int !=
                      CS_STATE_IDLE as libc::c_int {
            sCameraInterfaceFlags = 0x3200 as libc::c_int;
            Camera_UpdateInterface(sCameraInterfaceFlags as s16);
        } else { Camera_UpdateInterface(sCameraInterfaceFlags as s16); }
    }
    if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 80 as libc::c_int) as usize]
           != 0 {
        osSyncPrintf(b"camera: shrink_and_bitem %x(%d)\n\x00" as *const u8 as
                         *const libc::c_char, sCameraInterfaceFlags,
                     (*(*camera).globalCtx).transitionMode as libc::c_int);
    }
    if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 80 as libc::c_int) as usize]
           != 0 {
        osSyncPrintf(b"camera: engine (%s(%d) %s(%d) %s(%d)) ok!\n\x00" as
                         *const u8 as *const libc::c_char,
                     &mut *sCameraSettingNames.as_mut_ptr().offset((*camera).setting
                                                                       as
                                                                       isize)
                         as *mut [libc::c_char; 12],
                     (*camera).setting as libc::c_int,
                     &mut *sCameraModeNames.as_mut_ptr().offset((*camera).mode
                                                                    as isize)
                         as *mut [libc::c_char; 12],
                     (*camera).mode as libc::c_int,
                     &mut *sCameraFunctionNames.as_mut_ptr().offset((*(*sCameraSettings.as_mut_ptr().offset((*camera).setting
                                                                                                                as
                                                                                                                isize)).cameraModes.offset((*camera).mode
                                                                                                                                               as
                                                                                                                                               isize)).funcIdx
                                                                        as
                                                                        isize)
                         as *mut [libc::c_char; 8],
                     (*sCameraSettings[(*camera).setting as
                                           usize].cameraModes.offset((*camera).mode
                                                                         as
                                                                         isize)).funcIdx
                         as libc::c_int);
    }
    // enable/disable debug cam
    if !((*D_8015BD7C).state.input[2 as libc::c_int as usize].press.button as
             libc::c_int | !(0x1000 as libc::c_int)) == 0 as libc::c_int {
        gDbgCamEnabled ^= 1 as libc::c_int;
        if gDbgCamEnabled != 0 {
            DbgCamera_Enable(&mut D_8015BD80, camera);
        } else if (*(*camera).globalCtx).csCtx.state as libc::c_int !=
                      CS_STATE_IDLE as libc::c_int {
            func_80064534((*camera).globalCtx,
                          &mut (*(*camera).globalCtx).csCtx);
        }
    }
    // Debug cam update
    if gDbgCamEnabled != 0 {
        (*(*camera).globalCtx).view.fovy = D_8015BD80.fov;
        DbCamera_Update(&mut D_8015BD80, camera);
        func_800AA358(&mut (*(*camera).globalCtx).view, &mut D_8015BD80.eye,
                      &mut D_8015BD80.at, &mut D_8015BD80.unk_1C);
        if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                                  16 as libc::c_int + 80 as libc::c_int) as
                                 usize] != 0 {
            osSyncPrintf(b"camera: debug out\n\x00" as *const u8 as
                             *const libc::c_char);
        }
        return D_8015BD80.sub.unk_104A
    }
    (*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int * 16 as libc::c_int
                           + 0 as libc::c_int) as usize] =
        ((*gGameInfo).data[(2 as libc::c_int * 6 as libc::c_int *
                                16 as libc::c_int + 0 as libc::c_int) as
                               usize] as libc::c_int & !(8 as libc::c_int)) as
            s16;
    if (*camera).status as libc::c_int == 3 as libc::c_int {
        return (*camera).inputDir
    }
    // setting bgCheckId to the ret of Quake_Calc, and checking that
    // is required, it doesn't make too much sense though.
    bgId = Quake_Calc(camera, &mut quake) as s32;
    if bgId != 0 as libc::c_int &&
           (*camera).setting as libc::c_int !=
               CAM_SET_TURN_AROUND as libc::c_int {
        viewAt.x = (*camera).at.x + quake.atOffset.x;
        viewAt.y = (*camera).at.y + quake.atOffset.y;
        viewAt.z = (*camera).at.z + quake.atOffset.z;
        viewEye.x = (*camera).eye.x + quake.eyeOffset.x;
        viewEye.y = (*camera).eye.y + quake.eyeOffset.y;
        viewEye.z = (*camera).eye.z + quake.eyeOffset.z;
        OLib_Vec3fDiffToVecSphGeo(&mut eyeAtAngle, &mut viewEye, &mut viewAt);
        Camera_CalcUpFromPitchYawRoll(&mut viewUp,
                                      (eyeAtAngle.pitch as libc::c_int +
                                           quake.rotZ as libc::c_int) as s16,
                                      (eyeAtAngle.yaw as libc::c_int +
                                           quake.unk_1A as libc::c_int) as
                                          s16, (*camera).roll);
        viewFov =
            (*camera).fov +
                quake.zoom as f32_0 * (360.0001525f32 / 65535.0f32)
    } else {
        viewAt = (*camera).at;
        viewEye = (*camera).eye;
        OLib_Vec3fDiffToVecSphGeo(&mut eyeAtAngle, &mut viewEye, &mut viewAt);
        Camera_CalcUpFromPitchYawRoll(&mut viewUp, eyeAtAngle.pitch,
                                      eyeAtAngle.yaw, (*camera).roll);
        viewFov = (*camera).fov
    }
    if (*camera).paramFlags as libc::c_int & 4 as libc::c_int != 0 {
        (*camera).paramFlags =
            ((*camera).paramFlags as libc::c_int & !(4 as libc::c_int)) as
                s16;
        viewUp = (*camera).up
    } else { (*camera).up = viewUp }
    (*camera).skyboxOffset = quake.eyeOffset;
    func_80058E8C(camera);
    if (*(*camera).globalCtx).sceneNum as libc::c_int ==
           SCENE_SPOT00 as libc::c_int && (*camera).fov < 59.0f32 {
        View_SetScale(&mut (*(*camera).globalCtx).view, 0.79f32);
    } else { View_SetScale(&mut (*(*camera).globalCtx).view, 1.0f32); }
    (*(*camera).globalCtx).view.fovy = viewFov;
    func_800AA358(&mut (*(*camera).globalCtx).view, &mut viewEye, &mut viewAt,
                  &mut viewUp);
    (*camera).camDir.x = eyeAtAngle.pitch;
    (*camera).camDir.y = eyeAtAngle.yaw;
    (*camera).camDir.z = 0 as libc::c_int as s16;
    if sUpdateCameraDirection == 0 as libc::c_int {
        (*camera).inputDir.x = eyeAtAngle.pitch;
        (*camera).inputDir.y = eyeAtAngle.yaw;
        (*camera).inputDir.z = 0 as libc::c_int as s16
    }
    if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 81 as libc::c_int) as usize]
           != 0 {
        osSyncPrintf(b"dir  (%d) %d(%f) %d(%f) 0(0) \n\x00" as *const u8 as
                         *const libc::c_char, sUpdateCameraDirection,
                     (*camera).inputDir.x as libc::c_int,
                     ((*camera).inputDir.x as f32_0 *
                          (360.0001525f32 / 65535.0f32)) as libc::c_double,
                     (*camera).inputDir.y as libc::c_int,
                     ((*camera).inputDir.y as f32_0 *
                          (360.0001525f32 / 65535.0f32)) as libc::c_double);
        osSyncPrintf(b"real (%d) %d(%f) %d(%f) 0(0) \n\x00" as *const u8 as
                         *const libc::c_char, sUpdateCameraDirection,
                     (*camera).camDir.x as libc::c_int,
                     ((*camera).camDir.x as f32_0 *
                          (360.0001525f32 / 65535.0f32)) as libc::c_double,
                     (*camera).camDir.y as libc::c_int,
                     ((*camera).camDir.y as f32_0 *
                          (360.0001525f32 / 65535.0f32)) as libc::c_double);
    }
    if (*camera).timer as libc::c_int != -(1 as libc::c_int) &&
           !((*D_8015BD7C).state.input[0 as libc::c_int as usize].press.button
                 as libc::c_int | !(0x100 as libc::c_int)) == 0 as libc::c_int
       {
        (*camera).timer = 0 as libc::c_int as s16
    }
    if (*gGameInfo).data[(3 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 80 as libc::c_int) as usize]
           != 0 {
        osSyncPrintf(b"camera: out (%f %f %f) (%f %f %f)\n\x00" as *const u8
                         as *const libc::c_char,
                     (*camera).at.x as libc::c_double,
                     (*camera).at.y as libc::c_double,
                     (*camera).at.z as libc::c_double,
                     (*camera).eye.x as libc::c_double,
                     (*camera).eye.y as libc::c_double,
                     (*camera).eye.z as libc::c_double);
        osSyncPrintf(b"camera: dir (%f %d(%f) %d(%f)) (%f)\n\x00" as *const u8
                         as *const libc::c_char,
                     eyeAtAngle.r as libc::c_double,
                     eyeAtAngle.pitch as libc::c_int,
                     (eyeAtAngle.pitch as f32_0 *
                          (360.0001525f32 / 65535.0f32)) as libc::c_double,
                     eyeAtAngle.yaw as libc::c_int,
                     (eyeAtAngle.yaw as f32_0 * (360.0001525f32 / 65535.0f32))
                         as libc::c_double, (*camera).fov as libc::c_double);
        if !(*camera).player.is_null() {
            osSyncPrintf(b"camera: foot(%f %f %f) dist (%f)\n\x00" as
                             *const u8 as *const libc::c_char,
                         curPlayerPosRot.pos.x as libc::c_double,
                         curPlayerPosRot.pos.y as libc::c_double,
                         curPlayerPosRot.pos.z as libc::c_double,
                         (*camera).dist as libc::c_double);
        }
    }
    return (*camera).inputDir;
}
/* *
 * When the camera's timer is 0, change the camera to its parent
 */
#[no_mangle]
pub unsafe extern "C" fn Camera_Finish(mut camera: *mut Camera) {
    let mut mainCam: *mut Camera =
        (*(*camera).globalCtx).cameraPtrs[0 as libc::c_int as usize];
    let mut player: *mut Player =
        (*(*camera).globalCtx).actorCtx.actorLists[ACTORCAT_PLAYER as
                                                       libc::c_int as
                                                       usize].head as
            *mut Player;
    if (*camera).timer as libc::c_int == 0 as libc::c_int {
        Gameplay_ChangeCameraStatus((*camera).globalCtx,
                                    (*camera).parentCamIdx,
                                    7 as libc::c_int as s16);
        if (*camera).parentCamIdx as libc::c_int == 0 as libc::c_int &&
               (*camera).csId as libc::c_int != 0 as libc::c_int {
            (*player).actor.freezeTimer = 0 as libc::c_int as u16_0;
            (*player).stateFlags1 &=
                !(0x20000000 as libc::c_int) as libc::c_uint;
            if (*player).csMode as libc::c_int != 0 as libc::c_int {
                func_8002DF54((*camera).globalCtx, &mut (*player).actor,
                              7 as libc::c_int as u8_0);
                osSyncPrintf(b"camera: player demo end!!\n\x00" as *const u8
                                 as *const libc::c_char);
            }
            (*mainCam).unk_14C =
                ((*mainCam).unk_14C as libc::c_int | 8 as libc::c_int) as s16
        }
        if (*(*(*camera).globalCtx).cameraPtrs[(*camera).childCamIdx as
                                                   usize]).parentCamIdx as
               libc::c_int == (*camera).thisIdx as libc::c_int {
            (*(*(*camera).globalCtx).cameraPtrs[(*camera).childCamIdx as
                                                    usize]).parentCamIdx =
                (*camera).parentCamIdx
        }
        if (*(*(*camera).globalCtx).cameraPtrs[(*camera).parentCamIdx as
                                                   usize]).childCamIdx as
               libc::c_int == (*camera).thisIdx as libc::c_int {
            (*(*(*camera).globalCtx).cameraPtrs[(*camera).parentCamIdx as
                                                    usize]).childCamIdx =
                (*camera).childCamIdx
        }
        if (*(*(*camera).globalCtx).cameraPtrs[(*camera).parentCamIdx as
                                                   usize]).thisIdx as
               libc::c_int == 0 as libc::c_int {
            (*(*(*camera).globalCtx).cameraPtrs[(*camera).parentCamIdx as
                                                    usize]).animState =
                0 as libc::c_int as s16
        }
        (*camera).parentCamIdx = 0 as libc::c_int as s16;
        (*camera).childCamIdx = (*camera).parentCamIdx;
        (*camera).timer = -(1 as libc::c_int) as s16;
        (*(*camera).globalCtx).envCtx.fillScreen = 0 as libc::c_int as u8_0;
        Gameplay_ClearCamera((*camera).globalCtx, (*camera).thisIdx);
    };
}
#[no_mangle]
pub unsafe extern "C" fn func_8005A02C(mut camera: *mut Camera) -> s32 {
    (*camera).unk_14C =
        ((*camera).unk_14C as libc::c_int | 0xc as libc::c_int) as s16;
    (*camera).unk_14C =
        ((*camera).unk_14C as libc::c_int &
             !(0x1000 as libc::c_int | 0x8 as libc::c_int)) as s16;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_ChangeModeFlags(mut camera: *mut Camera,
                                                mut mode: s16,
                                                mut flags: u8_0) -> s32 {
    static mut modeChangeFlags: s32 = 0 as libc::c_int;
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 89 as libc::c_int) as usize]
           != 0 {
        osSyncPrintf(b"+=+(%d)+=+ recive request -> %s\n\x00" as *const u8 as
                         *const libc::c_char,
                     (*(*camera).globalCtx).state.frames,
                     sCameraModeNames[mode as usize].as_mut_ptr());
    }
    if (*camera).unk_14C as libc::c_int & 0x20 as libc::c_int != 0 &&
           flags as libc::c_int == 0 as libc::c_int {
        (*camera).unk_14A =
            ((*camera).unk_14A as libc::c_int | 0x20 as libc::c_int) as s16;
        return -(1 as libc::c_int)
    }
    if sCameraSettings[(*camera).setting as usize].c2rust_unnamed.unk_00 &
           0x3fffffff as libc::c_int as libc::c_uint &
           ((1 as libc::c_int) << mode as libc::c_int) as libc::c_uint == 0 {
        if mode as libc::c_int == CAM_MODE_FIRSTPERSON as libc::c_int {
            osSyncPrintf(b"camera: error sound\n\x00" as *const u8 as
                             *const libc::c_char);
            func_80078884(0x4806 as libc::c_int as u16_0);
        }
        if (*camera).mode as libc::c_int != CAM_MODE_NORMAL as libc::c_int {
            osSyncPrintf(b"\x1b[43;30mcamera: change camera mode: force NORMAL: %s %s refused\n\x1b[m\x00"
                             as *const u8 as *const libc::c_char,
                         sCameraSettingNames[(*camera).setting as
                                                 usize].as_mut_ptr(),
                         sCameraModeNames[mode as usize].as_mut_ptr());
            (*camera).mode = CAM_MODE_NORMAL as libc::c_int as s16;
            Camera_CopyModeValuesToPREG(camera, (*camera).mode);
            func_8005A02C(camera);
            return (0xc0000000 as libc::c_uint | mode as libc::c_uint) as s32
        } else {
            (*camera).unk_14A =
                ((*camera).unk_14A as libc::c_int | 0x20 as libc::c_int) as
                    s16;
            (*camera).unk_14A =
                ((*camera).unk_14A as libc::c_int | 2 as libc::c_int) as s16;
            return 0 as libc::c_int
        }
    } else {
        if mode as libc::c_int == (*camera).mode as libc::c_int &&
               flags as libc::c_int == 0 as libc::c_int {
            (*camera).unk_14A =
                ((*camera).unk_14A as libc::c_int | 0x20 as libc::c_int) as
                    s16;
            (*camera).unk_14A =
                ((*camera).unk_14A as libc::c_int | 2 as libc::c_int) as s16;
            return -(1 as libc::c_int)
        }
        (*camera).unk_14A =
            ((*camera).unk_14A as libc::c_int | 0x20 as libc::c_int) as s16;
        (*camera).unk_14A =
            ((*camera).unk_14A as libc::c_int | 2 as libc::c_int) as s16;
        Camera_CopyModeValuesToPREG(camera, mode);
        modeChangeFlags = 0 as libc::c_int;
        match mode as libc::c_int {
            6 => { modeChangeFlags = 0x20 as libc::c_int }
            4 => { modeChangeFlags = 4 as libc::c_int }
            2 => {
                if !(*camera).target.is_null() &&
                       (*(*camera).target).id as libc::c_int !=
                           ACTOR_EN_BOOM as libc::c_int {
                    modeChangeFlags = 8 as libc::c_int
                }
            }
            1 | 3 | 8 | 15 | 19 => { modeChangeFlags = 2 as libc::c_int }
            _ => { }
        }
        match (*camera).mode as libc::c_int {
            6 => {
                if modeChangeFlags & 0x20 as libc::c_int != 0 {
                    (*camera).animState = 0xa as libc::c_int as s16
                }
            }
            1 => {
                if modeChangeFlags & 0x10 as libc::c_int != 0 {
                    (*camera).animState = 0xa as libc::c_int as s16
                }
                modeChangeFlags |= 1 as libc::c_int
            }
            17 => { modeChangeFlags |= 1 as libc::c_int }
            2 => {
                if modeChangeFlags & 8 as libc::c_int != 0 {
                    (*camera).animState = 0xa as libc::c_int as s16
                }
                modeChangeFlags |= 1 as libc::c_int
            }
            4 => {
                if modeChangeFlags & 4 as libc::c_int != 0 {
                    (*camera).animState = 0xa as libc::c_int as s16
                }
                modeChangeFlags |= 1 as libc::c_int
            }
            8 | 15 | 19 => { modeChangeFlags |= 1 as libc::c_int }
            0 => {
                if modeChangeFlags & 0x10 as libc::c_int != 0 {
                    (*camera).animState = 0xa as libc::c_int as s16
                }
            }
            _ => { }
        }
        modeChangeFlags &= !(0x10 as libc::c_int);
        if (*camera).status as libc::c_int == 7 as libc::c_int {
            match modeChangeFlags {
                1 => { func_80078884(0 as libc::c_int as u16_0); }
                2 => {
                    if (*(*camera).globalCtx).roomCtx.curRoom.unk_03 as
                           libc::c_int == 1 as libc::c_int {
                        func_80078884(0x4837 as libc::c_int as u16_0);
                    } else { func_80078884(0x480c as libc::c_int as u16_0); }
                }
                4 => { func_80078884(0x4837 as libc::c_int as u16_0); }
                8 => { func_80078884(0x480c as libc::c_int as u16_0); }
                _ => { }
            }
        }
        func_8005A02C(camera);
        (*camera).mode = mode;
        return (0x80000000 as libc::c_uint | mode as libc::c_uint) as s32
    };
}
#[no_mangle]
pub unsafe extern "C" fn Camera_ChangeMode(mut camera: *mut Camera,
                                           mut mode: s16) -> s32 {
    return Camera_ChangeModeFlags(camera, mode, 0 as libc::c_int as u8_0);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_CheckValidMode(mut camera: *mut Camera,
                                               mut mode: s16) -> s32 {
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 89 as libc::c_int) as usize]
           as libc::c_int != 0 as libc::c_int {
        osSyncPrintf(b"+=+=+=+ recive asking -> %s (%s)\n\x00" as *const u8 as
                         *const libc::c_char,
                     sCameraModeNames[mode as usize].as_mut_ptr(),
                     sCameraSettingNames[(*camera).setting as
                                             usize].as_mut_ptr());
    }
    if sCameraSettings[(*camera).setting as
                           usize].c2rust_unnamed.c2rust_unnamed.validModes()
           as libc::c_int & (1 as libc::c_int) << mode as libc::c_int == 0 {
        return 0 as libc::c_int
    } else if mode as libc::c_int == (*camera).mode as libc::c_int {
        return -(1 as libc::c_int)
    } else {
        return (mode as libc::c_uint | 0x80000000 as libc::c_uint) as s32
    };
}
#[no_mangle]
pub unsafe extern "C" fn Camera_ChangeSettingFlags(mut camera: *mut Camera,
                                                   mut setting: s16,
                                                   mut flags: s16) -> s16 {
    if (*camera).unk_14A as libc::c_int & 1 as libc::c_int != 0 {
        if (sCameraSettings[(*camera).setting as usize].c2rust_unnamed.unk_00
                & 0xf000000 as libc::c_int as libc::c_uint) >>
               0x18 as libc::c_int >=
               (sCameraSettings[setting as usize].c2rust_unnamed.unk_00 &
                    0xf000000 as libc::c_int as libc::c_uint) >>
                   0x18 as libc::c_int {
            (*camera).unk_14A =
                ((*camera).unk_14A as libc::c_int | 0x10 as libc::c_int) as
                    s16;
            return -(2 as libc::c_int) as s16
        }
    }
    if (setting as libc::c_int == CAM_SET_MEADOW_BIRDS_EYE as libc::c_int ||
            setting as libc::c_int == CAM_SET_MEADOW_UNUSED as libc::c_int) &&
           gSaveContext.linkAge == 0 as libc::c_int &&
           (*(*camera).globalCtx).sceneNum as libc::c_int ==
               SCENE_SPOT05 as libc::c_int {
        (*camera).unk_14A =
            ((*camera).unk_14A as libc::c_int | 0x10 as libc::c_int) as s16;
        return -(5 as libc::c_int) as s16
    }
    if setting as libc::c_int == CAM_SET_NONE as libc::c_int ||
           setting as libc::c_int >= CAM_SET_MAX as libc::c_int {
        osSyncPrintf(b"\x1b[41;37mcamera: error: illegal camera set (%d) !!!!\n\x1b[m\x00"
                         as *const u8 as *const libc::c_char,
                     setting as libc::c_int);
        return -(99 as libc::c_int) as s16
    }
    if setting as libc::c_int == (*camera).setting as libc::c_int &&
           flags as libc::c_int & 1 as libc::c_int == 0 {
        (*camera).unk_14A =
            ((*camera).unk_14A as libc::c_int | 0x10 as libc::c_int) as s16;
        if flags as libc::c_int & 2 as libc::c_int == 0 {
            (*camera).unk_14A =
                ((*camera).unk_14A as libc::c_int | 1 as libc::c_int) as s16
        }
        return -(1 as libc::c_int) as s16
    }
    (*camera).unk_14A =
        ((*camera).unk_14A as libc::c_int | 0x10 as libc::c_int) as s16;
    if flags as libc::c_int & 2 as libc::c_int == 0 {
        (*camera).unk_14A =
            ((*camera).unk_14A as libc::c_int | 1 as libc::c_int) as s16
    }
    (*camera).unk_14C =
        ((*camera).unk_14C as libc::c_int | 0xc as libc::c_int) as s16;
    (*camera).unk_14C =
        ((*camera).unk_14C as libc::c_int & !(0x1008 as libc::c_int)) as s16;
    if sCameraSettings[(*camera).setting as usize].c2rust_unnamed.unk_00 &
           0x40000000 as libc::c_int as libc::c_uint == 0 {
        (*camera).prevSetting = (*camera).setting
    }
    if flags as libc::c_int & 8 as libc::c_int != 0 {
        (*camera).camDataIdx = (*camera).prevCamDataIdx;
        (*camera).prevCamDataIdx = -(1 as libc::c_int) as s16
    } else if flags as libc::c_int & 4 as libc::c_int == 0 {
        if sCameraSettings[(*camera).setting as usize].c2rust_unnamed.unk_00 &
               0x40000000 as libc::c_int as libc::c_uint == 0 {
            (*camera).prevCamDataIdx = (*camera).camDataIdx
        }
        (*camera).camDataIdx = -(1 as libc::c_int) as s16
    }
    (*camera).setting = setting;
    if Camera_ChangeModeFlags(camera, (*camera).mode,
                              1 as libc::c_int as u8_0) >= 0 as libc::c_int {
        Camera_CopyModeValuesToPREG(camera, (*camera).mode);
    }
    osSyncPrintf(b"\x1b[1m%06u:\x1b[m camera: change camera[%d] set %s\n\x00"
                     as *const u8 as *const libc::c_char,
                 (*(*camera).globalCtx).state.frames,
                 (*camera).thisIdx as libc::c_int,
                 sCameraSettingNames[(*camera).setting as
                                         usize].as_mut_ptr());
    return setting;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_ChangeSetting(mut camera: *mut Camera,
                                              mut setting: s16) -> s32 {
    return Camera_ChangeSettingFlags(camera, setting, 0 as libc::c_int as s16)
               as s32;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_ChangeDataIdx(mut camera: *mut Camera,
                                              mut camDataIdx: s32) -> s32 {
    let mut newCameraSetting: s16 = 0;
    let mut settingChangeSuccessful: s16 = 0;
    if camDataIdx == -(1 as libc::c_int) ||
           camDataIdx == (*camera).camDataIdx as libc::c_int {
        (*camera).unk_14A =
            ((*camera).unk_14A as libc::c_int | 0x40 as libc::c_int) as s16;
        return -(1 as libc::c_int)
    }
    if (*camera).unk_14A as libc::c_int & 0x40 as libc::c_int == 0 {
        newCameraSetting = Camera_GetCamDataSetting(camera, camDataIdx);
        (*camera).unk_14A =
            ((*camera).unk_14A as libc::c_int | 0x40 as libc::c_int) as s16;
        settingChangeSuccessful =
            (Camera_ChangeSettingFlags(camera, newCameraSetting,
                                       5 as libc::c_int as s16) as libc::c_int
                 >= 0 as libc::c_int) as libc::c_int as s16;
        if settingChangeSuccessful as libc::c_int != 0 ||
               sCameraSettings[(*camera).setting as
                                   usize].c2rust_unnamed.unk_00 &
                   0x80000000 as libc::c_uint != 0 {
            (*camera).camDataIdx = camDataIdx as s16;
            (*camera).unk_14A =
                ((*camera).unk_14A as libc::c_int | 4 as libc::c_int) as s16;
            Camera_CopyModeValuesToPREG(camera, (*camera).mode);
        } else if (settingChangeSuccessful as libc::c_int) <
                      -(1 as libc::c_int) {
            // ! @bug: This is likely checking the wrong value. The actual return of Camera_ChangeSettingFlags or
            // camDataIdx would make more sense.
            osSyncPrintf(b"\x1b[41;37mcamera: error: illegal camera ID (%d) !! (%d|%d|%d)\n\x1b[m\x00"
                             as *const u8 as *const libc::c_char, camDataIdx,
                         (*camera).thisIdx as libc::c_int,
                         0x32 as libc::c_int,
                         newCameraSetting as libc::c_int);
        }
        return (0x80000000 as libc::c_uint | camDataIdx as libc::c_uint) as
                   s32
    }
    panic!("Reached end of non-void function without returning");
}
#[no_mangle]
pub unsafe extern "C" fn Camera_GetInputDir(mut dst: *mut Vec3s,
                                            mut camera: *mut Camera)
 -> *mut Vec3s {
    if gDbgCamEnabled != 0 {
        *dst = D_8015BD80.sub.unk_104A;
        return dst
    } else { *dst = (*camera).inputDir; return dst };
}
#[no_mangle]
pub unsafe extern "C" fn Camera_GetInputDirPitch(mut camera: *mut Camera)
 -> s16 {
    let mut dir: Vec3s = Vec3s{x: 0, y: 0, z: 0,};
    Camera_GetInputDir(&mut dir, camera);
    return dir.x;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_GetInputDirYaw(mut camera: *mut Camera)
 -> s16 {
    let mut dir: Vec3s = Vec3s{x: 0, y: 0, z: 0,};
    Camera_GetInputDir(&mut dir, camera);
    return dir.y;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_GetCamDir(mut dst: *mut Vec3s,
                                          mut camera: *mut Camera)
 -> *mut Vec3s {
    if gDbgCamEnabled != 0 {
        *dst = D_8015BD80.sub.unk_104A;
        return dst
    } else { *dst = (*camera).camDir; return dst };
}
#[no_mangle]
pub unsafe extern "C" fn Camera_GetCamDirPitch(mut camera: *mut Camera)
 -> s16 {
    let mut camDir: Vec3s = Vec3s{x: 0, y: 0, z: 0,};
    Camera_GetCamDir(&mut camDir, camera);
    return camDir.x;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_GetCamDirYaw(mut camera: *mut Camera) -> s16 {
    let mut camDir: Vec3s = Vec3s{x: 0, y: 0, z: 0,};
    Camera_GetCamDir(&mut camDir, camera);
    return camDir.y;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_AddQuake(mut camera: *mut Camera,
                                         mut arg1: s32, mut y: s16,
                                         mut countdown: s32) -> s32 {
    let mut quakeIdx: s16 = 0;
    quakeIdx = Quake_Add(camera, 3 as libc::c_int as u32_0);
    if quakeIdx as libc::c_int == 0 as libc::c_int { return 0 as libc::c_int }
    Quake_SetSpeed(quakeIdx, 0x61a8 as libc::c_int as s16);
    Quake_SetQuakeValues(quakeIdx, y, 0 as libc::c_int as s16,
                         0 as libc::c_int as s16, 0 as libc::c_int as s16);
    Quake_SetCountdown(quakeIdx, countdown as s16);
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_SetParam(mut camera: *mut Camera,
                                         mut param: s32,
                                         mut value: *mut libc::c_void)
 -> s32 {
    let mut pad: [s32; 3] = [0; 3];
    if !value.is_null() {
        match param {
            1 => {
                (*camera).paramFlags =
                    ((*camera).paramFlags as libc::c_int &
                         !(0x10 as libc::c_int | 0x8 as libc::c_int |
                               0x1 as libc::c_int)) as s16;
                (*camera).at = *(value as *mut Vec3f)
            }
            16 => {
                (*camera).paramFlags =
                    ((*camera).paramFlags as libc::c_int &
                         !(0x10 as libc::c_int | 0x8 as libc::c_int |
                               0x1 as libc::c_int)) as s16;
                (*camera).targetPosRot.pos = *(value as *mut Vec3f)
            }
            8 => {
                if !((*camera).setting as libc::c_int ==
                         CAM_SET_CS_C as libc::c_int ||
                         (*camera).setting as libc::c_int ==
                             CAM_SET_CS_ATTENTION as libc::c_int) {
                    (*camera).target = value as *mut Actor;
                    (*camera).paramFlags =
                        ((*camera).paramFlags as libc::c_int &
                             !(0x10 as libc::c_int | 0x8 as libc::c_int |
                                   0x1 as libc::c_int)) as s16
                }
            }
            2 => {
                (*camera).eyeNext = *(value as *mut Vec3f);
                (*camera).eye = (*camera).eyeNext
            }
            4 => { (*camera).up = *(value as *mut Vec3f) }
            64 => {
                (*camera).roll =
                    (*(value as *mut f32_0) * 182.04167f32 + 0.5f32) as s16
            }
            32 => { (*camera).fov = *(value as *mut f32_0) }
            _ => { return 0 as libc::c_int }
        }
        (*camera).paramFlags =
            ((*camera).paramFlags as libc::c_int | param) as s16
    } else { return 0 as libc::c_int }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_UnsetParam(mut camera: *mut Camera,
                                           mut param: s16) -> s32 {
    (*camera).paramFlags =
        ((*camera).paramFlags as libc::c_int & !(param as libc::c_int)) as
            s16;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn func_8005AC48(mut camera: *mut Camera, mut arg1: s16)
 -> s32 {
    (*camera).unk_14C = arg1;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_ResetAnim(mut camera: *mut Camera) -> s32 {
    (*camera).animState = 0 as libc::c_int as s16;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_SetCSParams(mut camera: *mut Camera,
                                            mut atPoints:
                                                *mut CutsceneCameraPoint,
                                            mut eyePoints:
                                                *mut CutsceneCameraPoint,
                                            mut player: *mut Player,
                                            mut relativeToPlayer: s16)
 -> s32 {
    let mut playerPosRot: PosRot =
        PosRot{pos: Vec3f{x: 0., y: 0., z: 0.,},
               rot: Vec3s{x: 0, y: 0, z: 0,},};
    (*camera).data0 = atPoints as *mut libc::c_void;
    (*camera).data1 = eyePoints as *mut libc::c_void;
    (*camera).data2 = relativeToPlayer;
    if (*camera).data2 as libc::c_int != 0 as libc::c_int {
        (*camera).player = player;
        Actor_GetWorldPosShapeRot(&mut playerPosRot, &mut (*player).actor);
        (*camera).playerPosRot = playerPosRot;
        (*camera).nextCamDataIdx = -(1 as libc::c_int) as s16;
        (*camera).xzSpeed = 0.0f32;
        (*camera).speedRatio = 0.0f32
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn func_8005ACFC(mut camera: *mut Camera, mut arg1: s16)
 -> s16 {
    (*camera).unk_14C =
        ((*camera).unk_14C as libc::c_int | arg1 as libc::c_int) as s16;
    return (*camera).unk_14C;
}
#[no_mangle]
pub unsafe extern "C" fn func_8005AD1C(mut camera: *mut Camera, mut arg1: s16)
 -> s16 {
    (*camera).unk_14C =
        ((*camera).unk_14C as libc::c_int & !(arg1 as libc::c_int)) as s16;
    return (*camera).unk_14C;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_ChangeDoorCam(mut camera: *mut Camera,
                                              mut doorActor: *mut Actor,
                                              mut camDataIdx: s16,
                                              mut arg3: f32_0,
                                              mut timer1: s16,
                                              mut timer2: s16,
                                              mut timer3: s16) -> s32 {
    let mut doorParams: *mut DoorParams =
        (*camera).paramData.as_mut_ptr() as *mut DoorParams;
    if (*camera).setting as libc::c_int == CAM_SET_CS_ATTENTION as libc::c_int
           || (*camera).setting as libc::c_int == CAM_SET_DOORC as libc::c_int
       {
        return 0 as libc::c_int
    }
    (*doorParams).doorActor = doorActor;
    (*doorParams).timer1 = timer1;
    (*doorParams).timer2 = timer2;
    (*doorParams).timer3 = timer3;
    (*doorParams).camDataIdx = camDataIdx;
    if camDataIdx as libc::c_int == -(99 as libc::c_int) {
        Camera_CopyModeValuesToPREG(camera, (*camera).mode);
        return -(99 as libc::c_int)
    }
    if camDataIdx as libc::c_int == -(1 as libc::c_int) {
        Camera_ChangeSetting(camera, CAM_SET_DOORC as libc::c_int as s16);
        osSyncPrintf(b".... change default door camera (set %d)\n\x00" as
                         *const u8 as *const libc::c_char,
                     CAM_SET_DOORC as libc::c_int);
    } else {
        let mut setting: s32 =
            Camera_GetCamDataSetting(camera, camDataIdx as s32) as s32;
        (*camera).unk_14A =
            ((*camera).unk_14A as libc::c_int | 0x40 as libc::c_int) as s16;
        if Camera_ChangeSetting(camera, setting as s16) >= 0 as libc::c_int {
            (*camera).camDataIdx = camDataIdx;
            (*camera).unk_14A =
                ((*camera).unk_14A as libc::c_int | 4 as libc::c_int) as s16
        }
        osSyncPrintf(b"....change door camera ID %d (set %d)\n\x00" as
                         *const u8 as *const libc::c_char,
                     (*camera).camDataIdx as libc::c_int,
                     (*camera).setting as libc::c_int);
    }
    Camera_CopyModeValuesToPREG(camera, (*camera).mode);
    return -(1 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn Camera_Copy(mut dstCamera: *mut Camera,
                                     mut srcCamera: *mut Camera) -> s32 {
    let mut pad: s32 = 0;
    (*dstCamera).posOffset.x = 0.0f32;
    (*dstCamera).posOffset.y = 0.0f32;
    (*dstCamera).posOffset.z = 0.0f32;
    (*dstCamera).atLERPStepScale = 0.1f32;
    (*dstCamera).at = (*srcCamera).at;
    (*dstCamera).eyeNext = (*srcCamera).eye;
    (*dstCamera).eye = (*dstCamera).eyeNext;
    (*dstCamera).dist =
        OLib_Vec3fDist(&mut (*dstCamera).at, &mut (*dstCamera).eye);
    (*dstCamera).fov = (*srcCamera).fov;
    (*dstCamera).roll = (*srcCamera).roll;
    func_80043B60(dstCamera);
    if !(*dstCamera).player.is_null() {
        Actor_GetWorld(&mut (*dstCamera).playerPosRot,
                       &mut (*(*dstCamera).player).actor);
        (*dstCamera).posOffset.x =
            (*dstCamera).at.x - (*dstCamera).playerPosRot.pos.x;
        (*dstCamera).posOffset.y =
            (*dstCamera).at.y - (*dstCamera).playerPosRot.pos.y;
        (*dstCamera).posOffset.z =
            (*dstCamera).at.z - (*dstCamera).playerPosRot.pos.z;
        (*dstCamera).dist =
            OLib_Vec3fDist(&mut (*dstCamera).playerPosRot.pos,
                           &mut (*dstCamera).eye);
        (*dstCamera).xzOffsetUpdateRate = 1.0f32;
        (*dstCamera).yOffsetUpdateRate = 1.0f32
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_GetDbgCamEnabled() -> s32 {
    return gDbgCamEnabled;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_GetSkyboxOffset(mut dst: *mut Vec3f,
                                                mut camera: *mut Camera)
 -> *mut Vec3f {
    *dst = (*camera).skyboxOffset;
    return dst;
}
#[no_mangle]
pub unsafe extern "C" fn Camera_SetCameraData(mut camera: *mut Camera,
                                              mut setDataFlags: s16,
                                              mut data0: *mut libc::c_void,
                                              mut data1: *mut libc::c_void,
                                              mut data2: s16, mut data3: s16,
                                              mut arg6: s32) {
    if setDataFlags as libc::c_int & 0x1 as libc::c_int != 0 {
        (*camera).data0 = data0
    }
    if setDataFlags as libc::c_int & 0x2 as libc::c_int != 0 {
        (*camera).data1 = data1
    }
    if setDataFlags as libc::c_int & 0x4 as libc::c_int != 0 {
        (*camera).data2 = data2
    }
    if setDataFlags as libc::c_int & 0x8 as libc::c_int != 0 {
        (*camera).data3 = data3
    }
    if setDataFlags as libc::c_int & 0x10 as libc::c_int != 0 {
        osSyncPrintf(b"\x1b[41;37mcamera: setCameraData: last argument not alive!\n\x1b[m\x00"
                         as *const u8 as *const libc::c_char);
    };
}
#[no_mangle]
pub unsafe extern "C" fn Camera_QRegInit() -> s32 {
    if (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                              16 as libc::c_int + 0 as libc::c_int) as usize]
           == 0 {
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 2 as libc::c_int) as usize]
            = 1 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 10 as libc::c_int) as
                              usize] = -(1 as libc::c_int) as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 11 as libc::c_int) as
                              usize] = 100 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 12 as libc::c_int) as
                              usize] = 80 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 20 as libc::c_int) as
                              usize] = 90 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 21 as libc::c_int) as
                              usize] = 10 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 22 as libc::c_int) as
                              usize] = 10 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 23 as libc::c_int) as
                              usize] = 50 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 24 as libc::c_int) as
                              usize] = 6000 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 25 as libc::c_int) as
                              usize] = 240 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 26 as libc::c_int) as
                              usize] = 40 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 27 as libc::c_int) as
                              usize] = 85 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 28 as libc::c_int) as
                              usize] = 55 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 29 as libc::c_int) as
                              usize] = 87 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 30 as libc::c_int) as
                              usize] = 23 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 31 as libc::c_int) as
                              usize] = 20 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 32 as libc::c_int) as
                              usize] = 4 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 33 as libc::c_int) as
                              usize] = 5 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 50 as libc::c_int) as
                              usize] = 1 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 51 as libc::c_int) as
                              usize] = 20 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 52 as libc::c_int) as
                              usize] = 200 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 53 as libc::c_int) as
                              usize] = 1 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 54 as libc::c_int) as
                              usize] = 15 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 55 as libc::c_int) as
                              usize] = 60 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 56 as libc::c_int) as
                              usize] = 15 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 57 as libc::c_int) as
                              usize] = 30 as libc::c_int as s16;
        (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int *
                               16 as libc::c_int + 58 as libc::c_int) as
                              usize] = 0 as libc::c_int as s16
    }
    (*gGameInfo).data[(4 as libc::c_int * 6 as libc::c_int * 16 as libc::c_int
                           + 65 as libc::c_int) as usize] =
        50 as libc::c_int as s16;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn func_8005B198() -> s32 { return D_8011D3AC; }
#[no_mangle]
pub unsafe extern "C" fn func_8005B1A4(mut camera: *mut Camera) -> s16 {
    (*camera).unk_14C =
        ((*camera).unk_14C as libc::c_int | 0x8 as libc::c_int) as s16;
    if (*camera).thisIdx as libc::c_int == 0 as libc::c_int &&
           (*(*camera).globalCtx).activeCamera as libc::c_int !=
               0 as libc::c_int {
        (*(*(*camera).globalCtx).cameraPtrs[(*(*camera).globalCtx).activeCamera
                                                as usize]).unk_14C =
            ((*(*(*camera).globalCtx).cameraPtrs[(*(*camera).globalCtx).activeCamera
                                                     as usize]).unk_14C as
                 libc::c_int | 0x8 as libc::c_int) as s16;
        return (*(*camera).globalCtx).activeCamera
    }
    return (*camera).thisIdx;
}
